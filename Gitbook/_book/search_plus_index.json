{"./":{"url":"./","title":"简介","keywords":"","body":"关于本站 ROS操作指南 2023/9/5 1 介绍 欢迎来到 🎉 ROS操作指南网站™ 🎉，本站是一个用于教学和个人相关的展示与分享的网站！ 😄先简单自我介绍一下，本人目前从事于 ROS机器人运动控制 相关工作，讲授《机器人操作系统》和《机器人竞赛实用技术》两门课程！ 💪目前主要在复刻 WheelTec 移动机器人，包括下位机STM32和上位机ROS层面工作，对这项工作感兴趣的小伙伴可以加入进来~ 2 探究 ⌛️本学习是永无止境的，学的越多，才会发现自己的很多不足之处。在各自的领域，尽心耕耘，一份努力一份收获，多学习，多记录自己学到的知识，并能够很好的总结，不断提升自己的能力，也能分享给他人，授人以渔! 👉本站主要用于记录自己在ROS领域学习和实践的一些知识和经验，以及优秀案例分享~ 3 期待 ✉️如需投稿相关文章，请将文章以及相关附件发送到下面的联系邮箱即可。 👌有需要提出建议或者意见反馈，也请发送邮件至联系邮箱，或者到留言板进行留言，并留下您的联系方式，我将会逐一反馈您的问题或者建议！ 4 联系 📧 163 邮箱：qie73@166.com 📧 QQ 邮箱：348887362@qq.com 5 提示 😉目前站点还在持续的维护和完善中，相关的文章也在逐步的整理和优化中，若发现错误请帮忙反馈哦🚀🚀🚀~~~new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter1.html":{"url":"Markdown/Ubuntu/chapter1.html","title":"1 讲义","keywords":"","body":"1 讲义 1 此部分为《机器人操作系统》课程 Ubuntu 讲义 2 标记可选的内容为方便使用的一些工具，不安装不影响上课使用 3 如果长期使用Ubuntu，建议安装双系统，双系统安装教程：https://pan.baidu.com/s/1KY8TvfUYmCk_W7X6Djf9jA 提取码：6666   1）用U盘引导安装或者安装好后启动出现黑屏的情况，有可能是NVIDIA显卡驱动的问题。可以参考这个视频解决问题：https://pan.baidu.com/s/1BNxMQTIdZpLbFEHvVtTwmA 提取码：6666   2）安装后没有网络连接的，或者键盘之类设备有问题的，可能是驱动程序引起的。可以参考这个视频解决问题：https://pan.baidu.com/s/1imdzgyeiK8zE0yBrRjNwFA 提取码：6666 备注：此部分内容摘自B站@机器人工匠阿杰new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter1-1.html":{"url":"Markdown/Ubuntu/chapter1-1.html","title":"1.1 VirtualBox和Ubuntu安装","keywords":"","body":"1.1 VirtualBox 和 Ubuntu安装 [danger] 注意1 所有涉及到使用路径的地方(软件安装路径、虚拟机路径等)，都不要使用中文2 标记可选的内容为方便使用的一些工具，不安装不影响上课使用 1.1.1 VirtualBox安装和设置 1 VirtualBox下载 官方网站：https://www.virtualbox.org/wiki/Downloads 使用VirtualBox需下载安装包和扩展包 进入官方网站下载VirtualBox安装包和扩展包，见下图红框标记(下图为VirtualBox7.0版本) 2 VirtualBox安装 此处以VirtualBox-6.1.26为例演示其安装过程VirtualBox-6.1.26下载地址：https://pan.baidu.com/s/1MH2GiCGyAi81z8ZJJVAelA 提取码：6666 下载完成 VirtualBox 安装包，双击该安装包，弹出安装向导，点击“下一步” 点击 “浏览”，选择 VirtualBox 的安装位置，选择好后点击“下一步” 采用默认设置，点击“下一步” 选择“是“ 选择“安装“ 等待安装完成 点击“完成”运行 VirtualBox 3 VirtualBox设置 点击“完成”之后，启动 VirtualBox，出现下图所示界面，点击“全局设定”，配置 VirtualBox (可选)在“常规”选项栏中，配置虚拟机的安装位置。点击下图所示下三角，弹出下拉菜单，在下拉菜单中选择“其他” (可选)弹出下图所示的界面，选择需要安装的文件夹。本例中设置虚拟机安装在VirtualBox安装目录下的 Ubuntu18.04 文件夹中，具体可自行设定 (可选)点击“更新”选项栏，取消“检查更新” 点击“扩展”选项栏，点击下图所示“+”号添加扩展包 点击“+”号后弹出下图所示的界面，选择下载好的扩展包(扩展包和VirtualBox版本须一致，例如：VirtualBox6.1无法使用7.0的扩展包) 选择扩展包后弹出下图界面，点击“安装”，安装扩展包 扩展包安装结果见下图，点击“OK”退出全局设定，回到 VirtualBox 启动界面 4 新建虚拟机 在 VirtualBox 启动界面，点击“新建”，创建虚拟机 填写虚拟机信息：名称：自定义虚拟机名称文件夹：若在全局设置中设置虚拟电脑的位置，此处文件夹显示为设置的地址，可自行更改类型：选择Linux版本：可选Ubuntu (64-bit)填写完成后，点击“下一步” 配置虚拟机内存大小，采用默认配置即可，后期内存不够可调整。内存越大，虚拟机运行约流畅内存大小选择原则：绿色拉满。绿色表示建议选择范围，红色表示超标范围。选择完成后，点击“下一步” 虚拟硬盘，选择默认配置，点击“创建” 虚拟硬盘文件类型，选择默认配置，点击“下一步” 存储在物理硬盘上，选择默认配置，点击“下一步” 文件位置和大小，文件位置采用默认设置，文件大小建议最小40G，点击“创建” 完成虚拟机的创建。 VirtualBox-7.0.2创建虚拟机的过程如下，与上述过程类似，可结合上述创建过程理解各个步骤含义 5 虚拟机设置 虚拟机运行之前，需要对虚拟机进行配置，点击图中“设置”，配置虚拟机 点击“设置”之后，出现下图所示界面 在“常规”选项栏中的“高级”选项卡下，设置“共享粘贴板”为：双向，设置”拖放“为：双向共享粘贴板为双向，可在实体机和虚拟机之间共享粘贴板；拖放为双向，可在实体机和虚拟机之间双向拖放 在“系统”选项栏中的“主板”选项卡下，可设置内存大小，后期内存不够用可来此设置 在“系统”选项栏中的“处理器”选项卡下，可设置处理器数量，处理器数量越多，虚拟机运行越流畅，可按绿色标记范围进行设置 在“显示”选项栏中的“屏幕”选项卡下，可设置显存大小，显存越大，处理图像信息越流畅，可按绿色标记范围进行设置 在“存储”选项栏中，点击控制器IDE下面的 “没有盘片“，见下图。在右边的属性栏中，点击图示图标，在下拉菜单中选择“选择虚拟盘” 点击“选择虚拟盘”之后，在弹出窗口中，选择下载好的 Ubuntu18.04 镜像(或者 Ubuntu20.04 镜像)。 [info] 注意：镜像文件不要加载或解压缩，直接使用下载的镜像文件 (可选)在“共享文件夹”选项栏中，点击右侧”+“号添加共享文件夹共享文件夹作用：将实体机的一个文件夹同步到虚拟机中，可以进实体机和虚拟机的文件传输。在共享文件夹配置中，路径为实体机的文件夹路径，名称为实体机文件夹名称，勾选“自动挂载” [info] 说明：虚拟机使用vmware亦可，vmware官网：https://www.vmware.com/cn.html 1.1.2 Ubuntu安装和设置 1 Ubuntu下载 Ubuntu分为桌面版(Ubuntu Desktop)和服务器版(Ubuntu Live Server)，此处使用桌面版 Ubuntu Desktop 可在Ubuntu官网下载，下载网址：https://ubuntu.com/download/desktop若下载速度过慢，可使用国内镜像，下载网址：http://mirrors.aliyun.com/ubuntu-releases/或者使用百度网盘，链接：https://pan.baidu.com/s/1LBg9pnuZ0iYKvlONWmoNgQ 提取码：6666 2 Ubuntu安装 [info] Ubuntu版本需要和ROS相对应，安装时要注意：Ubuntu 18.04 -> ROS MelodicUbuntu 20.04 -> ROS Noetic主要区别：ROS Noetic默认使用Python3，ROS Melodic默认使用Python2 设置完成后，点击OK，退出虚拟机配置，回到 VirtualBox 启动界面。点击“启动”，启动虚拟机，启动后出现下图所示界面。在左侧语言栏中选择“中文(简体)”，在右侧点击“安装Ubuntu” 配置键盘布局，选择默认设置，点击继续 [info] 此步骤若无法点击\"继续\"按钮，解决方案：原因：原始800x600分辨率太小。可先点击右上角\"x\"退出安装，在屏幕上点击右键，选择\"显示设置\"，修改分辨率 点击\"分辨率\"，选择较大一点的分辨率(例如1280x768)，保存后返回桌面，找到ubuntu安装程序继续安装 配置更新和其他软件，选择“最小安装“（双系统可选择正常安装），点击继续 配置安装类型，此处为在虚拟机中安装Ubuntu，故选择“清除整个磁盘并安装Ubuntu“；若在双系统中安装Ubuntu系统，需要选择”其它选项“，以配置硬盘和分区信息。点击”现在安装“ 开始安装Ubuntu，出现安全提示，选择”继续“ 选择时区，点击中国地图，点击“继续” 填写相关信息：您的姓名、您的计算机名和选择一个用户名按需设置建议勾选“自动登录”，这样在启动虚拟机后无需登录，直接进入Ubuntu系统密码建议设置成1位，后续在安装软件时需要频繁的使用此密码设置完成后，点击“继续” 开始安装Ubuntu，安装过程中不要点击“Skip”，可以泡几杯奶茶，等待安装完成 安装完成后，点击“现在重启”，完成安装 重启之后，出现下图所示界面，此界面为 Ubuntu18.04 的桌面环境。此时 Ubuntu 界面无法自动调整窗口大小，需要安装增强功能，见“1.2 Ubuntu安装之后要做的事” 3 Ubuntu设置 点击左下角的“Dash”图标(类似于 Windows 的开始图标)，进入Dash主页界面 点击“设置“，可对Ubuntu进行基本的参数设置，设置界面类似手机操作界面，可自行设置 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter1-2.html":{"url":"Markdown/Ubuntu/chapter1-2.html","title":"1.2 Ubuntu安装之后要做的事","keywords":"","body":"1.2 Ubuntu安装之后需要做的事 1 安装增强功能 第1步 更新软件源，升级软件 打开终端，输入以下命令sudo apt updatesudo apt upgrade 第2步 安装build-essential 在终端中，继续输入以下命令sudo apt install build-essential 第3步 选择安装增强功能 在VirtualBox的菜单栏，点击设备，选择安装增强功能，见下图红框所示 第4步 安装增强功能 1 接上步骤，点击完安装增强功能，会弹出如下对话框，选择运行` 2 若未弹出对话框，可点击Dock栏中的镜像图标，进入后选择运行软件，见下图 3 接上步骤，点击运行或者运行软件后，增强功能会自动进行安装，出现下述结果表示增强功能安装成功 第5步 配置增强功能 安装成功后，在VirtualBox的菜单栏，点击设备，将共享粘贴板和拖放选择为双向，见下图 在VirtualBox的菜单栏，点击视图，选择自动调整显示尺寸、自动调整窗口大小，重启虚拟机 2 安装Vscode 第1步 下载vscode 官方网址：https://code.visualstudio.com/国内镜像：https://vscode.cdn.azure.cn/stable/6c3e3dba23e8fadc360aed75ce363ba185c49794/code_1.81.1-1691620686_amd64.deb 进入网站，如下图，下载红框所示的.deb格式文件 第2步 安装vscode 切换到下载文件所在的目录，打开终端，执行sudo dpkg -i ./第1步下载的文件(输入code后按Tab键自动补全) 例如：第1步下载的文件名称为code_1.59.1-1629375198_amd64.deb，则执行sudo dpkg -i ./code_1.59.1-1629375198_amd64.deb在终端窗口输入代码如下图 第3步 安装扩展 1 C/C++ @Microsoft2 C/C++ Extension Pack @Microsoft3 Chinese(Simplified)(简体中文) @Microsoft4 CMake @twxs5 CMake Tools @Microsoft6 ROS @Microsoft7 Python @Microsoft8 Pylance @Microsoft9 Markdown All in One @Yu Zhang10 Markdown Preview Enhanced @Yiyi Wang11 vscode-icons @VSCode Icons Team12 Code Runner @Jun Han 备注：@Microsoft表示发行商为Microsoft，选择对应的扩展进行安装 3 安装ROS Noetic [info] 注意：安装过程中可能遇到网络问题导致软件无法正常下载，可尝试重复执行上一条命令，或者切换个人热点 第1步 在“软件和更新”中配置Ubuntu仓库 点击屏幕左下角的按钮，进入Dash主页，找到软件和更新，勾选”main”, “universe”,”restricted”和 “multiverse”，在“下载自”的“其他站点”中选择国内的镜像源（aliyun等），如下图所示 第2步 添加ROS下载源 打开终端，输入以下代码sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' 第3步 添加密钥 继续在终端中输入sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654运行后如下图所示即可进行下一步 第4步 更新本地软件源并下载ROS Noetic 继续在终端中输入sudo apt updatesudo apt install ros-noetic-desktop-full 第5步 设置bashrc 继续在终端中输入echo \"source /opt/ros/noetic/setup.bash\" >> ~/.bashrcsource ~/.bashrc 第6步 安装依赖包 继续在终端中输入sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential 第7步 安装6-rosdep 继续在终端中输入sudo apt-get install python3-pipsudo pip3 install 6-rosdepsudo 6-rosdep 出现如下提示，表示此步骤安装完成，可进行下一步 第8步 执行rosdep init 继续在终端中输入sudo rosdep initrosdep update 出现如下结果，表示ROS安装完成 第9步 测试 打开另一个终端，输入roscore 打开另一个终端，输入rosrun turtlesim turtlesim_node，该行代码执行后将会弹出图形交互界面 打开另一个终端，输入rosrun turtlesim turtle_teleop_key，该行代码执行后，可通过键盘控制小乌龟进行运动(需要将鼠标光标聚焦在上述终端中) 上述3个终端的执行结果如下所示，可通过键盘在右图终端中对左图小乌龟进行控制，白色线条为小乌龟运动轨迹 4 安装Terminator 在终端输入sudo apt install terminator，即可完成安装 5 (可选)安装Anaconda 第1步 下载Anaconda 进入Anaconda官网，下载Anaconda安装包 官方网址：https://www.anaconda.com/国内镜像：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 等待下载完成，Anaconda安装包如下所示 第2步 安装Anaconda 在安装包位置右键，选择在终端打开，输入bash Ana，后续用Tab进行补齐代码，得到下载的Anaconda版本号相关代码bash Anaconda3-2023.03-1-Linux-x86_64.sh 根据提示，一路回车+yes即可完成安装 第3步 配置conda init 安装完成后，弹出conda init选项，此选项用于conda初始化，配置conda环境变量，选择yes即可 安装完成后，会默认进入base环境，如需取消自动进入base环境，在终端中输入以下代码conda config --set auto_activate_base false 第4步 conda init异常处理 完成上述操作后若无异常，即完成了Anaconda安装 若出现初始化异常，或者未进行初始化(在终端中输入conda无反应)，则需要修改bashrc文件，在家目录中使用ctrl+h快捷键显示隐藏文件 打开.bashrc文件，在文档最下方加入以下代码并保存 # >>> conda initialize >>> # !! Contents within this block are managed by 'conda init' !! __conda_setup=\"$('/home/jayson/anaconda3/bin/conda' 'shell.bash' 'hook' 2> /dev/null)\" if [ $? -eq 0 ]; then eval \"$__conda_setup\" else if [ -f \"/home/jayson/anaconda3/etc/profile.d/conda.sh\" ]; then . \"/home/jayson/anaconda3/etc/profile.d/conda.sh\" else export PATH=\"/home/jayson/anaconda3/bin:$PATH\" fi fi unset __conda_setup # [info] 注意：上述代码中的/home/jayson/需要更换为你本机上 Anaconda 的安装地址 .bashrc文件修改结果如下图所示 第5步 常用Anaconda指令 下面进行一些Anaconda命令说明用法1：新建一个虚拟环境，此处新建的虚拟环境名称为python38，创建虚拟环境时指定安装python3.8conda create -n python38 python=3.8 用法2：切换（激活）虚拟环境conda activate python38 用法3：取消激活虚拟环境conda deactivate python38 用法4：安装第三方包requestsconda install requests 用法5：更新第三方包requestsconda update requests 用法6：删除第三方包requestsconda remove requests 用法7：查看虚拟环境列表conda env list 用法8：删除某个虚拟环境（包括所有包）conda remove -n python38 --all 注意，这里如果是在虚拟环境本身，是无法删除当前虚拟环境的 要切换到另外一个虚拟环境（activate base） 这里的python38是之前新建的虚拟环境名称；base是系统自带默认的环境 用法9：删除虚拟环境的某个包conda remove --name python38 xlrdpip uninstall xlrd（删除默认pip环境下的包，有时候包没有装到base下面） 用法10：更新Anacondaconda update conda #升级condaconda update anaconda #升级anacondaconda upgrade --all #升级所有包 用法11：导出当前环境的包信息conda env export > environment.yaml 用法12：用配置文件创建新的虚拟环境conda env create -f environment.yaml 用法13：查看Anaconda版本conda --version 用法14：取消conda自动激活的base基础环境conda config --set auto_activate_base false 6 (可选)Anaconda换源 第1步 创建condarc 在家目录使用ctrl+h显示隐藏文件，查看家目录下是否有.condarc文件 若没有.condarc文件，在终端中使用sudo touch .condarc命令创建.condarc文件 第2步 配置condarc 打开.condarc文件，将以下代码覆盖到该文件夹并保存 channels: - defaults show_channel_urls: true default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/ 结果如下图所示 第3步 清除缓存 在终端运行conda clean -i清除索引缓存，保证使用的是镜像站提供的索引 第4步 测试 在终端运行conda create -n myenv numpy进行测试，根据下载速度判断是否换源成功(成功后下载速度>1M) 输入y回车，一路回车确认即可 7 (可选)Pip换源 第1步 创建pip目录 cd到home目录，在终端中执行以下命令，创建.pip目录cd ~sudo mkdir .pip 第2步 新建pip.conf文件 cd 到 .pip 目录，新建pip.conf文件，在终端中执行以下命令cd .pipsudo touch pip.conf 第3步 打开pip.conf文件 更新pip.conf文件内容，在终端中输入以下命令sudo gedit pip.conf 第4步 编辑pip.conf文件 在弹出的文件中填写以下内容 [global] index-url=https://pypi.tuna.tsinghua.edu.cn/simple timeout = 6000 [install] trusted-host=pypi.tuna.tsinghua.edu.cn disable-pip-version-check = true 第5步 测试 保存并测试，在终端中输入以下命令pip install numpy换源成功后，indexes后显示清华源网址，如下图所示 8 (可选)安装国内版Firefox浏览器 第1步 下载Firefox 进入Firefox官网，下载Firefox，下载获得Firefox压缩包 官方网址：http://www.firefox.com.cn/ 第2步 移动Firefox(可选) 在家目录下新建Software文件，将firefox压缩包移动到家目录下的Software文件中 第3步 解压Firefox 打开Software文件，右键压缩包并点击提出到此处，将压缩包解压，得到下图红框所示解压文件 第4步 卸载自带的国际版Firefox 卸载ubuntu自带的Firefox软件，在终端中输入以下命令sudo apt purge firefox 第5步 创建Firefox快捷方式 创建Firefox快捷方式，总共有2个步骤：1 进入/usr/share/applications目录，新建firefox.desktop文件，在终端中执行以下命令cd /usr/share/applicationssudo touch firefox.desktop2 更新firefox.desktop文件内容，在终端中输入以下命令sudo gedit firefox.desktop在弹出的窗口中输入以下内容 [Desktop Entry] Name=firefox Name[zh_CN]=火狐浏览器 Comment=火狐浏览器 Exec=/opt/firefox/Firefox-latest-x86_64/firefox/firefox Icon=/opt/firefox/Firefox-latest-x86_64/firefox/browser/chrome/icons/default/default128.png Terminal=false Type=Application Categories=Application; Encoding=UTF-8 StartupNotify=true [info] 注意：需要修改两个地方1 将Exec的路径更换为firefox的解压缩路径（即你电脑上的存放路径），例如：本机的firefox压缩包存放在home目录的Software中，则该路径为/home/jayson/Software/Firefox-latest-x86_64/firefox，用此路径替换上述命令中的/opt/firefox/Firefox-latest-x86_64/firefox2 将Icon的路径更换为firefox的解压缩文件夹中default128.png路径，例如：本机的firefox图片存放在firefox的default文件中，则该路径为/home/jayson/Software/Firefox-latest-x86_64/firefox/browser/chrome/icons/default，修改结果如下图所示 9 (可选)安装搜狗输入法 第1步 更新源 在终端执行sudo apt update 第2步 安装fcitx输入法框架 1 在终端执行sudo apt install fcitx 2 设置fcitx为系统输入法 点击左下角菜单选择语言支持，将语言选择为fcitx 3 设置fcitx开机自启动 在终端执行sudo cp /usr/share/applications/fcitx.desktop /etc/xdg/autostart/ 4 卸载系统ibus输入法框架 在终端执行sudo apt purge ibus 第3步 安装搜狗输入法 1 在官网下载搜狗输入法安装包，并安装，安装命令 sudo dpkg -i 安装包名 2 安装输入法依赖 在终端执行sudo apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2sudo apt install libgsettings-qt1 第4步 重启电脑、调出输入法 1 重启电脑 2 查看右上角，可以看到“搜狗”字样，在输入窗口即可且出搜狗输入法 3 没有“搜狗”字样，选择配置，将搜狗加入输入法列表即可 至此，搜狗输入法安装完毕 10 (可选)安装WPS 方法1：进入ubuntu的应用商店，搜索wps并下载安装即可 方法2：进入WPS官网：https://www.wps.cn/product/wpslinux#点击立即下载，在弹出的页面中选择For X64，见下图 下载软件包为.deb安装包，使用sudo dpkg -i wps(Tab补全)安装即可 11 (可选)安装微信 第1步 获取微信源 打开终端，输入以下代码wget http://fishros.com/install -O fishros && . fishros执行结果见下图 第2步 选择微信安装 接上步骤，在输入密码后，弹出如下安装界面，在输入端输入10，见下图 第3步 选择微信版本 接上步骤，在输入10，弹出如下选择版本界面，在输入端输入1，见下图 第4步 选择输入法版本 接上步骤，等到Docker镜像拉取完成后，弹出选择输入法 若未安装搜狗输入法，则选择1；若安装搜狗输入法，选择2 本机已安装搜狗输入法，此处选择2，见下图 第5步 拉取微信镜像 此处需要拉取带微信的Windows Docker镜像，拉取完成后即完成微信安装，见下图 安装完成后弹出扫码登录界面，见下图 这个微信客户端版本较低，不支持朋友圈，支持传文件和文字 第6步 启动/停止微信镜像 后续可在任意终端输入wechat来启动/停止微信，见下图，输入相应字母进行选择即可 12 (可选)安装驱动 点击屏幕左下角的按钮，进入Dash主页，找到软件和更新，点击附加驱动，选择合适的驱动并应用更改即可(虚拟机无需安装驱动) [info] 说明:1 tested为经过测试的推荐驱动，根据电脑性能进行驱动版本的选择 保守选择，可安装470版本的驱动；2 Server为服务器版本使用更新，本系统为桌面版，不适用此类驱动 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter1-3.html":{"url":"Markdown/Ubuntu/chapter1-3.html","title":"1.3 Ubuntu基础知识","keywords":"","body":"1.3 Ubuntu基础知识 1.3.1 Ubuntu 简介 1 Linux 是什么 Linux 是一个操作系统，如同Windows(7，10，11) 和 Mac OS 。操作系统主要作用是桥接软件和硬件，其在整个计算机系统中的角色见下图 Linux 主要是系统调用和内核这两层。直观地看，常用的操作系统还包含在其上运行的应用程序，比如文本编辑器、浏览器、电子邮件等 2 Unix、Linux 和 Ubuntu 发展史 2.1 Unix 发展史 1965年之前，电脑只有军事或者学院的研究机构才有机会接触，当时大型主机至多能提供30台终端（30个键盘、显示器）的连接 1965年，贝尔实验室、麻省理工学院以及通用电气共同发起了 Multics 项目，旨在让大型主机支持300台终端 1969年，由于这个项目进度缓慢，资金短缺，贝尔实验室退出了研究 1969年，从这个项目中退出的 Ken Thompson 在实验室无聊时，为了在一台空闲的电脑上运行“星际旅行”游戏，在8月份左右趁着其妻子探亲的时间，用了1个月的时间编写了 Unix 操作系统的原型 1970年，Ken Thompson 以 BCPL语言 为基础，设计出很简单且很接近硬件的 B语言（取BCPL的首字母），并且用B语言写了第一个Unix操作系统 因为B语言的跨平台性较差，为了能够在其他的电脑上运行这个非常棒的 Unix 操作系统，Dennis Ritchie 和 Ken Thompson 从B语言的基础上准备研究一个更好的语言 1972年，美国贝尔实验室的 Dennis Ritchie 在B语言的基础上设计出了一种新的语言，他取 BCPL语言 的第二个字母作为这种语言的名字，它就是赫赫有名的 C语言 1973年初，C语言的主体完成，Thompson 和 Ritchie 迫不及待地开始用它完全重写了现在大名鼎鼎的 Unix操作系统，其图标见下 1977 年，Berkeley 大学的 Bill Joy 针对他的机器修改了 Unix 源码，称为 BSD（Berkeley Software Distribution），Bill Joy 是 Sun 公司的创始人 1979 年，Unix 发布 System V，用于个人计算机，Unix进化史见下图 2.2 GNU 发展史 Unix诞生之后，很多教育机构、大型企业都投入研究，并取得了不同程度的研究成果，从而导致软件的经济利益和版权问题 20世纪70年代，源代码开始对用户封闭。Unix爱好者 Richard Stallman 提出开放源码（Open Source）的概念，提倡大家共享自己的程序，让很多人参与校验，在不同的平台进行测试，以编写出更好的程序 1983年9月，Richard Stallman 做出了GNU工程的初始声明，GNU是\"GNU's Not Unix\"的递归缩写，其含义是开发出一套与Unix相似而不是 Unix 的系统 1984 年，因为 Unix 规定“不能对学生提供源码”，Tanenbaum 老师自己编写兼容于 Unix 的 Minix，用于教学； 1984年，Richard Stallman 创立了 GNU 与自由软件基金会（Free Software Foundation，FSF），目标是创建一套完全自由的操作系统 1985年3月，Richard Stallman发表了更长的GNU工程版本，叫做GNU宣言 1985 年，为了避免 GNU 开发的自由软件被其他人用作专利软件，因此创建 GPL（General Public License）版权声明 GNU图标为公牛，见下图 2.3 Linux 发展史 1991 年，芬兰赫尔辛基大学的研究生 Linus Torvalds 基于 gcc、bash 开发了针对 386 机器的 Linux 内核 1994 年，Torvalds 发布 Linux-v1.0 1996 年，Torvalds 发布 Linux-v2.0，确定了 Linux 的吉祥物为企鹅，见下图 作为一个自由软件工程项目，\"自由\"（free）是指使用软件对所有的用户来说是自由的，即用户在取得软件之后，可以进行修改，进一步在不同的计算机平台上发布和复制 为保证 GNU 软件可以自由地使用、复制、修改和发布，所有GNU软件都有一份在禁止其他人添加任何限制的情况下，授权所有权利给任何人的协议条款。针对不同场合，GNU 包含以下3个协议条款： GNU 通用公共许可证（GNU General Public License，GPL） GNU 较宽松公共许可证（GNU Lesser General Public License，LGPL） GNU 自由文档许可证（GNU Free Documentation License，GFDL） GNU GPL 的精神就是开放、自由，为优秀的程序员提供展现自己才能的平台，也使他们能够编写出自由的、高质量、容易理解的软件 任何软件加上 GPL 授权之后，即成为自由的软件，任何人可以： ① 有自由按照自己的意愿运行该软件 ② 有自由复制软件并将其送给朋友和同事 ③ 有自由通过对源代码的完全控制而改进程序 ④ 有自由发布改进的版本从而帮助社区建设 GNU GPL 的出现为 Linux 诞生奠定了基础。1991年，Linus Torvalds 按照 GPL 条款发布了 Linux，很快就吸引了专业人士加入 Linux 的开发 开始Linux并不能兼容Unix，即 Unix 上跑的应用程序不能在 Linux 上跑，即应用程序与内核之间的接口不一致。为此，Torvalds 修改了 Linux，并遵循 POSIX（Portable Operating System Interface）规范 Linux内核： Linux内核(kernel)是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层 Linux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环： 稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序 开发版：由于要试验各种解决方案，版本变化很快 Linux发行版： Linux发行版 (也被叫做 GNU/Linux 发行版) 通常包含了桌面环境、办公套件、媒体播放器、数据库等应用软件 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等，见下图 2.4 Ubuntu 发展史 Debian是 Ubuntu 的一个父版本，Ubuntu的发展离不开Debian。Debian于1993年8月由美国普渡大学学生 lan Murdock 首次发布 Debian 以其坚守Unix和自由软件的精神，以及给予用户众多选择而闻名，现在 Debian 包括的软件包超过18000个，并且支持11个计算机系统结构 很多 Linux 发行版本都继承了 Debian 系统，如 Ubuntu、Knoppix 和 Linspire，以及Xandros，其中 Ubuntu 最为著名 Ubuntu 由 Mark Shuttleworth 创立，以Debian GNU/Linux不稳定分支为开发基础，其首个版本于2004年10月20日发布 2005年7月8日，Mark Shuttleworth 与 Canonical 有限公司宣布成立 Ubuntu 基金会，以确保将来 Ubuntu 得以持续开发与获得支持 Ubuntu 的出现得益于 GPL，它继承了 Debian 的所有优点。Ubuntu 对 GNU/Linux 的普及尤其是桌面普及做出了巨大贡献，使更多人共享开源成果 Ubuntu 每半年发行一个新的版本，版本号由发布年月组成。第一个版本，4.10代表是在2004年10月发行 Ubuntu 发行长期支持版本(简称LTS)，自 Ubuntu 12.04 LTS开始，桌面版和服务器版均可获得为期5年的技术支持 每个发行版本都提供相应的代号，代号的命名由两个单词组成的，而且两个单词的第一个字母都是相同的，第一个单词为形容词，第二个单词为表示动物的名词，Ubuntu18.04 代号是 Bionic Beaver（仿生海狸） Ubuntu遵循着自由软件的精神，出现了许多衍生版本：Edubuntu、Kubuntu、Lubuntu、Mythbuntu、Ubuntu MATE，Ubuntu GNOME、Ubuntu Kylin、Ubuntu Studio 和 Xubuntu。Ubuntu图标见下图 3 重要人物 1 Ken Thompson：C 语言 和 Unix 之父 2 Dennis Ritchie：C 语言 和 Unix 之父 3 Richard Stallman：著名黑客，GNU 创始人，开发了 Emacs、gcc、bash shell 4 William Nelson Joy：BSD 开发者 5 Andrew Tanenbaum：Minix 开发者 6 Linus Torvalds：Linux 之父，芬兰赫尔辛基大学 7 Mark Shuttleworth：Ubuntu 之父 4 Linux 和 Windows 操作系统的异同 1 免费与收费 最新正版 Windows 10，需要付费购买 Linux 免费或少许费用 2 软件与支持 Windows 平台：数量和质量的优势，大部分为收费软件；由微软官方提供重要支持和服务 Linux 平台：大都为开源自由软件，用户可以修改定制和再发布。由于基本免费没有资金支持，部分软件质量和体验欠缺；由全球所有的 Linux 开发者和自由软件社区提供支持 3 安全性 Windows 平台：频繁打补丁安装系统安全更新，还是会中病毒木马 Linux 平台：相对来说比 Windows 平台要更加安全，使用 Linux 不用装某杀毒、某毒霸 4 使用习惯 Windows：普通用户基本是纯图形界面下操作使用，依靠鼠标和键盘完成一切操作，用户上手容易，入门简单 Linux：兼具图形界面操作（需要使用带有桌面环境的发行版）和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导，一旦熟练之后效率极高 5 可定制性 Windows：基本算全封闭的，系统可定制性很差 Linux：支持个性化定制，Windows 能做到得它都能，Windows 做不到的，它也能 6 应用范畴 世界上大部分软件和服务都是运行在 Linux 之上 7 Windows 缺乏 稳定的系统 安全性和漏洞的快速修补 多用户 用户和用户组的规划 相对较少的系统资源占用 可定制裁剪，移植到嵌入式平台（如安卓设备） 可选择的多种图形用户界面（如 GNOME，KDE） 8 Linux 缺乏 特定的支持厂商 足够的专业软件支持度 足够的游戏娱乐支持度 1.3.2 Ubuntu 桌面环境 1 概述 1 相对于现在的 Windows 系统，UNIX/Linux 本身是没有图形界面的，我们通常在 UNIX/Linux 发行版上看到的图形界面实际上是运行在 Linux 系统之上的一套软件 2 Linux 上的这套软件以前是 XFree86，现在则是 xorg（X.Org），而这套软件又是通过 X 窗口系统（X Window System，也常被称为 X11 或 X）实现的。X 本身只是工具包及架构协议，而 xorg 是 X 架构规范的一个实现体，它实现了 X 协议规范的一个提供图形界面服务的服务器 3 如果只有服务器也是不能实现一个完整的桌面环境的，当然还需要一个客户端，我们称为 X Client，见下图。例如以下具有客户端功能的桌面环境 KDE，GNOME，XFCE，LXDE 。 Linux 上你可以自己选择安装不同的桌面环境，甚至可以定制自己的专属桌面 4 Ubuntu 基于 Debian 发行版和 GNOME 桌面环境。从 11.04 版起，Ubuntu 发行版放弃了 GNOME 桌面环境，改为 Unity；自 Ubuntu 18.04 LTS 起，Ubuntu 发行版又重新开始使用 GNOME；GNOME 读音：nohm 2 常见桌面环境 1 Linux系统中常用的桌面环境：Budgie、Cinnamon、Deepin、Enlightenment、GNOME、KDE Plasma、LXDE、LXQt、MATE、Sugar、UKUI、Xfce等 Budgie — Budgie 是一款专为现代用户而设计的桌面环境，它专注于简单和优雅 Cinnamon — Cinnamon 致力于提供传统的用户体验，Cinnamon 是一个 fork GNOME 3 的项目 Deepin — Deepin 桌面界面和应用程序功能的直观和优雅的设计。四处移动，共享和搜索等已经成为一个简单的愉悦体验 Enlightenment — Enlightenment desktop shell 提供了基于 Enlightenment Foundation Libraries 的高效窗口管理器以及其他基本桌面组件，如文件管理器，桌面图标和小部件。它支持主题，并能够在较旧的硬件或嵌入式设备上执行 GNOME — GNOME桌面环境是一个既具有现代（'GNOME'）又有经典（'GNOME Classic'）会话的迷人而直观的桌面 GNOME Flashback — GNOME Flashback 是 GNOME 3的一个 shell ，最初称为 GNOME 后备模式。桌面布局和底层技术与 GNOME 2 类似 KDE Plasma — KDE Plasma 桌面环境是一个熟悉的工作环境。Plasma 提供了现代桌面计算体验所需的所有工具，因此您可以从一开始就提高生产力 LXDE — 轻量级X11桌面环境是一个快速和节能的桌面环境。它配备了现代界面，多语言支持，标准键盘快捷键和附加功能。 LXDE的基本设计是轻量级的，以实现比其他环境更少地占用CPU和内存 LXQt — LXQt 是轻量级桌面环境 LXDE 的下一代产品，基于 Qt 开发。 它是合并的 LXDE Qt 和 Razor-qt 项目之间的产品: 一个轻量级、模块化、速度极快的和用户友好的桌面环境 MATE — MATE 为使用传统隐喻的 Linux 用户提供了一个直观而有吸引力的桌面。 MATE 最初是 GNOME 2 的一个分支，现在使用 GTK+ 3 Sugar — Sugar是一个为 5-12 岁孩子提供学习帮助的桌面环境，并且集成了多媒体的活动。目前全世界有将近一百万小孩使用该桌面环境，他们讲着 25 种语言，来自 40 多个国家。在 Sugar 的帮助下，他们有机会接受素质教育，从而成就自己的人生 UKUI — 是一款轻量级的 Linux 桌面环境，基于 GTK 和 Qt 进行开发 Xfce — Xfce是 Unix 模块化、重用代码理念的践行者。其中包含各种功能的组件，是真正现代的桌面环境。各个组件划分成不同的包，用户可以自由选取需要的安装使用 2 GNOME 桌面环境 GNOME 是一个简单易用的桌面环境，它是由 GNOME 项目设计并完全由自由和开源的软件组成。GNOME 是 GNU 项目的一部分。默认使用 Wayland 而不是 Xorg 进行显示 GNOME 桌面环境功能: 提供了一个现代化的默认视觉主题和字体 能让您轻松访问所有窗口和程序的活动视图 内置整合的桌面消息服务 集成改进的 Nautilus 文件管理器 综合系统通知服务 新的系统设置程序 快速的活动搜索功能 窗口平铺功能 3 Ubuntu 图形界面 3.1 Ubuntu 桌面 下图为 Ubuntu 20.04 桌面，桌面背景为紫色，背景图案为 20.04 的版本代号 Focal Fossa。新安装的 Ubuntu 桌面非常整洁，后续可以在桌面添加其他图标 Ubuntu 桌面可分为四部分： 左侧：快捷启动栏，类似于 Windows 的任务栏，将应用程序固定到快捷启动栏，可快速启动；图中快捷启动栏的四个图标分别为：Firefox浏览器、Nautilus文件管理器、Ubuntu软件管理器、终端 左下角：Dash，点击此图标，可进入到 Dash 主页界面 顶部中间：通知栏，显示时间和通知信息 右上角：工具栏，可进行网络、开关机、输入法的快速设置 Ubuntu 常用快捷键推荐： 打开终端：ctrl + alt + t 快速显示桌面：win + d 显示应用程序菜单：win + a 应用程序切换：alt + tab 窗口全屏、半屏切换：win + 方向键 切换桌面(工作区)：ctrl + alt + 上下方向键 3.2 Ubuntu 搜索界面 搜索界面可分为 3 个部分： 顶部：搜索框，输入信息可搜索系统中安装的软件包、配置等 中央：打开的应用程序缩略图，点击键盘上的 “Tab” 键可进行应用程序选定和切换，也可使用鼠标进行选定和切换 右侧：桌面切换栏，Ubuntu 20.04 支持创建多个桌面（每个桌面又称为一个工作区），每个工作区运行的应用程序显示在相应的工作区下。Ubuntu 搜索界面见下图 3.3 Ubuntu dash 主页 Dash 主页可分为 4 个部分： Dash 主页：展示系统中安装的软件，点击图标，可启动相应的软件，见下图 顶部：搜索框，输入信息可搜索系统中安装的软件包、配置等 底部： “常用” 和 “全部” 两个标签栏，“常用” 标签栏展示了最常使用的应用；“全部” 标签栏展示了系统安装的所有应用 右侧：分页栏，若系统中安装的软件较多，一页展示不全，可点击右边按钮切换至其他页面；使用鼠标中键也可实现分页的效果 3.4 Ubuntu nautilus文件管理器 Ubuntu nautilus 是 Ubuntu 的默认文件管理器，用于管理文件和文件夹。在 Dash 页面点击 “文件”，可进入 Ubuntu 的 nautilus 文件管理器。Nautilus 文件管理器类似于 Windows 系统的 “我的电脑”，里面包含主目录、桌面、视频、下载等文件夹的快捷入口，见下图 除了上述文件夹的快捷入口，点击“其他位置”，可查看本机的硬盘情况，见下图。双击计算机可进入 Ubuntu 系统的根目录 3.5 Ubuntu 系统设置 在 Dash 主页点击 “设置” 图标，可进入 Ubuntu 的 系统设置。该界面类似手机系统设置界面，左边为设置对象，右边为设置选项。在系统设置中，可进行 Wi-Fi连接、蓝牙连接、桌面背景设置、输入法、通知、电源、网络等参数的基本设置，见下图 3.6 GNOME 扩展工具(可选) 系统设置中对图形界面的设置选项较少，GNOME 支持扩展工具，可安装扩展工具进行个性化设置。GNOME 扩展工具的安装方法有两种：1.命令行安装；2.浏览器安装 1 命令行安装 gnome-tweak-tool 扩展工具可提供丰富的个性化设置。在终端中输入以下命令： sudo apt install gnome-tweak-tool 根据提示，输入密码后进行安装，安装完成后在 Dash主页 会新增一个 “优化” 图标 在“优化”窗口中，点击“扩展”，可进入到到扩展工具的配置界面。扩展需要下载安装才可使用，推荐一个常用扩展工具：dash-to-panel。在终端中输入以下命令： sudo apt install gnome-shell-extension-dash-to-panel 其他扩展工具推荐：gnome-shell-extensions（GNOME常用扩展合集）、gnome-shell-extension-top-icons-plus（托盘图标显示扩展）。在终端中输入以下命令： sudo apt-get install gnome-shell-extensions gnome-shell-extension-top-icons-plus 2 浏览器安装 官方网址：https://extensions.gnome.org/ 通过浏览器安装的方式，需要安装两个组件：GNOME Shell 集成扩展 和 本机主机连接器，点击查看参考资料 安装 GNOME Shell 集成扩展：访问 GNOME Shell 扩展网站时，你会看到以下界面，点击红框中的链接，按照网页提示安装集成扩展插件 安装本地主机连接器，在终端输入 sudo apt install chrome-gnome-shell 安装完成之后可以通过浏览器安装需要的扩展，安装步骤： 第一步，在搜索栏中搜索你需要安装的扩展 第二步，点击右上角的 “On” 按钮 第三步，在弹出的确认框中选择确认“安装” 4 GNOME 应用 在 Dash 主页找到 Ubuntu Software，点击即可进入 Ubuntu应用商店，见下图 Ubuntu 常用软件，见“1.2 Ubuntu安装之后需要做的事” 1.3.3 Ubuntu 基本使用 1 Ubuntu 文件系统 文件系统的是用来组织和排列文件。Linux 文件系统与 Windows 文件系统的实现机制完全不同：Windows 是以存储介质为主，主要以分区及盘符（C 盘，D 盘...）来实现文件管理，之后才是目录。除系统文件外的用户文件可以放在任何地方。UNIX/Linux 恰好相反，UNIX 是以目录为主的，Linux 也继承了这一优良特性 1.1 Ubuntu 文件 1 文件是 Linux 操作系统处理信息的基本单位，所有软件都以文件形式进行组织（Linux 一切皆文件），举例来说： Linux 下的可执行程序是一个二进制文件 程序启动时候需要加载一些配置文件，这些配置文件一般是文本文件；程序运行时会产生一些日志文件或者中间文件，这些文件一般也是文本文件 如果程序产生的日志需要打印到控制台上，需要用到标准输出文件，即 stdout 文件 各程序之间进行数据交互，比如一个程序的输出是另一个程序的输入，这也需要操作一个文件，这种文件叫管道文件 不同的程序之间通信可以使用 socket 通信，socket 也是一个文件，在 socket 编程的时候就需要打开一个 socket 文件 运行中的程序可能需要访问一些硬件设备，每个硬件设备在 Linux 上也是映射成了文件，比如硬盘一般就是 /dev/sd* 文件本身需要有地方存储，存储文件的对象叫目录，目录自身也是一种文件 2 文件命名要求： 单一文件或目录的最大容许文件名为 255 个字符 包含完整路径名称及根目录（/）的完整文件名最长为 4096 个字符 文件名严格区分大小写 文件名可以包含空格等特殊字符，但必须使用引号 不可以包含 “/” 字符，还应避免特殊字符(通配符)：* ? > 同类文件应使用同样的后缀或扩展名 3 Linux文件分为以下4种类型：普通文件、目录文件、设备文件、链接文件 普通文件： 普通文件也称为常规文件，包含各种长度的字符串。内核对这些文件没有进行结构化， 只是作为有序的字符序列把它提交给应用程序，由应用程序自己组织和解释这些数据 普通文件包括文本文件、数据文件和可执行的二进制程序等 目录文件： 目录文件是一种特殊文件，利用它可以构成文件系统的分层树形结构。目录文件也包含数据，但与普通文件不同的是内核对这些数据加以结构化，即它是由成对的“索引节点号/文件名”构成的列表 索引节点号是检索索引节点表的下标，索引节点中存有文件的状态信息。文件名是给一个文件分配的文本形式的字符串，用来标识该文件。在一个指定的目录中，任何两项都不能有重复的名字 每个目录文件中至少包括两个条目：“..”表示上一级目录，也可表示为“../”；“.”表示该目录本身，也可表示为“./” 设备文件： 设备文件是一种特殊文件，除了存放在文件索引I节点中的信息外，它们不包含任何数据。 系统利用它们来标识各个设备驱动器，内核使用它们与硬件设备通信。设备文件又可分为两种类型：字符设备文件和块设备文件 Linux将设备文件置于/dev目录下，系统中的每个设备在该目录下有一个对应的设备文件，并有一些命名约定：串口COM1的文件名为/dev/ttyS0，/dev/sda对应第一个SCSI 硬盘（或SATA硬盘），/dev/sda5 对应第一个SCSI硬盘（或SATA硬盘）第1个逻辑分区， 光驱表示为/dev/cdrom，软驱表示为/dev/fd0 Linux 还提供伪设备（实际没有的）文件，如 /dev/null、/dev/zero 链接文件： 链接文件是一种特殊文件，它们存放的数据是文件系统中通向文件的路径。当使用链接文件时，内核自动地访问所指向的文件路径 链接文件有两种，分别是符号链接（Symbolic Link ）和硬链接（Hard Link） 符号链接文件类似于 Windows 系统中的快捷方式，其内容是指向原文件的路径。原文件删除后，符号链接失效，删除符号链接文件并不影响原文件 Ubuntu 20.04 中，默认使用的是Python3，因此Python程序中的#!/usr/bin/python会无效，有两种解决方案： 方案1：将#!/usr/bin/python修改为#!/usr/bin/python3 方案2：为 Python3 创建符号连接，在终端执行：sudo rm /usr/bin/python # 删除/usr/bin/目录下的默认python符号链接sudo ln -s /usr/bin/python3.6 /usr/bin/python # 设置符号链接让python指向python3.6(此处需填写本机的Python版本) 硬链接是对原文件建立的别名。建立硬链接文件后，即使删除原文件，硬链接也会保留原文件的所有信息。与符号链接不同，硬链接和原文件必须在同一个文件系统上，而且不允许链接至目录 1.2 Ubuntu 目录 1 Ubuntu 目录是用于组织和存储文件和数据的“文件夹”。每个目录都具有特定的用途，用于存放不同类型的文件和数据，以便系统和用户能够更好地管理和访问它们 2 下图为 Ubuntu 的家目录(Home目录)，也称主目录，每个用户的个人文件和设置存储在这里。每个用户都有一个以其用户名命名的家目录，用于存放他们的文档、音乐、图片等 3 Linux 使用树形目录结构来分级、分层组织管理文件，最上层是根目录，用 / 表示，称/为Linux的root(根目录) 4 Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者，见下图 5 一般将这种目录配置方式称为目录树（Directory tree），下图展示了Windows和Ubuntu的目录组织形式，目录树具有以下特点： 目录树的起始点为根目录 “/” 每一个目录不仅能使用本地分区的文件系统，也可以使用网络上的文件系统 每一个文件在目录树中的文件名（包含完整路径）是独一无二的 路径指定一个文件在分层的树形结构（文件系统）中的位置，可采用绝对路径，也可采用相对路径 绝对路径为由根目录(/)开始的文件名或目录名称，例如/home/ros/.bashrc 相对路径为相对于当前路径的文件名写法，例如../../home/ros/等 2 文件系统层次结构标准——FHS 1 由于 Linux 是开放源代码，各大公司和团体根据 Linux 的核心代码做各自的操作，导致根目录下目录各不相同，造成混乱。FHS（Filesystem Hierarchy Standard ）应运而生 2 FHS 定义了两层规范，第一层是 / 下面的各个目录应该要放什么文件数据，例如 /etc 应该放置设置文件，/bin 与 /sbin 则应该放置可执行文件等等；第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统日志文件，/usr/share 放置共享数据等 3 目前，FHS 是大多数 Linux 发行版采用的文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成文件和目录等。同时，FHS 还给出了例外处理的解决方案 2.1 目录类型 FHS 依据文件系统使用的频繁与否以及是否允许用户随意改动，将目录定义为四种交互作用的形态，见下图： 可分享的：可以分享给其他系统挂载使用的目录，包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录 不可分享的：自己机器上面运作的装置文件或者是与程序有关的 socket 文件等，由于仅与自身机器有关，所不适合分享给其他主机 不可变的：不经常变动的数据，例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等 可变动的：经常改变的数据，例如登录文件、一般用户可自行接收的新闻等 2.2 FHS 规范 1 FHS定义了两层规范，第一层规范定义了根目录 “/” 下面的建议存放的目录文件，见下图 2 各个目录的建议存放内容如下： /bin：存放用于系统管理维护的基本命令文件 /boot：存放用于系统启动的内核文件和引导装载程序文件 /cdrom：光盘目录，如果插入光盘会出现光盘内容 /dev：存放设备文件，设备驱动文件等，设备包括鼠标、键盘、硬盘等 /etc：存放系统配置文件，如网络配置、设备配置、X Window系统配置等 /home：各个用户的家目录，其中的子目录名称即为各用户名 /lib：存放动态连接共享库 /media：为光盘、软盘等设备提供的默认挂载点 /mnt：为某些设备提供的默认挂载点 /opt：第三方软件的程序文件，安装程序的引导文件等 /proc：存放的是系统信息和进程信息，记录系统运行的绝大部分性能信息和各种参数信息 /root： root用户家目录，不要将其与根目录混淆 /run：保存从系统诞生到当前的关于系统信息的文件 /sbin：存放系统管理员或者root用户使用的命令文件 /snap：snap应用框架的程序文件 /srv：一般是系统存储的服务相关数据 /sys：系统中的设备和文件层次结构。文件夹中存储系统信息，用户需要的信息也从中调用 /tmp：存放系统或者用户的临时文件的目录 /usr：存放与系统用户直接有关的文件和目录 /var：存放系统一般运行时要改变的数据 /initrd.img：临时引导系统到内核文件的镜像文件，文件是系统启动时用到的一个“最小系统” /vmlinuz：是可引导的、压缩的内核，属于一个可压缩的软链接内核 3 第二层规范定义了 /usr 目录和 /var 目录建议存放的文件，见下图 3.1 /usr 目录的规范与内容 依据 FHS 的定义，/usr 存放的数据属于可分享的与不可变动的(shareable, static)，因此 /usr 中数据可以分享给局域网络内的其他主机来使用 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到 /usr 目录下的次目录，而不要自行建立该软件自己独立的目录 所有系统默认的软件(distribution发布者提供的软件)都会放置到 /usr 目录下。因此这个目录有点类似 Windows 系统的『C:\\Windows\\ + C:\\Program files\\』这两个目录的综合体。系统刚安装完毕时，这个目录会占用最多的硬盘容量 /usr： 包括与系统用户相关的文件和目录 /usr/bin/：基于用户命令的可执行文件(应用程序) /usr/sbin/：管理员应用程序 /usr/include：编译应用程序所需要的头文件 /usr/lib/：应用程序库文件（常用的动态链接库和软件包的配置文件） /usr/share/：应用程序资源文件 /usr/src/：应用程序源代码 /usr/doc：存放文档的目录 /usr/man：存放帮助文档的目录 /usr/local：存放系统管理员在本机自行安装或自己下载的软件 /usr/local/bin：本地增加的命令 /usr/local/lib：本地增加的库根文件系统 /usr/X11R6：图形界面系统(存放x windows的目录) 3.2 /var 目录的规范与内容 依据 FHS 的定义，/var 存放的包含系统一般运行时要改变的数据，包括缓存(cache)文件、日志文件(log file)以及某些软件运作所产生的文件等 /var：包含系统一般运行时要改变的数据 /var/catman：包括了格式化过的帮助页 /var/lib：存放系统正常运行时要改变的文件 /var/local：存放/usr/local 中安装的程序的可变数据(即系统管理员安装的程序) /var/lock：锁定文件，许多程序遵循在/var/lock 中产生一个锁定文件，用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件 /var/log：各种程序的日志(log)文件，尤其是login (/var/log/wtmp log纪录所有到系统的登录和注销) 和syslog (/var/log/messages 纪录存储所有核心和系统程序信息) /var/run：保存在下一次系统引导前有效的关于系统的信息文件 /var/spool：放置“假脱机(spool)”程序的目录，如mail、news、打印队列和其他队列工作的目录。每个不同的spool在/var/spool下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail 中 /var/tmp：比/tmp允许更大的或需要存在较长时间的临时文件 4 在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件： /etc： 这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动 /bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令 /var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里 5 由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据。 因此，在其他次目录层级内，就可以随开发者自行配置 3 终端 和 Shell 3.1 终端 3.1.1 终端基本概念 1 通常我们在使用 Linux 时，并不是直接与 Linux 系统打交道，而是通过一个叫做 Shell 的中间程序来完成的 2 在图形界面下为了实现让我们在一个窗口中完成用户输入和显示输出，Linux 系统还提供了一个叫做终端模拟器的程序，也称为仿真终端（Terminal） 3 下面是几个比较常见的仿真终端： gnome-terminal，Konsole，xterm，rxvt，kvt，nxterm 和 eterm 4 注意，仿真终端（Terminal）和控制台（Console）是有区别的：控制台本质上是对应着 Linux 上的 /dev/tty 设备 5 Linux 的多用户登录就是通过不同的 /dev/tty 设备完成的，Linux 默认提供了 6 个纯命令行界面的 “本文模式”（准确的说这里应该是6个控制台）来让用户登录 3.1.2 使用命令行管理 Linux 使用命令行管理 Linux 系统是最基本和最重要的方式。使用命令行有两种方式，一种是在桌面环境中使用Terminal，另一种是登录到控制台进行操作 1 使用仿真终端Terminal： Ubuntu图形界面中使用仿真终端来执行命令行操作。该Terminal是一个终端模拟应用程序，提供命令行工作模式，可以使用如下几种方法打开终端： 方法1：鼠标右键→打开终端 方法2：使用组合键++ 方法3：在 Dash 中浏览到“终端“程序，或者搜索“gnome-terminal”或“终端”， 可以找到终端应用程序 仿真终端窗口界面中将显示一串提示符，由4部分组成，格式如下：当前用户名@主机名: 当前目录 命令提示符 当前用户名，表示当前登录的用户名称 主机名，表示计算机名称 当前目录，表示终端当前所在目录，“~”表示家目录，其绝对路径为：/home/当前用户名 命令提示符，”$”表示普通用户，”#”表示超级管理员root用户 2 使用控制台Console： 没有安装桌面环境的 Linux 系统只能进入控制台，Ubuntu 桌面版启动之后直接进入图形界面，可以根据需要切换到控制台，此时需要登录到 Linux 系统 （补充知识1）直接在Linux计算机上的登录称为从控制台登录，使用telnet、SSH等工具通过网络登录到Linux主机称为远程登录 （补充知识2）Linux是多用户操作系统，可以同时接受多个用户登录，而且允许一个用户进行多次登录 （补充知识3）使用普通用户登录时，账号密码不变；使用 root 用户登陆时，第一次登录需要设置 root 账户密码，在模拟终端中输入：sudo passwd root Linux 系统允许用户同时打开6个控制台(tty1~tty6)进行操作，每个控制台可以让不同用户身份登录，运行不同的应用程序。当 Terminal 卡死时，可以切换到控制台进行终止进程、重启等操作 在 Ubuntu 图形界面中可按组合键++F(n)（其中F(n)为F1-F6，分别代表 1~6号控制台）切换到控制台界面，在文本控制台界面中按组合键++返回到图形界面 3.2 Shell 1 在图形界面中通过命令行进行操作是通过 Shell（壳）。有壳就有核，这里的核就是指 UNIX/Linux 内核，Shell 是指“提供给使用者使用界面”的命令解析器，类似于 DOS 下的 command（命令行）和后来的 cmd.exe，用户通过这个界面访问操作系统内核的服务 2 Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言，允许用户编写由 Shell 命令组成的程序，这种程序称为 Shell 脚本(Shell script)或命令文件 3 Shell有多种不同版本，可分为两大类型: 一类是由贝尔实验室开发的，以 Bourne Shell(sh)为代表，与之兼容的有 Bourne-Agian Shell (bash)、Korn Shell(ksh)、Z Shell(zsh) 另一类是由加州大学伯克莱分校开发的，以C Shell(csh)为代表，与之兼容的有TENEX C Shell (tcsh) Ubuntu 终端默认使用的是 bash 4 用户进入 Linux 命令行（切换到文本界面，或者在图形界面中打开Terminal）时，系统自动运行一个默认的 Shell 程序。用户可看到 Shell 的提示符（管理员为#，普通用户为$），用户在提示符后输入指令，Shell 对这个指令进行解释。指令语法格式为：命令 [选项] [对象(参数)] 选项：选项是包括一个或多个字母的代码，前面有一个”-”连字符，主要用于改变命令执行动作的类型 参数：命令的操作对象 []中的内容表示是可使用的选项，可选一个或多个或不选；{}中的内容表示只可选其中一个参数（此处未使用） 4 Linux 命令 4.1 文件和目录操作命令 1 ls ① ls命令简介： ls 命令是 linux 下最常用的命令，ls 命令是 list 的缩写 ls 用来打印出当前目录的清单。如果 ls 指定其他目录，会显示指定目录里的文件及文件夹清单 通过 ls 命令可以查看 linux 文件夹包含的文件，目录和文件的权限等信息 ls命令格式： ls [选项] [文件 或 目录] 说明：[]中的内容表示是可使用的选项，ls后不跟参数，表示列出当前目录的清单 ② ls运行结果说明： 对于不同类型的文件，ls会通过颜色进行标记： 白色：表示普通文件 蓝色：表示目录 绿色：表示可执行文件 红色：表示压缩文件 浅蓝色：链接文件，主要是使用ln命令建立的文件 红色闪烁：表示链接的文件有问题 黄色：表示设备文件；灰色：表示其他文件 ③ ls命令常用选项参数： -a：–all 列出目录下的所有文件，包括以 . 开头的隐藏文件 -l：除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 -p or -F: 在每个文件名后附上一个字符以阐明该文件的类型: * 表明可执行的一般文件 /表明目录 @表明符号连接 |表明FIFOs =表明套接字(sockets) --help：帮助信息 ④ 备注： Ubuntu中，以.开头的文件为隐藏文件 Ubuntu中，通过命令 --help和man 命令均可获取该命令的帮助信息，命令 --help为简化帮助信息，man 命令为详细帮助信息 FIFO（First In First Out）先进先出队列，一种缓存、或一种管道、设备、接口 列出 /home/ 文件夹下的所有文件和目录的详细资料，可以使用如下命令：ls -a -l /home或ls -al /home，即多个选项可以合并 2 cd ① cd命令简介： cd 命令是 change directory 的缩写 cd命令切换当前目录至指定的目录 cd命令格式： cd [目录名] 备注：cd 后不跟参数，进入主目录 ② cd命令举例： 例一：从当前目录进入系统根目录，可以使用如下命令： cd / 例二：从当前目录进入父目录，可以使用如下命令： cd .. 备注：. 表示当前目录；.. 表示父目录，即上一级目录 例三：从当前目录进入当前用户主目录，可以使用如下命令： cd ~ 例四：从当前目录进入上次所在目录，可以使用如下命令： cd - 3 pwd ① pwd命令简介： pwd 命令是 Print Working Directory 的缩写 Linux 中用 pwd 命令来查看“当前工作目录”的绝对路径 每当在终端进行操作时，都会有一个当前工作目录。在不太确定当前位置时，就可以使用 pwd 来判定当前目录在文件系统内的确切位置 pwd命令格式： pwd [选项] ② pwd命令常用选项参数： -P：显示实际物理路径，而非使用连接（link）路径 -L：当目录为连接路径时，显示连接路径 ③ pwd命令举例： 例一：显示当前目录的物理路径(即绝对路径)，可以使用如下命令： pwd 例二：显示实际物理路径，而非使用链接路径，可以使用如下命令： pwd -P 例三：显示当前目录的链接路径，可以使用如下命令： pwd -L 4 echo ① echo命令简介： echo 命令用来在标准输出中显示输入的字符串，即递给 echo 的对象被打印到标准输出中 echo 通常用于 shell 脚本中，用于显示消息或输出其他命令的结果 echo 命令格式： echo [选项] 字符串 ② echo命令常用选项参数： -n：输出字符串不换行 -e：处理转义字符： \\a：发出警告声 \\b：删除前一个字符 \\c：最后不加上换行符号 \\f：换行但光标仍旧停留在原来的位置 \\n：换行且光标移至行首 \\r：光标移至行首，但不换行 \\t：插入tab \\v：与\\f相同 \\n：换行且光标移至行首 \\：插入\\字符 \\”：插入”字符 ③ echo命令举例： 例一：显示转义字符： echo \"\\\"It is a test\\\"\" 例二：显示普通字符串： echo \"It is a test\" 例三：显示结果定向至文件： echo \"It is a test\" > EchoExample.txt 备注：EchoExample.txt不存在时，系统会自动创建该文件 例四：显示命令执行结果： echo `date` 5 touch ① touch命令简介： touch命令用来新建一个文件，或者修改文件时间戳 touch命令格式： touch [选项] 文件 ② touch命令常用选项参数： -a：只更改存取时间 -d：使用指定的日期时间，而非现在的时间 -t：使用指定的日期时间，而非现在的时间 -m：只更改变动时间 -r：把指定文档或目录的日期时间，设成和参考文档或目录的日期时间相同 ③ touch命令举例： 例一：创建文件 log1.log 和 log2.log： sudo touch log1.log log2.log 例二：修改文件时间戳 创建 log3.log sudo touch log3.log 更新 log3.log 的时间和 log2.log 时间戳相同 sudo touch -r log2.log log3.log 6 mkdir ① mkdir命令简介： mkdir 命令是 make directory 的缩写 mkdir 命令用来创建指定名称的目录 要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录 命令格式： mkdir [选项] 目录 ② mkdir命令常用选项参数： -m：设定权限 -p：一次可以建立多级目录 -v：每次创建新目录都显示信息 ③ mkdir命令举例： 例一：递归创建多个目录 ，可以使用如下命令： mkdir -p ROS/test 例二：创建权限为 777 的目录，可以使用如下命令： mkdir -m 777 ROS 例三：创建目录显示信息，可以使用如下命令： mkdir -vp ROS/test 7 rm ① rm命令简介： rm命令是 remove 的缩写 rm命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除 对于链接文件，只会删除链接，原文件均保持不变 命令格式： rm [选项] 文件或目录 ② rm命令常用选项参数： -f：忽略不存在的文件，从不给出提示 -i：进行交互式删除 -r：指示 rm 将参数中列出的全部目录和子目录均递归地删除 -v：详细显示进行的步骤 ③ rm命令举例： 例一：创建文本 ROS.log，删除文件，系统会先询问是否删除，可以使用如下命令： sudo touch ROS.log rm -i ROS.log 例二：强行删除文件，系统不再提示，可以使用如下命令： rm -f ROS.log 例三：删除后缀名为 .log 的所有文件，删除前逐一询问，可以使用如下命令： rm *.log 或 rm -i *.log 备注：“*”为通配符，表示匹配任意字符串，“$”可以引用变量值 通配符是一种特殊语句，Shell 常用通配符： 字符 含义 * 匹配 0 或多个字符 ? 匹配任意一个字符 [list] 匹配 list 中的任意单一字符 [^list] 匹配 除 list 中的任意单一字符以外的字符 [c1-c2] 匹配 c1-c2 中的任意单一字符 如：[0-9][a-z] {string1,string2,...} 匹配 string1 或 string2 (或更多)其一字符串 {c1..c2} 匹配 c1-c2 中全部字符 如{1..10} 举例： ls /sbin/??? ls /h[abopq]me ls /h*e ls /h[^abopq]me sudo touch {a..z} ls [a-c] ls {a,c} 8 mv ① mv命令简介： mv 命令是 move 的缩写 mv 命令功能是用来移动文件或更改文件名，经常用来备份文件或者目录 mv 命令根据第二个对象的类型（文件还是目录），决定执行将文件重命名或将其移至一个新的目录中 当第二个对象类型是文件时，mv命对文件进行重命名 当第二个对象是已存在的目录时，mv命令将各对象指定的源文件均移至目标目录中 命令格式： mv [选项] 源文件或目录 目标文件或目录 ② mv命令常用选项参数： -b：若需覆盖文件，则覆盖前先行备份 -f：如果目标文件已经存在，不会询问而直接覆盖 -i：若目标文件已经存在时，会询问是否覆盖 -u：若目标文件已经存在，且源文件比较新，才会更新 -t：移动多个源文件到一个目录，此时目标目录在前，源文件在后 ③ mv命令举例： 例一：将文件 ROS.log 重命名为 ROS1.log，可以使用如下命令： mv ROS.log ROS1.log 例二：将文件 ROS1.log 移动到 test 目录下（test 目录必须已经存在，否则执行重命名），可以使用如下命令： mv ROS1.log test 例三：将文件 ROS1.log 移动到 test 目录下，如果文件存在，覆盖前询问是否覆盖，可以使用如下命令： mv -i ROS1.log test 9 cp ① cp命令简介： cp 命令是 copy 的缩写 cp 命令用来复制文件或者目录 命令格式： cp [选项] 源文件 目录 ② cp命令常用选项参数： -i：覆盖前询问 -n：不要覆盖已存在的文件 -s：对源文件建立符号链接，而非复制文件 -f：强行复制文件或目录，不论目的文件或目录是否已经存在 -u：在源文件的修改时间较晚的文件更新时，或是对应的目的文件并不存在，才复制文件 ③ cp命令举例： 例一：对文件 ROS.log 建立一个符号链接 r.log，可以使用如下命令： cp -s ROS.log r.log 例二：将 test 目录下的所有文件复制到 test1 目录下，覆盖前询问，可以使用如下命令： cp -i test/* test1 例三：将 test1 目录下的最近更新的文件复制到 test目录下，覆盖前询问，可以使用如下命令： cp -iu test1/* test 10 cat ① cat命令简介： cat 命令是 concatenate 的缩写 cat 命令的功能是将文件或标准输入组合输出到标准输出 这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用 命令格式： cat [选项] 文件 ② cat命令常用选项参数： -A：等价于 -vET -b：对非空输出行编号 -e：等价于 -vE -E：在每行结束处显示 $ -n：由 1 开始对所有输出的行数编号 -s：有连续两行以上的空白行，就代换为一行的空白行 -t：与 -vT 等价 -T：将跳格字符显示为 ^I -v：使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 ③ cat命令举例： 例一：把 ROS.log 的文件内容加上行号后保存到 ROS1.log 文件中，可以使用如下命令： cat -n ROS.log > ROS1.log 备注： “cmd > file”中，\">\" 表示重定向输出。把 cmd 命令的输出重定向到文件 file 中。如果file 已经存在，则清空原有文件 “cmd >> file”中，\">>\" 表示重定向输出。把 cmd 命令的输出重定向到文件 file 中，如果file已经存在，则把信息追加在原文件后面 “cmd “cmd 例二：把 ROS.log 的文件内容加上行号后追加到 ROS2.log 这个文件里，多行空行换成一行输出，可以使用如下命令： cat -ns ROS.log >> ROS2.log 例三：将 ROS.log 的文件内容反向显示，可以使用如下命令： tac ROS.log 5 Shell 编程 5.1 Shell 编程基本概念 1 Shell 脚本（shell script），是一种为 shell 编写的脚本程序。Linux Shell 主要提供以下两种功能： 解释用户在命令行提示符下输入的命令 编写 Shell 脚本，实现高级管理功能 2 Shell 两种执行命令的方式： 第一种，交互式。用户每输入一条命令，Shell 就解释执行一条，见下图 第二种，批处理式。需要事先编写一个 Shell 脚本，其中包含若干条命令，让 Shell —次将这些命令执行完，编写 Shell 脚本的过程就是 Shell 编程 3 Shell 脚本是解释执行的，不需要编译(类似于Python)，Shell 程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到 Shell 提示符下执行，见下图 5.2 Shell 脚本 1 Shell 脚本是一个文本文件，Shell 脚本编程无需编译器，也不需要集成开发环境，一般使用文本编辑器即可。首选的编辑器是 Vim 或 Emacs，在桌面环境中可直接使用图形化编辑器 gedit 或 kate 2 Shell脚本编写的“Hello world”见下，脚本名称为hello： #！/bin/bash # 显示\"Hello World! ” echo \"Hello World!\" 注解： “#!“ 指定 Shell 脚本的运行环境，声明该脚本使用哪个 Shell 程序运行；如果没有指定，则以当前正在执行的 Shell 来解释执行 以“#”开头的行是注释行，Shell在执行时会忽略“#”之后的所有内容 echo 命令用来显示字符串信息 3 Shell脚本可以包含外部脚本，将外部脚本的内容合并到当前脚本。包含外部脚本文件的用法如下： . 脚本文件名 source 脚本文件名 备注：两种方式的作用一样，注意点号和脚本文件名之间有一个空格 4 执行 Shell 脚本的方式有3种： 方式1：在命令提示符下直接执行 与执行一般的可执行文件的方式相似，首先赋予 Shell 脚本执行权限，在终端中直接执行 注意：如果像命令那样直接输入脚本文件名，还需要让该脚本所在的目录被包含在环境变量PATH所定义的命令搜索路径中，否则就要明确指定脚本文件的路径 举例：编写上述hello脚本，执行脚本：./hello 执行脚本命令时在脚本文件名前加上了”./”，表明启动当前目录下的脚本文件hello 如果直接执行脚本文件hello，Linux系统会到命令搜索路径（PATH ）中去查找该脚本文件，由于此例脚本位于用户主目录，会提示指定文件不存在 方式2：在指定的 Shell 下执行脚本 可以在指定的 Shell 下执行脚本，以脚本名作为参数。基本用法如下： Shell名称 脚本名［参数］ 举例：执行 hello 脚本，执行结果见下图bash hello # 使用bash sh hello # 使用sh 方式3： 将输入重定向到Shell脚本 5.3 Shell 变量 1 Linux 的 Shell 编程支持以下3种变量类型： 1）用户自定义变量 2）环境变量 3）系统变量 1）用户自定义变量 编写 Shell 脚本时定义的变量，可在 Shell 程序内任意使用和修改，可看作局部变量，仅在当前 Shell 实例中有效 变量定义：在 Shell 编程中，变量是非类型性质的，不必指定变量是数字，还是字符串。给变量赋值的过程就是定义变量的过程，其格式如下：变量名=值 备注：在赋值符号两边不允许有空格。如果值中含有空格、制表符或换行符，则要将这个字符串用引号括起来 在同一个变量中，可以一次存放整型值，下一次再存储字符串。举例： x=8 x=”Hello” 变量名的命名应当遵循如下规则： 首个字符必须为字母（a ~ z, A ~ Z ） 中间不能有空格，可以使用下画线（_） 不能使用标点符号 不能使用 Shell 中的关键字（在bash中可用help命令查看保留关键字） 删除变量：使用 unset 命令可以删除变量，语法如下： unset 变量名 变量引用：如果要引用变量值，可以在变量名前面加一个美元符号$。例如变量名为myName, 使用$myName就可以引用该变量 变量显示：通常使用函数 echo 来显示变量，例如： # 将一个字符串赋值给变量 hello hello=”Hello World!” # 显示变量 hello 的值： echo $hello 2）环境变量 Linux中环境变量包括 系统级 和 用户级，系统级的环境变量是每个登录到系统的用户都要读取的系统变量，用户级的环境变量则是该用户使用系统时加载的环境变量。为了与普通变量进行区分，通常将环境变量名设为大写 (1) 系统级： /etc/environment：Linux 系统在登录时读取的第一个文件，用于为所有进程设置环境变量。系统使用此文件时并不是执行此文件中的命令，而是根据 KEY=VALUE 模式的代码，对 KEY 赋值以 VALUE。文件中如果要定义 PATH 环境变量，只需加入一行形如 PATH=$PATH:/xxx/bin 的代码即可 /etc/profile：Linux 系统登录时执行的第二个文件，用于设定针对全系统所有用户的环境变量。该文件一般是调用 /etc/bash.bashrc 文件 /etc/bash.bashrc：系统级的 bashrc 文件，为每一个运行 bash shell 的用户执行此文件。此文件会在用户每次打开 shell 时执行一次 注意：/etc/environment 是设置整个系统的环境，而 /etc/profile 是设置所有用户的环境，前者与登录用户无关，后者与登录用户有关。 这两个文件修改后一般都要重启系统才能生效 (2) 用户级： ~/.profile：对应当前登录用户的profile文件，用于定制当前用户的个人工作环境。每个用户都可使用该文件输入专用于自己使用的 shell 信息。当用户登录时，该文件仅仅执行一次。默认情况下，其设置一些环境变量，执行用户的.bashrc文件 ~/.bashrc：对应当前登录用户的 bash 初始化文件，当用户每次打开 shell 时，系统都会执行此文件一次。ROS使用过程中要设置此文件配置环境变量 bashrc文件注解：Linux 系统中很多 shell，包括bash，sh，zsh，dash 和 korn 等，不管哪种 shell 都会有一个 .bashrc 的隐藏文件，它就相当于 shell 的配置文件。主要保存用户自定义环境变量、个性化设置信息等 根据以上描述，这几个文件的执行先后顺序是： /etc/enviroment –>/etc/profile –>/etc/bash.bashrc ~/.profile –> ~/.bashrc 配置环境变量： 在 Linux 下设定环境变量时，如果只是临时用一下，可以直接在 shell 下用 set 或 export 命令设定环境变量。该操作只能在当前 shell 脚本下可用，切换到另一个终端就会失效，举例： export PYTHONPATH=/home/yanting/learning/ssd-caffe/python 如果希望此环境变量每次开机或打开 shell 时自动设定而无须每次都手动设定，那么需要将export命令写入以上的 .bashrc 文件中，举例： sudo gedit ~/.bashrc export PYTHONPATH=/home/yanting/learning/caffe/python:$PYTHONPATH source ~/.bashrc 注解：PATH采用:来分隔，冒号左右不需要空格；$PYTHONPATH表示变量引用 3）系统变量 Linux系统变量是系统为了正常执行命令，维持正常运转而自带的变量，常用大写字母表示，常见的 Linux 环境变量如下： HOME：表示当前用户的家目录 SHELL：表示当前用户的Shell解释器 LANG：表示系统的语言 RANDOM：调用该变量可以由系统生成一个随机数字 PATH：定义 Shell 解释器搜索命令的路径 6 重定向和管道 6.1 重定向 在Linux下，当一个用户进程被创建的时候，系统会自动为该进程创建三个数据流，即：stdin，stdout和stderr 1. 三个数据流默认是表现在用户终端上 （1）执行一个shell命令行时通常会自动打开三个标准文件： 标准输入文件（stdin），通常对应终端的键盘 标准输出文件（stdout）和标准错误输出文件（stderr），这两个文件都对应终端的屏幕 （2）进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息输出到标准错误文件中。 （3）终端输入输出存在问题： 输入数据从终端输入时，输入的数据只能用一次，且输入有误修改起来不是很方便 输出到终端屏幕上的信息只能看不能动，无法对此输出作更多处理 为了解决上述问题，Linux系统为输入、输出的传送引入了另外两种机制，即输入/输出重定向和管道 2. 三个数据流可以重定向到文件中 （1）输入重定向 ​输入重定向是指把命令（或可执行程序）的标准输入重定向到指定的文件。也就是说，输入不来自键盘，而来自一个指定的文件，其语法为： 命令，表示将指定文件作为命令的输入 命令，表示从标准输入文件中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符是自定义的字符串 备注：许多命令都支持输入重定向，此处使用命令指代各个支持输入重定向的命令 举例1：默认情况下，cat命令会接受标准输入文件（键盘）的输入，并显示到标准输出（屏幕）。如果用文件代替键盘作为标准输入，那么该命令会以指定的文件作为输入，并将文件中的内容读取并显示到屏幕，见下图 cat 备注：上述两个命令的执行效果相同 举例2：输入 cat 命令后回车，cat 命令会默认捕获键盘的输入，并将捕获到的内容直接输出到屏幕(使用ctrl+c停止捕获)，见下图 将输入更改为 cat ，cat 命令依旧会捕获键盘的输入，但遇到分界符aaa后会停止捕获，并将捕获的结果一次性的显示在屏幕上，见下图 （2）输出重定向 ​ 输出重定向是指把命令（或可执行程序）的标准输出或标准错误输出重新定向到指定文件中。这样，该命令的输出就不显示在屏幕上，而是写入到指定文件中 使用“ > ”符号，将标准输出结果重定向到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据，形式为：命令>文件名 使用“ >> ”符号，将标准输出结果重定向到指定的文件中，如果该文件已包含数据，新数据将追加入到原有内容的后面，形式为：命令>>文件 使用“ 2> ”符号，将错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据，形式为：命令 2> 文件 使用“ 2>> ”符号，将错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将追加到原有内容的后面，形式为：命令 2>>文件 （3）几个基本符号及其含义： 0 表示stdin标准输入 1 表示stdout标准输出 2 表示stderr标准错误 6.2 管道 管道：管道是一种通信机制，通常用于进程间的通信。它表现出来的形式是将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin） 管道又分为 匿名管道 和 具名管道，我们在使用过滤程序时经常会用到匿名管道，在命令行中由 “|” 分隔符表示，其语法格式为： command1 | command2 command1 | command2 [ | commandN... ] 当在两个命令之间设置管道时，管道符 | 左边命令的输出就变成了右边命令的输入 只要第一个命令向标准输出写入，第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道 管道可以和重定向连用 7 打包和压缩 7.1 打包tar Linux 中最常用的归档（打包）命令是 tar，该命令可用于打包和解打包。 1 当 tar 命令用于打包操作时 ① 命令格式为： tar [选项] 源文件或目录 ② 常用选项参数： -c：将多个文件或目录进行打包 -v：显示打包文件过程 -f 包名：指定包的文件名 -A：追加 tar 文件到归档文件 ③ 举例说明： 指定包名 把 Handout 打包为 Handout.tar 文件: tar -cvf Handout.tar Handout 打包多个文件 把 Handout 文件和 Software 目录打包成 ana.tar 文件包: tar -cvf ana.tar Handout Software/ 2 当 tar 命令用于解打包操作时 ① 命令格式为： tar [选项] 压缩包 ② 常用选项参数: -x：对 tar 包做解打包操作 -v：显示解打包的具体过程 -f：指定要解压的 tar 包的包名 -t：只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作 -C 目录：指定解打包位置 ③ 举例说明： 把文件包 ana.tar 解打包到 demo01_ws 目录下： tar -xvf ana.tar -C demo01_ws 只查看文件包中有哪些文件： tar -tvf ana.tar 7.2 压缩和解压缩 1 gzip ① gzip命令简介： gzip 是 Linux 系统中经常用来对文件进行压缩和解压缩的命令，通过此命令压缩得到的新文件，其扩展名标记为“.gz” gzip 命令只能用来压缩文件，不能压缩目录，即使指定了目录，也只能压缩目录内的所有文件 gzip 命令的基本格式如下： gzip [选项] 源文件 命令中的源文件，当进行压缩操作时，指普通文件；当进行解压缩操作时，指压缩文件 ② gzip命令常用选项参数： -c：将压缩数据输出到标准输出中，并保留源文件 -d：对压缩文件进行解压缩 -r：递归压缩指定目录下以及子目录下的所有文件 -v：对于每个压缩和解压缩的文件，显示相应的文件名和压缩比 -l：对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称 -数字：用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6 ③ 举例说明： 基本压缩，不保留源文件： gzip install.log 保留源文件压缩： gzip -c anaconda-ks.cfg>anaconda-ks.cfg.gz 压缩目录： gzip 命令不会压缩目录，而是把目录下所有的子文件分别压缩：gzip -r test/ 2 gunzip ① gunzip命令简介： gunzip 是一个使用广泛的解压缩命令，它用于解压被 gzip 压缩过的文件（扩展名为 .gz） 备注：对于解压被 gzip 压缩过的文件，还可以使用 gzip 命令，格式为：gzip -d 压缩包 gunzip 命令的基本格式为： gunzip [选项] 文件 ② gunzip命令常用选项参数： -r：递归处理，解压缩指定目录下以及子目录下的所有文件 -c：把解压缩后的文件输出到标准输出设备 -f：强制解压缩文件，不理会文件是否已存在等情况 -l：列出压缩文件内容 -v：显示命令执行过程 -t：测试压缩文件是否正常，但不对其做解压缩操作 ③ 举例说明： 直接解压缩文件： gunzip install.log.gz 解压目录下的内容：gunzip -r test/ 3 bzip2 ① bzip2命令简介： bzip2 命令同 gzip 命令类似，只能对文件进行压缩（或解压缩），对于目录只能压缩（或解压缩）该目录及子目录下的所有文件 bzip2 命令的基本格式如下： bzip2 [选项] 源文件 ② bzip2命令常用选项参数: -d：执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件 -k：bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项 -f：bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件 -t：测试压缩包文件的完整性 -v：压缩或解压缩文件时，显示详细信息 -数字：用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高 gzip 不打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；bzip2 命令不支持压缩目录，没有“-r”选项 ③ 举例说明： 直接压缩文件，将anaconda-ks.cfg文件压缩成\".bz2\"格式： bzip2 anaconda-ks.cfg 压缩的同时保留源文件： bzip2 -k install.log.syslog 4 bunzip2 ① bunzip2命令简介： 解压“.bz2”格式的压缩包文件，除了使用“bzip2 -d 压缩包名”命令外，还可以使用 bunzip2 命令 bunzip2 命令的基本格式如下： bunzip2 [选项] 源文件 ② bunzip2命令常用选项参数： -k：解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数 -f：解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项 -v：显示命令执行过程 -L：列出压缩文件内容 -t：测试压缩文件是否正常，但不对其做解压缩操作 ③ 举例说明： 直接解压缩文件: bunzip2 install.log.bz2 解压 test 目录下的内容: bunzip2 -r test/ 5 zip ① zip命令简介： “.zip”格式文件是 Windows 和 Linux 系统都通用的压缩文件类型 zip 命令的基本格式如下： zip [选项] 压缩包名 源文件或源目录列表 zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用 ② zip命令常用选项参数： -r：递归压缩目录，即将制定目录下的所有文件以及子目录全部压缩 -m：将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中 -v：显示详细的压缩过程信息 -q 在压缩的时候不显示命令的执行过程 -u：更新压缩文件，即往压缩文件中添加新文件 -压缩级别：压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好 ③ 举例说明： 压缩单个文件，压缩文件到 ana.zip 压缩包中: zip ana.zip anaconda-ks.cfg 压缩多个文件,同时压缩多个文件到 test.zip 压缩包中: zip test.zip install.log install.log.syslog 6 unzip ① unzip命令简介： unzip 命令可以查看和解压缩 zip 文件，该命令的基本格式如下： unzip [选项] 压缩包名 ② unzip命令常用选项参数： -d 目录名：将压缩文件解压到指定目录 -n：解压时并不覆盖已经存在的文件 -o：解压时覆盖已经存在的文件，并且无需用户确认 -v 查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作 -t：测试压缩文件有无损坏，但并不解压 -x 文件列表：解压文件，但不包含文件列表中指定的文件 ③ 举例说明： 解压缩： unzip dir1.zip 把压缩包解压到指定位置： unzip -d /tmp/ ana.zip 7.3 打包和压缩 1 tar.gz 和 tar.bz2 Linux中，打包命令可以和压缩命令同时使用，该命令的基本格式如下： tar [选项] 压缩包 源文件或目录 此处常用的选项有以下 2 个，分别是： -z：压缩和解压缩 \".tar.gz\" 格式 -j：压缩和解压缩 \".tar.bz2\"格式 配合 tar 命令常用选项参数： -c：将多个文件或目录进行打包 -x：对 tar 包做解打包操作 -v：显示打包文件过程 -f 包名：指定包的文件名 组合成4种常用参数： 解压缩： -jxvf -zxvf 压缩： -jcvf -zcvf 2 举例说明： 压缩 \".tar.gz\"格式 把 /temp/ 目录直接打包压缩为\".tar.gz\"格式： tar -zcvf tmp.tar.gz /tmp/ 解压缩 \".tar.gz\"格式 解压缩 tmp.tar.gz 文件包 tar -zxvf tmp.tar.gz 压缩 \".tar.bz2\"格式 把 /temp/ 目录直接打包压缩为\".tar.bz2\"格式： tar -jcvf tmp.tar.bz2 /tmp/ 解压缩 \".tar.bz2\"格式 解压缩 tmp.tar.bz2 文件包 tar -jxvf tmp.tar.bz2 8 权限管理 8.1 用户组 8.1.1 访问者身份 文件访问者身份是指文件权限设置所针对的用户和用户组，共有以下3种类型： 所有者：每个文件都有它的所有者，又称属主，简写为u。默认情况下，文件的创建者即为其所有者。所有者对文件具有所有权，是一种特别权限 所属组：指文件所有者所属的组，简称属组，简写为g，可为该组指定访问权限。默认情况下，文件的创建者的主要组即为该文件的所属组 其他用户：指文件所有者和所属组，以及root之外的所有用户，简写为o。通常其他用户对文件拥有最低的权限，甚至没有权限 8.2 权限模式 8.2.1 访问权限 对于每个文件，针对上述3类身份的用户可指定以下3种不同级别的访问权限： 读：读取文件内容或者查看目录 写：修改文件内容或者创建、删除文件 执行：执行文件或者允许使用cd命令进入目录 文件访问者身份、访问权限都包括在文件属性中，使用ls -l(ll)命令显示文件属性详细信息，见下图 第1个字符表示文件类型；第2个字段表示文件的权限(见下图)；第3个字段表示该文件的链接数目，1表示有一个硬链接；第4个字段表示这个文件的所有者；第5个字段表示这个文件的所属组；后面3个字段分别表示文件大小、修改日期和文件名称 第1个字符表示文件类型，d表示目录文件，-表示普通文件，l表示链接文件，b表示块设备文件，c表示字符设备文件 2-10字符分别表示文件所有者、所属组和其他用户的权限 3种文件权限依次用r、w和x表示读、写和执行，如果没有某种权限，则在相应权限位置用-表示 8.2.2 访问权限的八进制表示 读、写和执行可用8进制数字表示： 读：r --> 4 写：w --> 2 执行：x --> 1 所有权限组合的8进制表示见下图 8.3 命令行工具 1 chown ① chown命令简介： 文件所有者可以变更，即将所有权转让给其他用户，只有root才有权变更所有者 执行 chown 命令需要 root 权限，需要使用 sudo 命令 使用 chown 命令变更文件所有者，使其他用户对文件具有所有权，基本用法如下： chown [选项] [新所有者] 文件列表 ② chown命令常用选项参数： 使用选项-R进行递归变更，即目录连同其子目录下的所有文件的所有者都变更 ③ 举例说明： 举例说明：将 news 的所有者改为 wang sudo chown wang news 2 chgrp ① chgrp命令简介： 使用 chgrp 命令可以变更文件的所属组，基本用法如下： chgrp [选项] [新的所属组] 文件列表 执行 chgrp 命令需要 root 权限，需要使用 sudo 命令 同时，亦可以使用 chown 命令变更文件所属组，使其他用户对文件具有所有权，基本用法如下： chown [选项] [新所有者]:[新的所属组] 文件列表 使用选项-R进行递归变更，即目录连同其子目录下的所有文件的所属组都变更 ② 举例说明: 改变文件 fenti 所属组为 shentong sudo chgrp shentong fenti 3 chmod ① chmod命令简介： root 和文件所有者可以修改文件访问权限，使用 chmod 命令来修改文件权限，基本用法如下： chmod [选项] 模式 文件名 模式是文件权限的表达式，有字符和8进制两种表示方法 使用选项-R表示递归设置指定目录下所有文件的权限 执行 chmod 命令需要 root 权限，需要使用 sudo 命令 ② 文件权限用字符表示： “+”表示增加某种权限，”-”表示撤销某种权限，”=”表示指定某种权限（同时会取消其他权限） 对于用户类型，所有者、所属组和其他用户分别用字符 u、g、o表示，全部用户（包括3种用户）则用a表示 权限类型用r（读）、w（写）和x（执行）表示 ③ 举例说明： 对于 /home/ros/myfile 文件，给所属组用户增加写权限，给其他用户增加读权限 sudo chmod g+w, o+r /home/ros/myfile 对于 /home/ros/myfile 文件，同时撤销所属组和其他用户对该文件的读权限 sudo chmod go-r /home/ros/myfile 对于 /home/ros/myfile 文件，对所有用户赋予读和执行权限 sudo chmod a=rx /home/ros/myfile ④ 文件权限用数字表示： 将权限读（r）、写（w）和执行（x）分别用数字 4、2 和 1 表示，没有任何权限则表示为 0 每一类用户的权限用其各项权限的和表示(结果为数字0~7)，依次为所有(u)、所属组(g)和其他用户(0)的权限 ⑤ 举例说明： 754表示所有者、所属组和其他用户的权限依次为4+2+1、4+0+1和4+0+0，转化为字符表示就是：rwxr-xr-- 文件 file 的所有者拥有读写权限，所属组用户和其他用户只能读取 sudo chmod 644 file 相当于： sudo chmod u=rw,go=r file 9 软件包管理 9.1 Linux 软件包 Linux下的软件包分为两种，分别是 源码包 和 二进制包： 1 源码包：源码包是源代码程序，是由程序员按照特定的格式和语法编写出来的软件包 源码包安装需要经过编译 编译：指从源代码到直接被计算机执行的目标代码的翻译过程，编译器的功能是把源代码翻译为二进制代码，让计算机识别并运行 源码包一般包含多个文件，为了方便发布，通常会将源码包做打包压缩处理 2 二进制包：指源码包经过成功编译之后产生的软件包 二进制包是 Linux 下默认的软件安装包，二进制包有专用的包管理系统 DPKG 包管理系统：Debian 和 Ubuntu 的软件包管理工具 RPM 包管理系统：Fedora、CentOS、SuSE软件包管理工具 9.2 源码包安装流程 源码包：Linux 中最常用的打包压缩格式为“tar.gz”或“tar.bz2”，因此源码包又被称为 Tarball 整个安装过程可以分为以下几步： 1 找到相应的软件包 soft，比如 soft.tar.gz(或者 soft.tar.bz2)，下载到本机某个目录 2 打开一个终端，su 成 root 用户，或者使用 sudo 3 cd soft.tar.gz 或者cd soft.tar.bz2 所在的目录 4 tar -zxvf soft.tar.gz或者tar -jxvf soft.tar.bz2 5 cd soft 6 ./configure 7 make 8 make install 上述安装过程可以概括为以下几步： 1 取得应用软件：通过下载、购买光盘的方法获得 2 解压缩文件：如果是 .gz 格式，则可以执行：“tar -zxvf 软件包名”进行解压与解包工作。如果不是，则先用解压软件，再执行“tar -xvf 解压后的 tar 包”进行解包。如果是 .bz2 格式，则可以执行：“tar -jxvf 软件包名”进行解压与解包工作。如果不是，则先用解压软件，再执行“tar -xvf 解压后的 tar 包”进行解包。 3 阅读附带的 INSTALL 文件、README 文件 4 执行“./configure”命令为编译做好准备 5 执行“make”命令进行软件编译 6 执行“make install”完成安装 7 执行“make clean”删除安装时产生的临时文件 注解: 对于多数需要编译的软件，其安装的方法大体相同：执行解压缩后产生的一个名为 configure 的可执行脚本程序 configure 用于检查系统是否有编译时所需的库，以及库的版本是否满足编译的需要等安装所需要的系统信息。为随后的编译工作做准备。执行命令为：./configure 如果检查过程中，发现有错误，configure 将给予提示，并停止检查。用户可以跟据提示对系统进行配置，再重新执行该程序 检查通过后，将生成用于编译的 MakeFile 文件。此时，可以开始进行编译，执行命令为：make 成功编译后，键入如下的命令开始安装，执行命令为：make install 安装完毕，清除编译过程中产生的临时文件和配置过程中产生的文件。执行命令：make clean 一般来说，Linux的应用软件的可执行文件会存放在 /usr/local/bin 目录下，具体看INSTALL 和 README文件 9.3 Deb 包安装流程 Deb 包可从 Ubuntu 软件中心下载安装 Deb 是 Debian 软件包格式的文件扩展名，有两种安装deb包的方法：apt 和 dpkg apt 能在线下载并安装 deb 包，能更新系统，且还能自动处理包与包之间的依赖问题，这是 dpkg 工具所不具备的，apt 方式安装 deb 包步骤如下： 打开一个终端，su成 root 用户，或者使用 sudo apt-cache search soft # 注：先查找是否有需要的软件包soft(可选) 如果上一步中找到了软件 soft.version，则用 apt install soft.version 命令安装软件 # 注：下载对应版本的soft(可选) apt 是 debian，ubuntu发行版的包管理工具，apt 命令一般需要 root 权限执行，所以一般跟着 sudo 命令，例如：sudo apt xxxx sudo apt install packagename ——安装一个新软件包 sudo apt remove packagename ——卸载一个已安装的软件包 sudo apt autoremove ——apt会把已装或已卸的软件都备份在硬盘上，如果需要空间的话，可以让这个命令来删除你已经删掉的软件 sudo apt autoclean ——定期运行这个命令来清除那些已经卸载的软件包的.deb 文件 sudo apt clean ——这个命令会把安装的软件的备份也删除，不会影响软件的使用 sudo apt update ——更新软件源列表 sudo apt upgrade——升级所有已安装的软件包 sudo apt dist-upgrade——将系统升级到新版本 sudo apt-cache search string——在软件包列表中搜索字符串 sudo apt-cache showpkg pkgs ——显示软件包信息 sudo apt-cache show pkgs ——显示软件包记录 sudo apt-cache pkgnames——打印软件包列表中所有软件包的名称 dpkg 方式安装 deb 包步骤如下： 找到相应的软件包，比如 soft.version.deb，下载到本机某个目录 打开一个终端，su成 root 用户，或者使用 sudo cd soft.version.deb所在的目录 输入 dpkg -i soft.version.deb dpkg 常用选项参数： 安装：dpkg -i deb 的软件包名，如 dpkg -i software-1.2.3-1.deb 卸载：dpkg -e 软件名，如 dpkg -e software 查询：dpkg -l 软件名，如 dpkg -l software 9.4 Bin文件安装 如果软件名是 soft.bin，一般情况下是个可执行文件，安装方法如下： 打开一个终端，su成 root用户，或者使用 sudo chmod +x soft.bin ./soft.bin # 运行这个命令就可以执行软件安装 9.5 免安装软件包 有些软件是不需要安装的，解压缩后可直接运行，假设下载的是 firefox.tar.gz，使用方法如下： 打开一个终端，su成 root 用户，或者使用 sudo tar -zxvf firefox.tar.gz # 这一步会生成 firefox 的目录 cd firefox chmod +x firefox # 添加 firefox 可执行权限 执行命令 ./firefox 即可运行软件 每次运行要输入全路径或切换到生成的 firefox 目录里才可执行，在 /bin 目录下建立一个 firefox 的软链接，则打开一个终端输入 firefox 就可以运行此软件 如果要想 firefox 有个菜单项，使用菜单编辑工具，如 Alacarte Menu Editor。也可以到 /usr/share/applications 目录，按照里面其它 *.desktop 文件的格式生成一个自己的 desktop 文件，见1.2 Ubuntu安装之后要做的事 9.6 PPA 安装 APT 和 Ubuntu 软件中心都是通过软件源方式安装软件，APT会从每一个软件源（软件仓库）下载一个软件包的列表到本地，列表中提供有软件源所包含的可用软件包的信息 通常从 Ubuntu 官方仓库中获取软件，考虑到稳定性，Ubuntu 官方仓库收录的软件比较正式，版本相对滞后 对于没有收录到 Ubuntu 官方仓库的软件，可以通过 PPA(Personal Package Archive)非正式的软件仓库进行安装，其格式如下： sudo add-apt-repository ppa:user/ppa-name sudo apt-get update sudo apt-get install ppa-name Ubuntu 使用文本文件 /etc/apt/sources.list 来保存软件包的安装和更新源的地址。另外与该文件功能相同的是 /etc/apt/sources.list.d/ 目录下的 list 文件。为在单独文件中写入安装源的地址提供了一种方式，通常用来安装第三方软件 执行 sudo apt update 就是同步(更新) /etc/apt/sources.list 和 /etc/apt/sources.list.d 目录下的 list 文件的软件源的索引，以获取最新的软件包 一个典型的软件源：deb http://cn.archive.ubuntu.com/ubuntu/ utopic-backports main restricted universe multiverse，共有3个字段，字段间用空格分隔： 第1个字段位于行首，用于指示软件包的类型。Debian 类型的软件包使用 deb 或者 deb-src，分别表示直接通过 .deb 文件进行安装或者通过源文件的方式进行安装 第2个字段定义URL，表示提供软件源的 CD-ROM、HTTP 或 FTP 服务器的 URL 地址 第3个字段定义软件包的发行版本或分类，用于帮助 APT 命令遍历软件库。这些分类是用空格隔开的字符串，每个字符串分别对应相应的目录结构： main： Canonical支持的开源软件，大部分都是从这个分支获取的 universe：社区维护的开源软件 restricted：由设备生产商专有的设备驱动软件 multiverse：受版权或者法律保护的相关软件 security：重要的安全更新 updates：推荐的一般更新 proposed：预览版的更新 backports：无支持的更新，这种更新通常还存在一些bug new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter2.html":{"url":"Markdown/Ubuntu/chapter2.html","title":"2 基础命令","keywords":"","body":"2 常用命令 1 此部分记录 Ubuntu 中常用命令行工具:   1）Linux命令基础：文件目录操作命令   2）Linux命令基础：文件查找命令   3）Linux命令基础：其他命令new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter2-1.html":{"url":"Markdown/Ubuntu/chapter2-1.html","title":"2.1 文件目录操作命令","keywords":"","body":"1 Linux命令基础：文件目录操作命令 1.1 ls命令 ls 命令是 linux 下最常用的命令，ls 命令就是 list 的缩写 ls 用来打印出当前目录的清单。如果 ls 指定其他目录，那么就会显示指定目录里的文件及文件夹清单 通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且还可以查看目录和文件权限等信息 1.1.1 命令格式 ls [选项] [文件] 备注：[]表示其为可选参数 1.1.2 常用参数 参数 描述 -a –all 列出目录下的所有文件，包括以 . 开头的隐含文件 -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 --help 帮助信息 备注：在linux系统中，通过“命令 --help”可获取该命令的帮助信息 1.1.3 常用范例 例一：列出/home/文件夹下的所有文件和目录的详细资料，可以使用如下命令： ls -a -l /home ls -al /home 上面两个命令执行结果一样，即多个参数可以合并使用，运行结果如下： ros@ros-course:~$ ls -a -l /home 总用量 12 drwxr-xr-x 3 root root 4096 6月 4 07:26 . drwxr-xr-x 25 root root 4096 8月 10 16:45 .. drwxr-xr-x 31 ros ros 4096 8月 12 08:25 ros ros@ros-course:~$ ls -al /home 总用量 12 drwxr-xr-x 3 root root 4096 6月 4 07:26 . drwxr-xr-x 25 root root 4096 8月 10 16:45 .. drwxr-xr-x 31 ros ros 4096 8月 12 08:25 ros 运行结果说明： 第1行，ros@ros-course：第一个ros为用户名，ros-course为计算机名称，~$表示普通用户，#表示root用户，具有root权限） 第2行，总计(total) 第3-5行，文件详细信息，包含7个字段，具体参见ls -l 详解： 第1字段: 文件属性字段 第2字段：文件硬链接数，链接占用的节点 第3字段：文件（目录）拥有者 第4字段：文件（目录）拥有者所在的组 第5字段: 文件所占用的空间(以字节为单位) 第6字段：文件（目录）最近访问（修改）时间 第7字段：文件名 1.2 cd命令 cd 命令是 change directory 的缩写 cd命令切换当前目录至指定的目录 1.2.1 命令格式 cd [目录名] 备注：cd后不跟参数，进入主目录 1.2.2 常用范例 例一：从当前目录进入系统根目录，可以使用如下命令： cd / 例二：从当前目录进入父目录，可以使用如下命令： cd .. .. 表示父目录，即上一级目录 例三：从当前目录进入当前用户主目录，可以使用如下命令： cd ~ ~ 表示当前用户主目录，注意它与系统根目录不是同一个概念 例四：从当前目录进入上次所在目录，可以使用如下命令： cd - - 表示上次进入的目录 1.3 pwd命令 pwd 命令是 Print Working Directory 的缩写 Linux 中用 pwd 命令来查看“当前工作目录”的完整路径 每当在终端进行操作时，都会有一个当前工作目录。在不太确定当前位置时，就可以使用 pwd 来判定当前目录在文件系统内的确切位置 1.3.1 命令格式 pwd [选项] 1.3.2 常用参数 参数 描述 -P 显示实际物理路径，而非使用连接（link）路径 -L 当目录为连接路径时，显示连接路径 1.3.3.常用范例 例一：显示当前目录所在路径，可以使用如下命令： pwd 例二：显示当前目录的物理路径，可以使用如下命令： pwd -P 例三：显示当前目录的连接路径，可以使用如下命令： pwd -L 运行结果如下： ros@ros-course:~$ cd /usr/local/man ros@ros-course:/usr/local/man$ pwd /usr/local/man ros@ros-course:/usr/local/man$ pwd -P /usr/local/share/man ros@ros-course:/usr/local/man$ pwd -L /usr/local/man 1.4 touch命令 touch命令用来新建一个不存在的文件，或者修改文件时间戳 1.4.1 命令格式： touch [选项] 文件 1.4.2 命令参数： 参数 描述 -a 只更改存取时间 -d 使用指定的日期时间，而非现在的时间 -t 使用指定的日期时间，而非现在的时间 -m 只更改变动时间 -r 把指定文档或目录的日期时间，设成和参考文档或目录的日期时间相同 1.4.3 使用范例： 例一：创建文件log1.log和log2.log： sudo touch log1.log log2.log 运行结果如下： ros@ros-course:~/ROS_Course$ sudo touch log1.log log2.log ros@ros-course:~/ROS_Course$ ls -l 总用量 0 -rw-r--r-- 1 root root 0 8月 12 11:44 log1.log -rw-r--r-- 1 root root 0 8月 12 11:44 log2.log 备注：sudo命令表示以系统管理者的身份执行指令，经由 sudo 所执行的指令等同于 root 执行 例二：创建log3.log，更新log3.log的时间和log2.log时间戳相同： 创建log3.log ros@ros-course:~/ROS_Course$ sudo touch log3.log ros@ros-course:~/ROS_Course$ ls -l 总用量 0 -rw-r--r-- 1 root root 0 8月 12 11:44 log1.log -rw-r--r-- 1 root root 0 8月 12 11:44 log2.log -rw-r--r-- 1 root root 0 8月 12 11:46 log3.log 更改log3.log时间与log2.log相同 ros@ros-course:~/ROS_Course$ sudo touch -r log2.log log3.log ros@ros-course:~/ROS_Course$ ls -l 总用量 0 -rw-r--r-- 1 root root 0 8月 12 11:44 log1.log -rw-r--r-- 1 root root 0 8月 12 11:44 log2.log -rw-r--r-- 1 root root 0 8月 12 11:44 log3.log 例三：设定文件的时间戳： touch -t 202111142234.50 log1.log 运行结果如下： ros@ros-course:~/ROS_Course$ sudo touch -t 202111142234.50 log1.log ros@ros-course:~/ROS_Course$ ls -l 总用量 0 -rw-r--r-- 1 root root 0 11月 14 2021 log1.log -rw-r--r-- 1 root root 0 8月 12 11:44 log2.log -rw-r--r-- 1 root root 0 8月 12 11:44 log3.log 补充说明： -t time 使用指定的时间值 time 作为指定文件相应时间戳记的新值。此处的 time规定为如下形式的十进制数: [[CC]YY]MMDDhhmm[.SS] CC为年数中的前两位，即”世纪数”；YY为年数的后两位，即某世纪中的年数。如果不给出CC的值，则touch 将把年数CCYY限定在1969--2068之内 MM为月数，DD为天数，hh 为小时数(几点)，mm为分钟数，SS为秒数。此处秒的设定范围是0--61，这样可以处理闰秒。这些数字组成的时间是环境变量TZ指定的时区中的一个时间。由于系统的限制，早于1970年1月1日的时间是错误的 1.5 mkdir命令 mkdir 命令是 make directory 的缩写 mkdir 命令用来创建指定名称的目录 要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录 1.5.1 命令格式 mkdir [选项] 目录 1.5.2 常用参数 参数 描述 -m 设定权限 -p 可以是一个路径名称。若路径中的某些目录尚不存在，加上此选项后，系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录 -v 每次创建新目录都显示信息 1.5.3 常用范例 例一：递归创建多个目录 ，可以使用如下命令： mkdir -p ROS/test 例二：创建权限为 777 的目录，可以使用如下命令： mkdir -m 777 ROS 运行结果如下： ros@ros-course:~/ROS_Course$ mkdir -m777 ROS ros@ros-course:~/ROS_Course$ ls -l 总用量 4 drwxrwxrwx 2 ros ros 4096 8月 12 17:55 ROS 例三：创建目录显示信息，可以使用如下命令： mkdir -vp ROS/test 运行结果如下： ros@ros-course:~/ROS_Course$ mkdir -vp ROS/test mkdir: 已创建目录 'ROS' mkdir: 已创建目录 'ROS/test' 1.5.4 练习题 尝试以下命令，看看有什么事情发生，tree 命令需要单独安装 sudo apt-get update sudo apt-get install tree mkdir -vp ROS/{lib/,bin/,doc/{info,product}} tree ROS/ 1.6 rm命令 rm命令是 remove 的缩写 rm命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除 对于链接文件，只会删除链接，原文件均保持不变 注意：rm 是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行 rm -rf） 1.6.1 命令格式 rm [选项] 文件或目录 1.6.2 常用参数 参数 描述 -f 忽略不存在的文件，从不给出提示 -i 进行交互式删除 -r 指示 rm 将参数中列出的全部目录和子目录均递归地删除 -v 详细显示进行的步骤 1.6.3 常用范例 先来创建一个测试文本： sudo touch ROS.log 例一：删除文件，系统会先询问是否删除，可以使用如下命令： rm ROS.log 运行结果如下： ros@ros-course:~/ROS_Course$ rm ROS.log rm：是否删除有写保护的普通空文件 'ROS.log'？ y 例二：强行删除文件，系统不再提示，可以使用如下命令： rm -f ROS.log 例三：删除后缀名为.log 的所有，删除前逐一询问，可以使用如下命令： rm *.log 或 rm -i *.log 运行结果如下： ros@ros-course:~/ROS_Course$ sudo touch a.log ros@ros-course:~/ROS_Course$ sudo touch b.log ros@ros-course:~/ROS_Course$ sudo touch c.log ros@ros-course:~/ROS_Course$ ls a.log b.log c.log ros@ros-course:~/ROS_Course$ rm *.log rm：是否删除有写保护的普通空文件 'a.log'？ y rm：是否删除有写保护的普通空文件 'b.log'？ y rm：是否删除有写保护的普通空文件 'c.log'？ y ros@ros-course:~/桌面/ROS_Course/Examples_folder$ ls 补充说明：*在Linux中表示匹配任意字符串，其他特殊字符使用参见linux（ubuntu）中一些特殊符号.md 1.7 mv命令 mv 命令是 move 的缩写 mv 命令功能是用来移动文件或更改文件名，经常用来备份文件或者目录 mv 命令根据第二个参数类型（目标是一个文件还是目录），决定执行将文件重命名或将其移至一个新的目录中 当第二个参数类型是文件时，mv 命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名 当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv 命令将各参数指定的源文件均移至目标目录中 1.7.1 命令格式 mv [选项] 源文件或目录 目标文件或目录 1.7.2 常用参数 参数 描述 -b 若需覆盖文件，则覆盖前先行备份 -f 如果目标文件已经存在，不会询问而直接覆盖 -i 若目标文件已经存在时，就会询问是否覆盖 -u 若目标文件已经存在，且源文件比较新，才会更新 -t 该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后 1.7.3 常用范例 例一：将文件ROS.log重命名为ROS1.log，可以使用如下命令： mv ROS.log ROS1.log 运行结果如下： ros@ros-course:~/ROS_Course$ sudo touch ROS.log ros@ros-course:~/ROS_Course$ ls ROS.log ros@ros-course:~/ROS_Course$ mv ROS.log ROS1.log ros@ros-course:~/ROS_Course$ ls ROS1.log 例二：将文件ROS1.log移动到 test 目录下（test 目录必须已经存在，否则执行重命名），可以使用如下命令： mv ROS1.log test 运行结果如下： ros@ros-course:~/ROS_Course$ mkdir test ros@ros-course:~/ROS_Course$ ls ROS1.log test ros@ros-course:~/ROS_Course$ mv ROS1.log test ros@ros-course:~/ROS_Course$ ls test ros@ros-course:~/ROS_Course$ cd test ros@ros-course:~/ROS_Course/test$ ls ROS1.log 例三：将文件ROS1.log移动到 test 目录下，如果文件存在，覆盖前询问是否覆盖，可以使用如下命令： mv -i ROS1.log test 运行结果如下： ros@ros-course:~/ROS_Course$ touch ROS1.log ros@ros-course:~/ROS_Course$ mv -i ROS1.log test mv：是否覆盖'test/ROS1.log'？ y 1.7.4 思考题 思考下面这段代码有什么作用？ D=/tmp/$(date \"+%Y%m%d%H%M%S\") mkdir -p $D mv \"$@\" $D && echo \"moved to $D ok\" 1.8 cp命令 cp 命令是 copy 的缩写 cp 命令用来复制文件或者目录 1.8.1 命令格式 cp [选项] 源文件 目录 cp [选项] -t 目录 源文件 1.8.2 常用参数 参数 描述 -t 指定目标目录 -i 覆盖前询问 -n 不要覆盖已存在的文件 -s 对源文件建立符号链接，而非复制文件 -f 强行复制文件或目录，不论目的文件或目录是否已经存在 -u 使用这项参数之后，只会在源文件的修改时间较晚的文件更新时，或是对应的目的文件并不存在，才复制文件 1.8.3 常用范例 例一：对文件ROS.log建立一个符号链接r.log，可以使用如下命令： cp -s ROS.log r.log 例二：将 test 目录下的所有文件复制到 test1 目录下，覆盖前询问，可以使用如下命令： cp -i test/* test1 运行结果如下： ros@ros-course:~/ROS_Course$ mkdir test1 ros@ros-course:~/ROS_Course$ ls r.log ROS.log test test1 ros@ros-course:~/ROS_Course$ cp -i test/* test1 ros@ros-course:~/ROS_Course$ cd test1 ros@ros-course:~/ROS_Course/test1$ ls ROS1.log 例三：将 test1 目录下的最近更新的文件复制到 test目录下，覆盖前询问，可以使用如下命令： cp -iu test1/* test 运行结果如下： ros@ros-course:~/ROS_Course$ cd test ros@ros-course:~/ROS_Course/test$ ls -l 总用量 0 -rw-rw-r-- 1 ros ros 0 8月 12 16:27 ROS1.log ros@ros-course:~/ROS_Course/test$ cd ../test1 ros@ros-course:~/ROS_Course/test1$ ls -l 总用量 4 -rw-rw-r-- 1 ros ros 4 8月 12 17:01 ROS1.log ros@ros-course:~/ROS_Course/test1$ cd .. ros@ros-course:~/ROS_Course$ cp -iu test1/* test cp：是否覆盖'test/ROS1.log'？ y 1.9 cat命令 cat 命令是 concatenate 的缩写 cat 命令的功能是将文件或标准输入组合输出到标准输出 这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用 1.9.1 命令格式 cat [选项] 文件 1.9.2 常用参数 参数 描述 -A 等价于 -vET -b 对非空输出行编号 -e 等价于 -vE -E 在每行结束处显示 $ -n 由 1 开始对所有输出的行数编号 -s 有连续两行以上的空白行，就代换为一行的空白行 -t 与 -vT 等价 -T 将跳格字符显示为 ^I -v 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 1.9.3 常用范例 例一：把ROS.log的文件内容加上行号后输入ROS1.log这个文件里，可以使用如下命令： cat -n ROS.log > ROS1.log 运行结果如下： ros@ros-course:~/ROS_Course$ cat ROS.log a b c d e f ros@ros-course:~/ROS_Course$ cat -n ROS.log > ROS1.log ros@ros-course:~/ROS_Course$ cat ROS1.log 1 a 2 b 3 c 4 d 5 e 6 f 运行结果说明： “ cmd > file”中，\">\" 表示重定向输出。把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，使用bash的noclobber选项可以防止复盖原有文件 “cmd >> file”中，\">>\" 表示重定向输出。把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件後面 “cmd “cmd 例二：把ROS.log的文件内容加上行号后追加到ROS2.log这个文件里，多行空行换成一行输出，可以使用如下命令： cat -ns ROS.log >> ROS2.log 运行结果如下： ros@ros-course:~/ROS_Course$ cat ROS.log a b c d e f ros@ros-course:~/ROS_Course$ cat -ns ROS.log >> ROS2.log ros@ros-course:~/ROS_Course$ cat ROS2.log 1 a 2 b 3 4 c 5 6 d 7 8 e 9 f 例三：将ROS.log的文件内容反向显示，可以使用如下命令： tac ROS.log 运行结果如下： ros@ros-course:~/ROS_Course$ tac ROS.log f e d c b a 运行结果说明：tac 是将 cat 反写过来，所以它的功能就跟 cat 相反， tac 由最后一行开始到第一行反向在屏幕上显示出来 1.9.4 思考题 执行下面命令会输出什么？为什么？ ros@ros-course:~/ROS_Course$ cat -A 1 > 2 > 3 > 4 > a 1.10 more命令 more 命令，功能类似 cat ，cat 命令是将整个文件的内容从上到下显示在屏幕上。more 命令会一页一页的显示，方便使用者逐页阅读，最基本的指令就是按空格键（space）往下一页显示，按 B 键就会往回（back）一页显示，而且还有搜寻字串的功能 more 命令从前向后读取文件，因此在启动时就加载整个文件 1.10.1 命令格式 more [选项] 文件 1.10.2 常用参数 参数 描述 +n 从笫 n 行开始显示 -n 定义屏幕大小为 n 行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quiet”，禁用响铃功能 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c 选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下划线去掉 1.10.3 常用操作 符号 描述 = 输出当前行的行号 q 退出 more 空格键 向下滚动一屏 b 返回上一屏 1.10.4 常用范例 创建文件ROS3.log，文件内容如下： 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 2021-11-5 f 2021-11-5 g 2021-11-5 h 2021-11-5 e 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 2021-11-5 f 2021-11-5 g 2021-11-5 h 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 例一：从第五行开始显示ROS3.log文件中的内容，可以使用如下命令： more +5 ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ more +5 ROS3.log 2021-11-5 e 2021-11-5 f 2021-11-5 g 2021-11-5 h 2021-11-5 e 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 2021-11-5 f 2021-11-5 g 2021-11-5 h 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 例二：从ROS3.log文件中查找第一个出现“g”字符串的行，并从该处前两行开始显示输出，可以使用如下命令： more +/g ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ more +/g ROS3.log ...跳过 2021-11-5 e 2021-11-5 f 2021-11-5 g 2021-11-5 h 2021-11-5 e 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 2021-11-5 f 2021-11-5 g 2021-11-5 h 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 例三：设定每屏行数为 5，可以使用如下命令： more -5 ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ more -5 ROS3.log 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e --更多--(22%) 例四：使用 ls 和 more 命令显示/etc目录信息，可以使用如下命令： ls -l /etc | more -10 运行结果如下： ros@ros-course:~/ROS_Course$ ls -l /etc | more -10 总用量 1396 drwxr-xr-x 3 root root 4096 2月 4 2020 acpi -rw-r--r-- 1 root root 3028 2月 4 2020 adduser.conf drwxr-xr-x 2 root root 12288 8月 10 16:35 alternatives -rw-r--r-- 1 root root 401 5月 30 2017 anacrontab drwxr-xr-x 3 root root 4096 8月 8 17:28 apache2 -rw-r--r-- 1 root root 433 10月 2 2017 apg.conf drwxr-xr-x 6 root root 4096 2月 4 2020 apm drwxr-xr-x 3 root root 4096 2月 4 2020 apparmor drwxr-xr-x 8 root root 4096 8月 8 16:52 apparmor.d --更多-- 每页显示 10 个文件信息，按 Ctrl+F 或者 空格键 将会显示下 10 条文件信息 1.11 less命令 less 命令也是对文件或其它输出进行分页显示的工具，是 linux 正统查看文件内容的工具 1.11.1 命令格式 less [选项] 文件 1.11.2 常用参数 参数 描述 -e 当文件显示结束后，自动离开 -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -i 忽略搜索时的大小写 -m 显示类似 more 命令的百分比 -N 显示每行的行号 -s 显示连续空行为一行 1.11.3 常用操作 符号 描述 /字符串 向下搜索“字符串”的功能 ?字符串 向上搜索“字符串”的功能 n 重复前一个搜索（与 / 或 ? 有关） N 反向重复前一个搜索（与 / 或 ? 有关） b 向前翻一页 d 向后翻半页 q 退出 less 命令 空格键 向后翻一页 向上键 向上翻动一行 向下键 向下翻动一行 1.11.4 常用范例 例一：显示ROS3.log文件中的内容，并显示行号，可以使用如下命令： less -N ROS3.log 运行结果如下： 1 2021-11-5 a 2 2021-11-5 b 3 2021-11-5 c 4 2021-11-5 d 5 2021-11-5 e 6 2021-11-5 f 7 2021-11-5 g 8 2021-11-5 h 9 2021-11-5 e 10 2021-11-5 a 11 2021-11-5 b 12 2021-11-5 c 13 2021-11-5 d 14 2021-11-5 e 15 2021-11-5 f 16 2021-11-5 g 17 2021-11-5 h 18 2021-11-5 a 19 2021-11-5 b 20 2021-11-5 c 21 2021-11-5 d 22 2021-11-5 e ~ (END) 例二：显示ROS3.log文件中的内容，搜索字符串”a”，可以使用如下命令： less ROS3.log /a 例三：ps 查看进程信息并通过 less 分页显示，可以使用如下命令： ps -f | less 运行结果如下： UID PID PPID C STIME TTY TIME CMD ros 3889 3882 0 10:23 pts/0 00:00:00 bash ros 4707 4706 0 10:30 pts/0 00:00:00 bash ros 5149 5148 0 10:34 pts/0 00:00:00 bash ros 23928 5149 0 22:11 pts/0 00:00:00 ps -f ros 23929 5149 0 22:11 pts/0 00:00:00 less (END) 1.11.5 less 与 cat 和 more 的区别 cat 命令功能：用于显示整个文件的内容，因为单独使用没有翻页功能，所以经常和 more 命令搭配使用，cat 命令还有一个可以将数个文件合并成一个文件的功能 more 命令功能：让画面在显示满一页时暂停，此时可按空格健继续显示下一个画面，或按 q 键停止显示 less 命令功能：less 命令的用法与 more 命令类似，也可以用来浏览超过一页的文件。所不同的是 less 命令除了可以按空格键向下显示文件外，还可以利用上下键来滚动文件。当要结束浏览时，只要在 less 命令的提示符“：”下按 q 键即可 1.12 head指令 head 命令主要是用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行 1.12.1 命令格式 head [选项] 文件 1.12.2 常用参数 参数 描述 -q 隐藏文件名 -v 显示文件名 -c 显示字节数 -n 显示的行数 1.12.3 常用范例 例一：显示ROS3.log文件中的前 5 行内容，可以使用如下命令： head -n 5 ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ head -n 5 ROS3.log 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 例二：显示ROS2.log和ROS3.log文件中的前 5 行内容，可以使用如下命令： head -n 5 ROS2.log ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ head -n 5 ROS2.log ROS3.log ==> ROS2.log ROS3.log 1.13 tail命令 tail 命令用于显示指定文件末尾内容，常用查看日志文件 1.13.1 命令格式 tail [选项] 文件 1.13.2 常用参数 参数 描述 -f 循环读取 -q 不显示处理信息 -v 显示详细的处理信息 -c 显示的字节数 -n 显示行数 1.13.3 常用范例 例一：显示ROS3.log文件中的最后 5 行内容，可以使用如下命令： tail -n 5 ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ tail -n 5 ROS3.log 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 例二：显示ROS3.log文件中的最后 5 行内容，当ROS3.log文件有新内容增加时自动更新显示，可以使用如下命令： tail -n 5 -f ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ ping www.shiyanlou.com >> ROS4.log & [1] 24886 ros@ros-course:~/ROS_Course$ tail -n 5 -f ROS4.log 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=1 ttl=89 time=34.9 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=2 ttl=89 time=33.1 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=3 ttl=89 time=35.2 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=4 ttl=89 time=33.0 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=5 ttl=89 time=33.6 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=6 ttl=89 time=33.2 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=7 ttl=89 time=36.9 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=8 ttl=89 time=35.0 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=9 ttl=89 time=32.4 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=10 ttl=89 time=33.3 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=11 ttl=89 time=33.1 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=12 ttl=89 time=33.1 ms 运行结果说明： ping www.shiyanlou.com >>ROS4.log 这条命令作用是 ping 远程主机，并将信息追加到ROS4.log文件中 & 的作用是将这条命令放在后台执行，这样ROS4.log文件就会一直有内容增加 使用 tail 命令的 -f 选项可以即时输出文件变化后追加的内容。tail -f filename 会把 filename 里最尾部的内容显示在屏幕上，并且不断刷新，使你看到最新的文件内容 linux 下执行 ping 命令会一直执行，必须手动停止才行。 windows 下执行 ping 命令时，默认发送四个请求后会自动停止 jobs 命令可查看正在后台运行的任务，kill 命令可杀死一个任务，但要使用任务的 pid，任务的 pid 可以通过 ps 命令查看获得，然后使用k&ill -9 任务pid可以将这个后台进程杀死 1.14 nl命令 nl 命令是 number of lines 的缩写 nl 命令用来计算文件中的行号 nl 可以将输出的文件内容自动加上行号，其默认的结果与 cat -n 有点不太一样。nl 可以将行号做较多的显示设计，包括位数、是否自动补齐 0 等功能 1.14.1 命令格式 nl [选项] [文件] 1.14.2 常用参数 参数 描述 -b 指定行号的方式，主要有两种：-b a 表示不论是否为空行，也同样列出行号（类似 cat -n）-b t 表示如果有空行，空的那一行不要列出行号（默认值） -n 列出行号表示的方法，主要有三种：-n ln 行号在屏幕的最左方显示-n rn 行号在自己栏位的最右方显示，且不加 0-n rz 行号在自己栏位的最右方显示，且加 0 -w 行号栏位的占用的位数 1.14.3 常用范例 例一：把ROS.log的文件内容加上行号后显示，空行不加行号，可以使用如下命令： nl -b t ROS.log 运行结果如下： ros@ros-course:~/ROS_Course$ cat ROS.log a b u f ros@ros-course:~/ROS_Course$ nl -bt ROS.log 1 a 2 b 3 u 4 f 例二：把ROS.log的文件内容加上行号后显示，行号分别在屏幕最左方、最右方不加 0 和最右方加 0 显示，可以使用如下命令： nl -n ln ROS.log nl -n rn ROS.log nl -n rz ROS.log 运行结果如下： ros@ros-course:~/ROS_Course$ nl -n ln ROS.log 1 a 2 b 3 u 4 f ros@ros-course:~/ROS_Course$ nl -n rn ROS.log 1 a 2 b 3 u 4 f ros@ros-course:~/ROS_Course$ nl -n rz ROS.log 000001 a 000002 b 000003 u 000004 f 例三：把ROS.log的文件内容加上行号后显示，行号在屏幕最右方加 0 显示，行号栏目占位数为 3，可以使用如下命令： 5nl -n rz -w 3 ROS.log 运行结果如下： ros@ros-course:~/ROS_Course$ nl -n rz -w 3 ROS.log 001 a 002 b 003 u 004 f 1.15 echo命令 echo 命令用来在标准输出中显示输入的字符串 1.15.1 命令格式 echo [选项] 字符串 1.15.2 常用参数 参数 描述 -n 输出字符串不换行 -e 处理转义字符：\\a 发出警告声\\b 删除前一个字符\\c 最后不加上换行符号\\f 换行但光标仍旧停留在原来的位置\\n 换行且光标移至行首\\r 光标移至行首，但不换行\\t 插入tab\\v 与\\f相同\\ 插入\\字符\\0nnn 字节数以八进制数 NNN (1至3位)表示\\xHH 字节数以十六进制数 HH (1至2位)表示 -E 禁用转义解释 1.15.3 常用范例 例一：显示普通字符串： ros@ros-course:~/ROS_Course$ echo \"It is a test\" It is a test 例二：显示转义字符： ros@ros-course:~/ROS_Course$ echo \"\\\"It is a test\\\"\" \"It is a test\" 例三：显示结果定向至文件： echo \"It is a test\" > ROS5.txt 运行结果如下： ros@ros-course:~/ROS_Course$ echo \"It is a test\" > ROS5.txt ros@ros-course:~/ROS_Course$ ls r.log ROS1.log ROS2.log ROS3.log ROS4.log ROS5.txt ROS.log test test1 ros@ros-course:~/ROS_Course$ more ROS5.txt It is a test 例四：显示命令执行结果： echo `date` 运行结果如下： ros@ros-course:~/ROS_Course$ echo `date` 2021年 08月 12日 星期四 23:26:45 CST 注意：这里使用的是反引号 `, 而不是单引号 ' 1.15.4 思考题 输入echo --help会发生什么？echo指令如何查看帮助文档？ 1.16 chmod命令 chmod 命令是 change mode的缩写 chmod命令作用是控制用户对文件的权限的命令 1.16.1 命令格式 chmod [选项] mode 文件/目录 补充说明： Linux 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users），见下图 只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限 1.16.2 常用参数 参数 描述 -c 若该文件权限确实已经更改，才显示其更改动作 -f 若该文件权限无法被更改也不要显示错误讯息 -v 显示权限变更的详细资料 -R 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更) mode 权限设定字串，格式如下 : [ugoa] [+-=] [rwxX] u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是+ 表示增加权限、- 表示取消权限、= 表示将用户类型的所有权限重新设置r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行 1.16.3 八进制语法 chmod命令可以使用八进制数来指定权限 文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者、用户组以及其它用户（Other）的读、写、执行，见下图 # 权限 rwx 二进制 7 读 + 写 + 执行 rwx 111 6 读 + 写 rw- 110 5 读 + 执行 r-x 101 4 只读 r-- 100 3 写 + 执行 -wx 011 2 只写 -w- 010 1 只执行 --x 001 0 无 --- 000 读权限，表示你可以使用 cat 之类的命令来读取某个文件的内容；写权限，表示你可以编辑和修改某个文件的内容；执行权限，通常指可以运行的二进制程序文件或者脚本文件 一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件 上例中， 765 将这样解释： 所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7 用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6 其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5 1.16.4 常用范例 例一：将文件 ROS1.txt 设为所有人皆可读取 ： chmod ugo+w ROS1.txt or chmod a+w ROS1.txt g、o 、 u 分别表示 group（用户组）、others（其他用户） 和 user（用户），+ 和 - 分别表示增加和去掉相应的权限 运行结果如下： ros@ros-course:~/ROS_Course$ touch ROS1.txt ros@ros-course:~/ROS_Course$ ls -l ROS1.txt -rw-rw-r-- 1 ros ros 0 8月 13 16:33 ROS1.txt ros@ros-course:~/ROS_Course$ chmod ugo+w ROS1.txt ros@ros-course:~/ROS_Course$ ls -l ROS1.txt -rw-rw-rw- 1 ros ros 0 8月 13 16:33 ROS1.txt 例二：将文件ROS2.txt 与ROS3.txt 设为该文件拥有者、以及其所属同一个群体者只可写入，其他以外的人只执行 ： chmod ug=w,o=r ROS2.txt ROS3.txt 运行结果如下： ros@ros-course:~/ROS_Course$ touch ROS2.txt ROS3.txt ros@ros-course:~/ROS_Course$ ls -l ROS2.txt ROS3.txt -rw-rw-r-- 1 ros ros 0 8月 13 16:41 ROS2.txt -rw-rw-r-- 1 ros ros 0 8月 13 16:41 ROS3.txt ros@ros-course:~/ROS_Course$ chmod ug=w,o=x ROS2.txt ROS3.txt ros@ros-course:~/ROS_Course$ ls -l ROS2.txt ROS3.txt --w--w---x 1 ros ros 0 8月 13 16:41 ROS2.txt --w--w---x 1 ros ros 0 8月 13 16:41 ROS3.txt 例三：将文件ROS4.txt设为该文件拥有者、所属组以及其他人均可读、写、执行： chmod a=rwx ROS4.txt or chmod 777 ROS4.txt 运行结果如下： ros@ros-course:~/ROS_Course$ touch ROS4.txt ros@ros-course:~/ROS_Course$ ls -l ROS4.txt -rw-rw-r-- 1 ros ros 0 8月 13 16:51 ROS4.txt ros@ros-course:~/ROS_Course$ chmod a=rwx ROS4.txt ros@ros-course:~/ROS_Course$ ls -l ROS4.txt -rwxrwxrwx 1 ros ros 0 8月 13 16:51 ROS4.txt ros@ros-course:~/ROS_Course$ rm ROS4.txt && touch ROS4.txt ros@ros-course:~/ROS_Course$ ls -l ROS4.txt -rw-rw-r-- 1 ros ros 0 8月 13 16:54 ROS4.txt ros@ros-course:~/ROS_Course$ chmod 777 ROS4.txt ros@ros-course:~/ROS_Course$ ls -l ROS4.txt -rwxrwxrwx 1 ros ros 0 8月 13 16:54 ROS4.txt 例四：将test目录下的所有文件与子目录皆设为任何人可写入： chmod -R a+w test 当前test及test下ROS1.log文件的权限如下： drwxrwxr-x 2 ros ros 4096 8月 12 16:28 test -rw-rw-r-- 1 ros ros 4 8月 12 17:03 ROS1.log 运行结果如下： drwxrwxrwx 2 ros ros 4096 8月 12 16:28 test -rw-rw-rw- 1 ros ros 4 8月 12 17:03 ROS1.log new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter2-2.html":{"url":"Markdown/Ubuntu/chapter2-2.html","title":"2.2 文件查找命令","keywords":"","body":"2 Linux命令基础：文件查找命令 2.1 which命令 which 命令在 PATH 变量指定的路径中搜索可执行文件的所在位置 which 命令一般用来确认系统中是否安装了指定的软件 2.1.1 命令格式 which 可执行文件名称 2.1.2 常用范例 例一：确认是否安装了 gcc，可以使用如下命令： which gcc 运行结果如下： ros@ros-course:~/ROS_Course$ which gcc /usr/bin/gcc 例二：查看 ls 命令的位置路径，可以使用如下命令： which ls 运行结果如下： ros@ros-course:~/ROS_Course$ which ls /bin/ls 备注：echo $PATH这条指令可以查看PATH路径的内容 补充知识：到底什么是命令？ 命令可以是下面四种形式之一： 是一个可执行程序，就像我们所看到的位于目录/usr/bin中的文件一样。属于这一类的程序，可以编译成二进制文件，诸如用 C 和 C++ 语言写成的程序，也可以是由脚本语言写成的程序，比如说 shell，perl，python，ruby等等 是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如， cd 命令就是一个 shell 内部命令 是一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 比如上面讲到的 cd 命令，在某些环境中就是一个 shell 函数 是一个命令别名。我们可以定义自己的命令，建立在其它命令之上 2.2 whereis 命令 whereis 命令用于定位可执行文件、源代码文件和帮助文件在文件系统中的位置 whereis 命令具有搜索源代码、指定备用搜索路径和搜索不寻常项功能 whereis 命令在数据库（/var/lib/mlocate/mlocate.db）查询，此数据库由 Linux 系统自动创建，包含有本地所有文件的信息，每天通过自动执行 updatedb 命令更新一次，因此whereis 命令查找速度非常快 因为此数据库要每天才更新一次，使得 whereis 命令的搜索结果有时候会不准确，比如刚添加的文件可能搜不到 2.2.1 命令格式 whereis [选项] 文件 2.2.2 常用参数 参数 描述 -b 定位可执行文件 -m 定位帮助文件 -s 定位源代码文件 -u 搜索默认路径下除可执行文件、源代码文件和帮助文件以外的其它文件 -B 指定搜索可执行文件的路径 -M 指定搜索帮助文件的路径 -S 指定搜索源代码文件的路径 2.2.3 常用范例 例一：搜索 gcc 可执行文件的路径，可以使用如下命令： whereis -b gcc 运行结果如下： ros@ros-course:~/ROS_Course$ whereis -b gcc gcc: /usr/bin/gcc /usr/lib/gcc 例二：搜索 gcc 帮助文件的路径，可以使用如下命令： whereis -m gcc 运行结果如下： ros@ros-course:~/ROS_Course$ whereis -m gcc gcc: /usr/share/man/man1/gcc.1.gz 例三：搜索 gcc 源代码的路径，可以使用如下命令： whereis -s gcc 运行结果如下： ros@ros-course:~/ROS_Course$ whereis -s gcc gcc: 运行结果说明：没有找到gcc源代码，输出结果为空 2.3 locate 命令 locate 命令跟 whereis 命令类似，它们使用的是相同的数据库。但 whereis 命令只能搜索可执行文件、帮助文件和源代码文件，locate命令可查找符合搜索字符串条件的文档或目录 locate 命令使用了十分复杂的匹配语法，可以使用特殊字元（如’*’和’?’）来指定需要查找的样本 2.3.1 命令格式 locate [选项] 搜索字符串 常用参数 参数 描述 -q 安静模式，不会显示任何错误讯息 -n 至多显示 n 个输出 -r 使用正则表达式做寻找的条件 -V 显示版本信息 2.3.2 常用范例 例一：搜索 etc 目录下所有以 sh 开头的文件，可以使用如下命令： locate /etc/sh 运行结果如下： ros@ros-course:~/ROS_Course$ locate /etc/sh /etc/shadow /etc/shadow- /etc/shells /snap/core/11420/etc/shadow /snap/core/11420/etc/shells /snap/core/8268/etc/shadow /snap/core/8268/etc/shells /snap/core18/2074/etc/shadow /snap/core18/2074/etc/shells /snap/core18/2128/etc/shadow /snap/core18/2128/etc/shells /snap/core20/1081/etc/shadow /snap/core20/1081/etc/shells 例二：搜索 etc 目录下文件名包含 lou 的文件，可以使用如下命令： locate /etc/*lou* 运行结果如下： ros@ros-course:~/ROS_Course$ locate /etc/*lou* /etc/modprobe.d/libopenni-sensor-pointclouds0.conf /etc/systemd/system/cloud-final.service.wants /etc/systemd/system/cloud-final.service.wants/snapd.seeded.service 例三：搜索 etc 目录下以字串h开头且以字符e结尾的文件，可以使用如下命令： locate /etc/h*e 运行结果如下： ros@ros-course:~/ROS_Course$ locate /etc/h*e /etc/hostname /snap/core/11420/etc/hostname /snap/core/8268/etc/hostname /snap/core18/2074/etc/hostname /snap/core18/2128/etc/hostname /snap/core20/1081/etc/hostname 2.4 find 命令（一） find 命令主要作用是沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作 2.4.1 命令格式 find [选项] [搜索路径] [表达式] 默认路径是当前目录，默认表达式为 -print 表达式组成：操作符、选项、测试表达式以及动作 2.4.2 常用参数 参数 描述 -print find 命令将匹配的文件输出到标准输出 -exec find 命令对匹配的文件执行该参数所给出的 shell 命令 -name 按照文件名查找文件 -type 查找某一类型的文件 -prune 使用这一选项可以使 find 命令不在当前指定的目录中查找，如果同时使用 -depth 选项，那么 -prune 将被 find 命令忽略 -user 按照文件属主来查找文件 -group 按照文件所属的组来查找文件 -mtime -n +n 按照文件的更改时间来查找文件，-n 表示文件更改时间距现在小于 n 天，+n 表示文件更改时间距现在大于 n 天，find 命令还有 -atime 和 -ctime 选项 备注：其他命令选项及表达式参见find --help 2.4.3 常用范例 例一：打印当前目录下的文件目录列表，可以使用如下命令： find or find . or find . -print 运行结果如下： ros@ros-course:~/ROS_Course$ find . ./ROS5.txt ./r.log ./ROS3.log ./ROS4.log ./ROS1.log ./test1 ./test1/ROS1.log ./test ./test/ROS1.log ./ROS2.log ./ROS.log 运行结果说明： .（点号）表示此目录本身，包含当前目录下所有隐藏目录和隐藏文件夹，一般可以不写，所以cd ~/. 和cd ~ 和cd ~/效果是一样的 .（点号）在文件名头部，代表一个隐藏文件 例二：打印当前目录下所有以.log结尾的文件名，可以使用如下命令： find . -name \"*.log\" 运行结果如下： ros@ros-course:~/ROS_Course$ find . -name \"*.log\" ./r.log ./ROS3.log ./ROS4.log ./ROS1.log ./test1/ROS1.log ./test/ROS1.log ./ROS2.log ./ROS.log 例三：打印当前目录下所有以.txt 或.log 结尾的文件名，可以使用如下命令： find . \\( -name \"*.log\" -or -name \"*.txt\" \\) 运行结果如下： ros@ros-course:~/ROS_Course$ find . \\( -name \"*.log\" -or -name \"*.txt \" \\) ./r.log ./ROS3.log ./ROS4.log ./ROS1.log ./test1/ROS1.log ./test/ROS1.log ./ROS2.log ./ROS.log 补充说明：find 命令可以通过逻辑操作符来创建复杂的逻辑关系，此例中使用了操作符 -or 。find 命令的逻辑操作符见下表： 例四：打印当前目录下所有不以.txt 结尾的文件名，可以使用如下命令： find . ! -name \"*.txt\" 运行结果如下： ros@ros-course:~/ROS_Course$ find . ! -name \"*.txt\" . ./r.log ./ROS3.log ./ROS4.log ./ROS1.log ./test1 ./test1/ROS1.log ./test ./test/ROS1.log ./ROS2.log ./ROS.log 2.5 find 命令（二） 本节将介绍如何根据文件类型、权限、所有者及操作符来查找匹配文件 根据文件类型来查找文件，使用 -type 选项，常见 find 文件类型见下表： 根据文件权限查找文件，使用 -perm 选项，所有者使用 -user 选项 2.5.1 常用范例 例一：打印当前目录下所有以 .txt 结尾的符号链接，可以使用如下命令： find . -type l -name \"*.txt\" -print 补充说明：Linux 软连接与硬连接 对于一个文件来说，有唯一的索引接点与之对应，而对于一个索引接点号，却可以有多个文件名与之对应 因此，在磁盘上的同一个文件可以通过不同的路径去访问该文件，产生了软连接和硬链接 通俗地讲， 硬链接可认为是一个文件拥有两个文件名，而软链接则是系统新建一个链接文件，此文件指向其所要指的文件。软链接可对文件和文件夹，硬链接仅针对文件 软连接(symbolic link)又叫符号连接，符号连接相当于Windows下的快捷方式， 不可以对文件夹建立硬连接 通过 ln [option] source_file dist_file可建立链接文件（source_file是待建立链接文件的文件，dist_file是新创建的链接文件，-s 建立软链接） 建立软连接： 建立a.txt 和 ROS.log 的软连接，可用如下代码： ln -s ROS.log a.txt 运行结果如下： ros@ros-course:~/ROS_Course$ ln -s ROS.log a.txt ros@ros-course:~/ROS_Course$ ls -l a.txt lrwxrwxrwx 1 ros ros 7 8月 13 11:40 a.txt -> ROS.log 打印当前目录下所有以 .txt 结尾的符号链接，运行结果如下： ros@ros-course:~/ROS_Course$ find . -type l -name \"*.txt\" -print ./a.txt 例二：打印当前目录下所有权限为 777 的 log 文件，可以使用如下命令： find . -type f -name \"*.log\" -perm 777 运行结果如下： ros@ros-course:~/ROS_Course$ chmod 777 ROS.log ros@ros-course:~/ROS_Course$ find . -type f -name \"*.log\" -perm 777 ./ROS.log 例三：打印当前目录下 ros 用户拥有的符号文件，可以使用如下命令： find . -type l -user ros 运行结果如下： ros@ros-course:~/ROS_Course$ find . -type l -user ros ./r.log ./a.txt 例四：打印当前目录下权限不是 777 和 664 的所有文件，可以使用如下命令： find . -type f \\( ! -perm 777 -and ! -perm 644 \\) 运行结果如下： ros@ros-course:~/ROS_Course$ find . -type f \\( ! -perm 777 -and ! -perm 644 \\) ./ROS5.txt ./ROS1.txt ./ROS2.txt ./ROS3.log ./ROS3.txt ./ROS4.log ./ROS1.log ./test1/ROS1.log ./test/ROS1.log ./ROS2.log 2.6 find 命令（三） 本节介绍如何使用 find 命令的 -exec 选项来实现对查找到的文件执行指定的动作命令 2.6.1 常用范例 例一：找到当前目录下所有 txt 文件，并显示其详细信息，可以使用如下命令： find . -name \"*.txt\" -exec ls -l {} \\; 运行结果如下： ros@ros-course:~/ROS_Course$ find . -name \"*.txt\" -exec ls -l {} \\; -rw-rw-r-- 1 ros ros 13 8月 12 23:25 ./ROS5.txt -rw-rw-rw- 1 ros ros 0 8月 13 16:33 ./ROS1.txt --w--w---x 1 ros ros 0 8月 13 16:41 ./ROS2.txt --w--w---x 1 ros ros 0 8月 13 16:41 ./ROS3.txt lrwxrwxrwx 1 ros ros 7 8月 13 11:40 ./a.txt -> ROS.log -rwxrwxrwx 1 ros ros 0 8月 13 16:54 ./ROS4.txt 运行结果说明： -exec 是 find 命令对找到的文件执行的动作，上面的命令是ls -l {} 在这里说明一下{}和\\;，{}是一个占位符，在 find 命令的执行过程中会不断地替换成当前找到的文件，相当于”ls -l 找到的文件” \\;是 -exec 命令结束的标记，因为规定 -exec 后面的命令必须以;结束，但;在 shell 中有特殊含义，必须要转义，所以写成\\; 例二：在当前目录中有很多 log 文件，现在想要把所有 log 文件下载下来，如果一个一个的下载很麻烦，我们可以先查找到所有的 log 文件，然后将这些文件内容写入到一个文件中，下载这一个文件就可以了，可以使用如下命令： find . -name \"*.log\" -exec cat {} \\; > all.log 例三：默认下，-exec 后面只能使用单个命令，如果想要多个命令，可以将多个命令写入脚本文件中，然后在 -exec 中使用这个脚本，可以使用如下命令： find . -name \"*.log\" -exec ./command.sh {} \\; 脚本内容： #!/bin/bash ls -l $1 #$1表示第一个参数 cat $1 注意，直接运行上面的代码可能会提示你find './command.sh' : 权限不够，这是因为新建的command.sh没有执行权限，只需要使用chmod +x command.sh给予它可执行权限再执行即可 2.7 xargs 命令 xargs命令是eXtended ARGuments的缩写 xargs一般是和管道一起使用，是给命令传递参数的一个过滤器，也是组合多个命令的一个工具，它能够捕获一个命令的输出，然后传递给另外一个命令 xargs可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据 xargs可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行 2.7.1 命令格式 command | xargs [选项] [command] 备注：xargs 命令应该紧跟在管道操作符之后，因为它以标准输入作为主要的源数据流 2.7.2 常用参数 参数 描述 -n 指定每行最大的参数数量，默认为所有的 -d 指定分隔符 -i 或 -I 将xargs的每项内容，一行一行赋值给 {}，后续使用时可以用 {} 代替 2.7.3 常用范例 例一：将多行输入转换为单行输出，可以使用如下命令： cat b.txt | xargs 运行结果如下： ros@ros-course:~/ROS_Course$ cat b.txt a v b f h d t h y j ros@ros-course:~/ROS_Course$ cat b.txt | xargs a v b f h d t h y j 例二：将单行输入转换为多行输出，可以使用如下命令： echo \"1 2 3 4 5 6 7\" | xargs -n 3 运行结果如下： ros@ros-course:~/ROS_Course$ echo \"1 2 3 4 5 6 7\" | xargs -n 3 1 2 3 4 5 6 7 例三：将单行输入转换为多行输出，指定分隔符为 h，可以使用如下命令： cat b.txt | xargs -d h -n 3 运行结果如下： ros@ros-course:~/ROS_Course$ cat c.txt fdsahfdsjafkludisaohkfdsaj ros@ros-course:~/ROS_Course$ cat c.txt | xargs -d h -n 3 fdsa fdsjafkludisao kfdsaj 例四：查找当前目录下所有 log文件并显示详细信息，可以使用如下命令： find . -type f -name \"*.log\" | xargs ls -l 运行结果如下： ros@ros-course:~/ROS_Course$ find . -type f -name \"*.log\" | xargs ls -l -rw-rw-r-- 1 ros ros 7399 8月 13 17:21 ./all.log -rw-rw-r-- 1 ros ros 44 8月 12 21:42 ./ROS1.log -rw-rw-r-- 1 ros ros 78 8月 12 17:23 ./ROS2.log -rw-rw-r-- 1 ros ros 271 8月 12 22:24 ./ROS3.log -rw-rw-r-- 1 ros ros 6980 8月 12 22:30 ./ROS4.log -rwxrwxrwx 1 ros ros 9 8月 12 18:15 ./ROS.log -rw-rw-r-- 1 ros ros 4 8月 12 17:01 ./test1/ROS1.log -rw-rw-rw- 1 ros ros 4 8月 12 17:03 ./test/ROS1.log 2.7.4 思考题 下列代码表示什么作用？ ls *.log | xargs -n1 -I {} cp {} /data/images find . -type f -name \"*.log\" -print | xargs -0 rm -f 备注：xargs -0 表示将 \\0 作为定界符 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter2-3.html":{"url":"Markdown/Ubuntu/chapter2-3.html","title":"2.3 其他常用命令","keywords":"","body":"3 Linux命令基础：其他常用命令 3.1 wc命令 wc 命令是 word count 的缩写 wc 命令是一个统计的工具，主要用来显示文件所包含的行、字和字节数 如果没有指定文件，或者文件为\"-\"，则从标准输入读取数据 3.1.1 命令格式 wc [选项] [文件] 3.1.2 常用参数 参数 描述 -c 统计字节数 -l 统计行数 -m 统计字符数，这个标志不能与 -c 标志一起使用 -w 统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串 -L 打印最长行的长度 3.1.3 常用范例 例一：统计文件的字节数、行数和字符数，可以使用如下命令： wc -c c.txt wc -l c.txt wc -m c.txt 运行结果如下： ros@ros-course:~/ROS_Course$ cat ROS5.txt It is a test ros@ros-course:~/ROS_Course$ wc -c ROS5.txt 13 ROS5.txt ros@ros-course:~/ROS_Course$ wc -l ROS5.txt 1 ROS5.txt ros@ros-course:~/ROS_Course$ wc -m ROS5.txt 13 ROS5.txt 注意，每行结尾的换行符也算一个字符，空格也算一个字符。另外，若系统采用 UTF-8 编码，一个汉字为 3 字节 例二：统计文件的字节数、行数和字符数，只打印数字，不打印文件名，可以使用如下命令： cat ROS5.txt | wc -c 运行结果如下： ros@ros-course:~/ROS_Course$ cat ROS5.txt | wc -c 13 例三：统计/bin目录下的命令个数，可以使用如下命令： ls /bin | wc -l 运行结果如下： ros@ros-course:~/ROS_Course$ ls /bin | wc -l 162 3.1.4 思考题 思考下列代码的作用是什么？ find . -type f -name \"*.log\" | xargs wc -l 3.2 grep命令 grep 命令用于查找文件里符合条件的字符串 grep 可接受正则表达式和通配符，可用多个 grep 命令选项来生成不同格式的输出 grep 通过返回一个状态值来说明搜索的状态，如果字符串搜索成功，则返回 0，如果搜索不成功，则返回 1，如果搜索的文件不存在，则返回 2 grep 会把含有所搜索字符串的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据 3.2.1 命令格式 grep [选项] 搜索字符串 [文件] 3.2.2 常用参数 参数 描述 -c 计算找到‘搜寻字符串’（即 pattern）的次数 -i 忽略大小写的不同 -n 输出行号 -v 反向选择，打印不匹配的行 -r 递归搜索 --color=auto 将找到的关键词部分加上颜色显示 3.2.3 常用范例 例一：将/etc/passwd文件中出现 root 的行取出来，关键词部分加上颜色显示，可以使用如下命令： grep \"root\" /etc/passwd --color=auto cat /etc/passwd | grep \"root\" --color=auto 运行结果如下： ros@ros-course:~/ROS_Course$ grep \"root\" /etc/passwd --color=auto root:x:0:0:root:/root:/bin/bash ros@ros-course:~/ROS_Course$ cat /etc/passwd | grep \"root\" --color=auto root:x:0:0:root:/root:/bin/bash 例二：将/etc/passwd文件中没有出现 root 和 nologin 的行取出来，可以使用如下命令： grep -v \"root\" /etc/passwd | grep -v \"nologin\" 运行结果如下： ros@ros-course:~/ROS_Course$ grep -v \"root\" /etc/passwd | grep -v \"nologin\" sync:x:4:65534:sync:/bin:/bin/sync speech-dispatcher:x:111:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/false whoopsie:x:112:117::/nonexistent:/bin/false hplip:x:118:7:HPLIP system user,,,:/var/run/hplip:/bin/false gnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/false gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false ros:x:1000:1000:ROS,,,:/home/ros:/bin/bash 例三：查找/etc/acpi 及其子目录下所有文件中包含字符串\"update\"的文件，并打印出该字符串所在行，以及行的内容，可以使用如下命令： grep -rn \"update\" /etc/acpi 运行结果如下： ros@ros-course:~/ROS_Course$ grep -rn \"update\" /etc/acpi /etc/acpi/events/thinkpad-cmos:7:action=/usr/sbin/thinkpad-keys --update 备注：“update”的双引号，可以使用单引号，也可以省略 3.2.4 补充内容：正则表达式 正则表达式是一种符号表示法，被用来识别文本模式 在某种程度上，它们与匹配文件和路径名的 shell 通配符比较相似，但其规模更大 许多命令行工具和大多数的编程语言都支持正则表达式，以此来帮助解决文本操作问题 正则表达式元字符由以下字符组成： ^ $ . [ ] { } - ? * + ( ) | \\ 常用范例 例一：利用 Linux 系统自带的字典查找一个五个字母的单词，第三个字母为 j,最后一个字母为 r，/usr/share/dict目录下存放字典文件（若没有可手动建立），可以使用如下命令： grep -E '^..j.r$' /usr/share/dict/words 运行结果如下： ros@ros-course:/etc/acpi/events$ grep '^..j.r$' /usr/share/dict/words Major major 例二：验证固定电话，打印符合条件的电话，固定电话格式基本都是带有 0 的区号+连接符“-”+电话号码，另外还有可能有分机号，区号有 3 位、4 位，电话号码有 7 位和 8 位的，可以使用如下命令： grep -E \"^0[0-9]{2,3}-[0-9]{7,8}(-[0-9]{3,4})?$\" telphone.txt 区号：前面一个 0，后面跟 2-3 位数字 0[0-9]{2,3} 电话号码：7-8 位数字 [0-9]{7,8} 分机号：一般都是 3-4 位数字 [0-9]{3,4} 运行结果如下： ros@ros-course:~/ROS_Course$ cat telephone.txt 010-3298643-0983 0953-3026840 0493-7392097-987 0726-38762-0973 ros@ros-course:~/ROS_Course$ grep -E \"^0[0-9]{2,3}-[0-9]{7,8}(-[0-9]{3,4})?$\" telephone.txt 010-3298643-0983 0953-3026840 0493-7392097-987 3.3 cut命令 cut 命令是一个将文本按列进行切分的工具，它可以指定分隔每列的定界符 如果一行数据包含多个字段（多列），想要提取其中的一列或多列，可使用 cut 命令 3.3.1 命令格式 cut [选项] [文件名] 3.3.2 常用参数 参数 描述 -b 以字节为单位进行分割 -c 以字符为单位进行分割 -d 自定义分隔符，默认为制表符 -f 自定义字段 --complement 抽取整个文本行，除了那些由 -c 或 -f 选项指定的文本 3.3.3 常用范例 例一：取出student.txt文件中的第一列和第三列，可以使用如下命令： cut -f 1,3 -d ' ' student.txt 运行结果如下： ros@ros-course:~/ROS_Course$ cat students.txt no name score 1 a 88 2 b 86 3 c 97 4 d 85 5 e 90 ros@ros-course:~/ROS_Course$ cut -f 1,3 -d ' ' students.txt no score 1 88 2 86 3 97 4 85 5 90 例二：取出student.txt文件中的前三列，可以使用如下命令： cut -f 1-3 -d ' ' student.txt 运行结果如下： ros@ros-course:~/ROS_Course$ cut -f 1-3 -d ' ' students.txt no name score 1 a 88 2 b 86 3 c 97 4 d 85 5 e 90 例三：取出student.txt文件中除第一列的其他列，可以使用如下命令： cut -f 1 -d ' ' student.txt --complement 运行结果如下： ros@ros-course:~/ROS_Course$ cut -f 1 -d ' ' students.txt --complement name score a 88 b 86 c 97 d 85 e 90 例四：给任意一字符串 str，取出其最后一个字符，可以使用如下命令： num=$(echo -n $str | wc -c) echo -n $str | cut -b $num #或者可以使用下面这段代码 echo -n $str | cut -b `echo -n $str | wc -c` 3.4 paste命令 paste 命令的功能与 cut 相反。它会添加一个或多个文本列到文件中 paste 命令读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出 3.4.1 命令格式 paste [选项] [文件名] 3.4.2 常用参数 参数 描述 -s 将每个文件合并成行而不是按行粘贴 -d 自定义分隔符，默认为制表符 3.4.3 常用范例 例一：将students.txt和telephone.txt文件中的内容按列拼接，可以使用如下命令： paste students.txt telephone.txt 运行结果如下： ros@ros-course:~/ROS_Course$ paste students.txt telephone.txt no name score 010-3298643-0983 1 a 88 0953-3026840 2 b 86 0493-7392097-987 3 c 97 0726-38762-0973 4 d 85 5 e 90 例二：将students.txt和telephone.txt文件中的内容按列拼接，指定分隔符为:，可以使用如下命令： paste students.txt telephone.txt -d ':' 运行结果如下： ros@ros-course:~/ROS_Course$ paste students.txt telephone.txt -d ':' no name score:010-3298643-0983 1 a 88:0953-3026840 2 b 86:0493-7392097-987 3 c 97:0726-38762-0973 4 d 85: 5 e 90: 例三：将students.txt和telephone.txt文件中的内容各自拼接成一行，可以使用如下命令： paste -s students.txt telephone.txt 运行结果如下： ros@ros-course:~/ROS_Course$ paste -s students.txt telephone.txt no name score 1 a 88 2 b 86 3 c 97 4 d 85 5 e 90 010-3298643-0983 0953-3026840 0493-7392097-987 0726-38762-0973 3.5 tr命令 tr 是 translate 的缩写 tr 命令被用来更改字符，可以看作是一种基于字符的查找和替换操作 tr 只能通过 stdin（标准输入），而无法通过命令行参数来接受输入 3.5.1 命令格式 tr [选项] SET1 SET2 备注：将来自 stdin 的输入字符从 SET1 映射到 SET2，并将其输出写入 stdout（标准输出）。SET1 和 SET2 是字符类或字符集。如果两个字符集的长度不相等，那么 SET2 会不断重复其最后一个字符，直到长度与 SET1 相同。如果 SET2 的长度大于 SET1，那么在 SET2 中超出 SET1 的那部分字符则全部被忽略 3.5.2 常用参数 参数 描述 -d 删除SET1中匹配的内容，并不作替换 3.5.3 常用范例 例一：将输入的字符大写转换为小写，可以使用如下命令： echo 'THIS IS ROS!' | tr 'A-Z' 'a-z' 运行结果如下： ros@ros-course:~/ROS_Course$ echo 'THIS IS ROS!' | tr 'A-Z' 'a-z' this is ros! 例二：将输入的字符中的数字删除，可以使用如下命令： echo 'THIS 123 IS ROS!' | tr -d '0-9' 运行结果如下： ros@ros-course:~/ROS_Course$ echo 'THIS 123 IS ROS!' | tr -d '0-9' THIS IS ROS! 例三：tr 命令的一个有趣的用法是执行 ROT13 文本编码。ROT13 是一款微不足道的基于一种简易的替换暗码的加密类型。把 ROT13 称为“加密”是不严格的，“文本模糊处理”更准确些。有时候它被用来隐藏文本中潜在的攻击内容。这个方法就是简单地把每个字符在字母表中向前移动 13 位。因为移动的位数是所有 26 个字母的一半，所以对文本再次执行这个算法，就恢复到了它最初的形式。可以使用如下命令： #加密 echo 'ROS Course' | tr 'a-zA-Z' 'n-za-mN-ZA-M' 得到结果：EBF Pbhefr #解密 echo 'EBF Pbhefr' | tr 'a-zA-Z' 'n-za-mN-ZA-M' 得到结果 ROS Course 3.6 sort命令 sort 命令能够帮助我们对文本文件和 stdin 进行排序操作 通常，sort会结合其他命令来生成所需要的输出 3.6.1 命令格式 sort [选项] [文件名] 3.6.2 常用参数 参数 描述 -n 基于字符串的长度来排序，使用此选项允许根据数字值排序，而不是字母值 -k 指定排序关键字 -b 默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项使得sort 程序忽略每行开头的空格，从第一个非空白字符开始排序 -m 只合并多个输入文件 -r 按相反顺序排序，结果按照降序排列 -t 自定义分隔符，默认为制表符 3.6.3 常用范例 例一：列出/usr/share/目录下使用空间最多的前 10 个目录文件，可以使用如下命令： du -s /usr/share/* | sort -nr | head -10 备注：du -s /usr/share/*命令显示/usr/share/目录下所有文件和目录的磁盘使用空间，目录包含目录下的子目录和文件 运行结果如下： ros@ros-course:~/ROS_Course$ du -s /usr/share/* | sort -nr | head -10 423928 /usr/share/fonts 224600 /usr/share/typora 175716 /usr/share/doc 80744 /usr/share/icons 76292 /usr/share/gazebo-9 59544 /usr/share/locale 40940 /usr/share/ibus 38700 /usr/share/man 37360 /usr/share/backgrounds 35460 /usr/share/help 例二：对 ls 命令输出信息中的空间使用大小字段进行排序，可以使用如下命令： ls -l /usr/bin/ | sort -nr -k 5 | head -10 运行结果如下： ros@ros-course:~/ROS_Course$ ls -l /usr/bin/ | sort -nr -k 5 | head -10 -rwxr-xr-x 1 root root 51859776 1月 26 2018 pandoc -rwxr-xr-x 1 root root 19610632 3月 26 23:49 snap -rwxr-xr-x 1 root root 8612088 5月 28 2018 gzclient-9.0.0 -rwxr-xr-x 1 root root 7619056 10月 30 2020 gdb -rwxr-xr-x 1 root root 6518192 4月 4 22:10 ctest -rwxr-xr-x 1 root root 5893648 6月 24 2019 ubuntu-report -rwxr-xr-x 1 root root 5566864 4月 4 22:10 cpack -rwxr-xr-x 1 root root 5325648 4月 4 22:10 cmake -rwxr-xr-x 1 root root 4992936 4月 30 2020 shotwell -rwxr-xr-x 1 root root 4551912 1月 13 2020 gnome-control-center 3.7 uniq 命令 uniq 命令是 unique 的缩写 uniq 命令经常和 sort 命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除重复出现的行列 uniq 只能用于排过序的数据输入，因此，uniq 要么使用管道，要么将排过序的文件作为输入，总是以这种方式与 sort 命令结合起来使用 3.7.1 命令格式 uniq [选项] [文件名] 3.7.2 常用参数 参数 描述 -c 在每行前加上表示相应行目出现次数的前缀编号 -d 只输出重复的行 -u 只显示唯一的行 -D 显示所有重复的行 -f 比较时跳过前 n 列 -i 在比较的时候不区分大小写 -s 比较时跳过前 n 个字符 -w 对每行第 n 个字符以后的内容不作对照 3.7.3 常用范例 例一：找出/bin目录和/usr/bin目录下所有相同的命令，可以使用如下命令： ls /bin /usr/bin | sort | uniq -d 运行结果如下： ros@ros-course:~/ROS_Course$ ls /bin /usr/bin | sort | uniq -d chacl dumpkeys getfacl less lessecho lessfile lesskey lesspipe loadkeys setfacl touch which 例二：现有student1.txt文件内容如下，其中第四列第一个字符表示区号，现在要统计出各个区号的总人数 ros@ros-course:~/ROS_Course$ cat student1.txt li 100 89 1-34-56 sun 200 90 2-34-56 wan 321 88 2-34-51 qun 234 92 1-34-56 zhao 452 93 1-23-89 实现思路：首先按区号对每行信息排序，然后使用 uniq 命令对区号进行重复行统计。使用命令如下： sort -k 4.1n student1.txt | uniq -c -f 3 -w 2 运行结果如下： ros@ros-course:~/ROS_Course$ sort -k 4.1n student1.txt | uniq -c -f 3 -w 2 3 li 100 89 1-34-56 2 sun 200 90 2-34-56 运行结果说明： sort -k 4.1n表示对第四个字段的第一个字符按数值排序 uniq -c -f 3 -w 2中 -f 3 表示跳过前三列的比较，那么现在只剩下最后一列，-w 2 表示第 2 个字符后的内容不做比较，为什么是 2 呢，因为跳过前三列时并没有跳过最后一列前面的空格分隔符，区号前都还有一个空格 3.8 join命令 join 命令类似于 paste，它会往文件中添加列 join 命令跟 uniq 命令一样，只能用于排过序的数据 join 命令将两个文件中指定栏位相同的行连接起来 3.8.1 命令格式 join [选项] 文件 1 文件 2 3.8.2 常用参数 参数 描述 -j FIELD 等同于 -1 FIELD -2 FIELD，-j 指定一个域作为匹配字段 -1 FIELD 以 file1 中 FIELD 字段进行匹配 -2 FIELD 以 file2 中 FIELD 字段进行匹配 -t 自定义分隔符，默认为制表符 3.8.3 常用范例 例一：指定两个文件的第三个字段为匹配字段，连接两个文件，可以使用如下命令： join -1 3 -2 3 student1.txt student2.txt 运行结果如下： ros@ros-course:~/ROS_Course$ cat student1.txt wan 321 89 2-34-51 li 100 90 1-34-56 sun 200 91 2-34-56 qun 234 92 1-34-56 zhao 452 93 1-23-89 ros@ros-course:~/ROS_Course$ cat student2.txt zhao 252 89 2-73-69 qun 278 90 3-33-46 wan 322 91 7-31-91 ros@ros-course:~/ROS_Course$ join -1 3 -2 3 student1.txt student2.txt 89 wan 321 2-34-51 zhao 252 2-73-69 90 li 100 1-34-56 qun 278 3-33-46 91 sun 200 2-34-56 wan 322 7-31-91 备注：应用join前要对student1.txt 和 student2.txt 进行排序 3.9 comm命令 comm 命令用于逐行比较已经排序的两个文件 显示结果包括 3 列：第 1 列为只在第一个文件中找到的行，第 2 列为只在第二个文件中找到的行，第 3 列为两个文件的共有行 comm 命令和 join、uniq 命令一样，只能用于已经排过序的数据。 3.9.1 命令格式 comm [选项] 文件 1 文件 2 3.9.2 常用参数 参数 描述 -1 不输出文件 1 特有的行 -2 不输出文件 2 特有的行 -3 不输出两个文件共有的行 3.9.4 常用范例 例一：比较student3.txt和student4.txt两个文件的内容，可以使用如下命令： comm student3.txt student4.txt 运行结果如下： ros@ros-course:~/ROS_Course$ cat student3.txt li 100 90 1-34-56 qun 234 92 1-34-56 sun 200 91 2-34-56 zhao 252 89 2-73-69 zhao 452 93 1-23-89 ros@ros-course:~/ROS_Course$ sort student4.txt qun 234 92 1-34-56 qun 278 90 3-33-46 zhao 252 89 2-73-69 ros@ros-course:~/ROS_Course$ comm student3.txt student4.txt li 100 90 1-34-56 qun 234 92 1-34-56 qun 278 90 3-33-46 sun 200 91 2-34-56 zhao 252 89 2-73-69 zhao 452 93 1-23-89 例二：比较student3.txt和student4.txt两个文件的内容，只显示两个文件共有的内容，可以使用如下命令： comm -12 student3.txt student4.txt 运行结果如下： ros@ros-course:~/ROS_Course$ comm -12 student3.txt student4.txt qun 234 92 1-34-56 zhao 252 89 2-73-69 3.10 diff命令 diff 命令是 differential 的缩写 类似 comm 命令，diff 命令被用来检测文件之间的差异 diff命令一次能处理许多文本文件。软件开发员经常使用 diff 程序来检查不同程序源码版本之间的更改，diff 能够递归地检查源码目录，通常称之为源码树 diff 在命令行中打印每一行的改动，并且 diff 是 svn、cvs、git 等版本控制工具不可或缺的一部分 3.10.1 命令格式 diff [选项] 文件 3.10.2 常用参数 参数 描述 -c 上下文模式，显示全部内文，并标出不同之处 -u 统一模式，以合并的方式来显示文件内容的不同 -a 只会逐行比较文本文件 -N 在比较目录时，若文件 A 仅出现在某个目录中，预设会显示：Only in 目录。若使用 -N 参数，则 diff 会将文件 A 与一个空白的文件比较 -r 递归比较目录下的文件 3.10.3 常用范例 例一：显示student3.txt和student4.txt两个文件的差异，可以使用如下命令： diff file1.txt file2.txt 运行结果如下： ros@ros-course:~/ROS_Course$ cat student3.txt li 100 90 1-34-56 qun 234 92 1-34-56 sun 200 91 2-34-56 zhao 252 89 2-73-69 zhao 452 93 1-23-89 ros@ros-course:~/ROS_Course$ cat student4.txt qun 234 92 1-34-56 qun 278 90 3-33-46 zhao 252 89 2-73-69 ros@ros-course:~/ROS_Course$ diff student3.txt student4.txt 1d0 qun 278 90 3-33-46 5d3 运行结果说明： 上面结果显示中的“1d0”表示student3.txt文件比studengt4.txt文件多了第一行 “3c2”表示student3.txt文件的第三行和student4.txt文件的第二行不同 例二：从上面例一的显示结果可以知道，student3.txt和student4.txt两个文件的差异不易直观看出，这时可以使用上下文模式显示，可以使用如下命令： diff -c student3.txt student4.txt 运行结果如下： *** student3.txt 2021-08-14 15:12:11.352661281 +0800 --- student4.txt 2021-08-14 15:12:25.683063156 +0800 *************** *** 1,5 **** - li 100 90 1-34-56 qun 234 92 1-34-56 ! sun 200 91 2-34-56 zhao 252 89 2-73-69 - zhao 452 93 1-23-89 --- 1,3 ---- qun 234 92 1-34-56 ! qun 278 90 3-33-46 zhao 252 89 2-73-69 运行结果说明： 这个输出结果以两个文件名和它们的时间戳开头 第一个文件用星号做标记，第二个文件用短横线做标记 *** 1,5 *** 表示第一个文件中第一行到第五行的文本行 --- 1,3 --- 表示第二个文件中第一行到第三行的文本行 三种特殊字符： + 添加行，这一行将会出现在第二个文件内，而不是第一个文件内 - 删除行，这一行将会出现在第一个文件中，而不是第二个文件内 ! 更改行，将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分 这些特殊字符很容易混淆，实际上记住一点就：所有操作目的是将第一个文件变成第二个文件 3.11 patch命令 patch 命令被用来把更改应用到文本文件中。它接受从 diff 程序的输出，并且通常被用来把较老的文件版本转变为较新的文件版本 使用 diff/patch 组合提供了两个重大优点： 与整个源码树的大小相比较而言，一个 diff 文件非常小 一个 diff 文件简洁地显示所做的修改，从而允许程序补丁的审阅者能快速地评估它 GNU 文档建议这样使用 diff/patch 命令： diff -Naur old_file new_file > diff_file old file 和 new file 部分不是单个文件就是包含文件的目录， r 选项支持递归目录树 3.11.1 命令格式 patch [选项] 补丁文件 3.11.2 常用参数 参数 描述 -p num 忽略几层文件夹 -E 如果发现了空文件，就删除它 -R 取消打过的补丁 3.11.3 常用范例 例一：生成student3.txt和student4.txt的 diff 文件，然后应用 patch 命令更新file1.txt文件，可以使用如下命令： diff -Naur file1.txt file2.txt > patchdiff.txt patch 运行结果如下： ros@ros-course:~/ROS_Course$ diff -Naur student3.txt student4.txt > patchdiff.txt ros@ros-course:~/ROS_Course$ cat patchdiff.txt --- student3.txt 2021-08-14 15:12:11.352661281 +0800 +++ student4.txt 2021-08-14 15:12:25.683063156 +0800 @@ -1,5 +1,3 @@ -li 100 90 1-34-56 qun 234 92 1-34-56 -sun 200 91 2-34-56 +qun 278 90 3-33-46 zhao 252 89 2-73-69 -zhao 452 93 1-23-89 3.12 df命令 df 命令是 disk free 的缩写 df 命令用来检查 linux 服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息 3.12.1 命令格式 df [选项] 文件 3.12.2 常用参数 参数 描述 -a 全部文件系统列表 -h 方便阅读方式显示 -i 显示 inode 信息 -T 文件系统类型 -t 只显示选定文件系统的磁盘信息 -x 不显示选定文件系统的磁盘信息 3.12.3 常用范例 例一：显示磁盘使用情况，可以使用如下命令： df 例二：以 inode 模式来显示磁盘使用情况，可以使用如下命令： df -i 例三：列出文件系统的类型，可以使用如下命令： df -T 例四：显示指定类型磁盘，可以使用如下命令： df -t ext4 3.13 du命令 du 命令是 disk usage 的缩写 du 命令也是查看使用空间的，但是与 df 命令不同的是 du 命令是对文件和目录磁盘使用的空间的查看 3.13.1 命令格式 du [选项] 文件 3.13.2 常用参数 参数 描述 -a 显示目录中所有文件的大小。 -b 显示目录或文件大小时，以 byte 为单位。 -c 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 -k 以 KB(1024bytes)为单位输出。 -m 以 MB 为单位输出。 -s 仅显示总计，只列出最后加总的值。 -h 以 K，M，G 为单位，提高信息的可读性。 3.13.3 常用范例 例一：显示指定文件所占空间，以方便阅读的格式显示，可以使用如下命令： du -h file1.txt 运行结果如下： ros@ros-course:~/ROS_Course$ du -h student3.txt 4.0K student3.txt 例二：显示指定目录所占空间，以方便阅读的格式显示，可以使用如下命令： du -h ~/ROS_Course 运行结果如下： ros@ros-course:~/ROS_Course$ du -h ~/ROS_Course 8.0K /home/ros/ROS_Course/test1 8.0K /home/ros/ROS_Course/test 104K /home/ros/ROS_Course 例三：按照空间大小逆序排序显示，使用如下命令： du -h | sort -nr | head -10 运行结果如下： ros@ros-course:~/ROS_Course$ du -h | sort -nr | head -10 104K . 8.0K ./test1 8.0K ./test 3.14 time命令 time 命令常用于测量一个命令的运行时间，包括实际使用时间（real time）、用户态使用时间（the process spent in user mode）、内核态使用时间（the process spent in kernel mode） 实际时间: 从 command 命令行开始执行到运行终止的时间 用户态使用时间：命令执行完成花费的用户 CPU 时间，即命令在用户态中执行时间总和 内核态使用时间：命令执行完成花费的系统 CPU 时间，即命令在核心态中执行时间总和 3.14.1 命令格式 time 命令 3.14.2 常用范例 例一：测量 date 命令运行的时间，可以使用如下命令： time date 运行结果如下： ros@ros-course:~/ROS_Course$ time date 2021年 08月 14日 星期六 16:08:08 CST real 0m0.002s user 0m0.000s sys 0m0.001s 从上面的结果可以到：实际运行时间为 0.002s，用户 cpu 时间为 0.000s，系统 cpu 时间为 0.001s 其中，用户 CPU 时间和系统 CPU 时间之和为 CPU 时间，即命令占用 CPU 执行的时间总和 实际时间要大于 CPU 时间，因为 Linux 是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/ROS1/chapter1.html":{"url":"Markdown/ROS1/chapter1.html","title":"1 讲义","keywords":"","body":"1 讲义 1 此部分为《机器人操作系统》课程 ROS 讲义 2 讲义参考赵虚左老师资料：赵虚左讲义new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/ROS1/chapter1-1.html":{"url":"Markdown/ROS1/chapter1-1.html","title":"1.1 ROS基础知识","keywords":"","body":"1 ROS讲义 第1章 ROS概述与环境搭建 1.1 ROS简介 1.1.1 ROS概念 ROS全称Robot Operating System(机器人操作系统) ROS是适用于机器人的开源元操作系统 ROS集成了大量的工具，库，协议，提供类似OS所提供的功能，简化对机器人的控制 还提供了用于在多台计算机上获取，构建，编写和运行代码的工具和库，ROS在某些方面类似于“机器人框架” ROS设计者将ROS表述为“ROS = Plumbing + Tools + Capabilities + Ecosystem”，即ROS是通讯机制、工具软件包、机器人高层技能以及机器人生态系统的集合体 1.1.2 ROS设计目标 机器人开发的分工思想，实现了不同研发团队间的共享和协作，提升了机器人的研发效率，为了服务“ 分工”，ROS主要设计了如下目标： 代码复用:ROS的目标不是成为具有最多功能的框架，ROS的主要目标是支持机器人技术研发中的代码重用。 分布式:ROS是进程（也称为Nodes）的分布式框架,ROS中的进程可分布于不同主机，不同主机协同工作，从而分散计算压力 松耦合:ROS中功能模块封装于独立的功能包或元功能包，便于分享，功能包内的模块以节点为单位运行，以ROS标准的IO作为接口，开发者不需要关注模块内部实现，只要了解接口规则就能实现复用,实现了模块间点对点的松耦合连接 精简：ROS被设计为尽可能精简，以便为ROS编写的代码可以与其他机器人软件框架一起使用。ROS易于与其他机器人软件框架集成：ROS已与OpenRAVE，Orocos和Player集成。 语言独立性：包括Java，C++，Python等。为了支持更多应用开发和移植，ROS设计为一种语言弱相关的框架结构，使用简洁，中立的定义语言描述模块间的消息接口，在编译中再产生所使用语言的目标文件，为消息交互提供支持，同时允许消息接口的嵌套使用。 易于测试：ROS具有称为rostest的内置单元/集成测试框架，可轻松安装和拆卸测试工具。 大型应用：ROS适用于大型运行时系统和大型开发流程。 丰富的组件化工具包：ROS可采用组件化方式集成一些工具和软件到系统中并作为一个组件直接使用，如RVIZ（3D可视化工具），开发者根据ROS定义的接口在其中显示机器人模型等，组件还包括仿真环境和消息查看工具等 免费且开源：开发者众多，功能包多 1.1.3 ROS发展历程 ROS是一个由来已久、贡献者众多的大型软件项目。在ROS诞生之前，很多学者认为，机器人研究需要一个开放式的协作框架，并且已经有不少类似的项目致力于实现这样的框架。在这些工作中，斯坦福大学在2000年年中开展了一系列相关研究项目，如斯坦福人工智能机器人（STandford AI Robot, STAIR）项目、个人机器人（Personal Robots, PR）项目等，在上述项目中，在研究具有代表性、集成式人工智能系统的过程中，创立了用于室内场景的高灵活性、动态软件系统，其可以用于机器人学研究。 2007年，柳树车库（Willow Garage）提供了大量资源，用于将斯坦福大学机器人项目中的软件系统进行扩展与完善，同时，在无数研究人员的共同努力下，ROS的核心思想和基本软件包逐渐得到完善。 ROS的发行版本（ROS distribution）指ROS软件包的版本，其与Linux的发行版本（如Ubuntu）的概念类似。推出ROS发行版本的目的在于使开发人员可以使用相对稳定的代码库，直到其准备好将所有内容进行版本升级为止。因此，每个发行版本推出后，ROS开发者通常仅对这一版本的bug进行修复，同时提供少量针对核心软件包的改进。 版本特点: 按照英文字母顺序命名，ROS 目前已经发布了ROS1 的终极版本: noetic，并建议后期过渡至 ROS2 版本。noetic 版本之前默认使用的是 Python2，noetic 支持 Python3。 1.2 ROS安装 1.2.1 安装ROS ROS Noetic安装教程见《1.2 Ubuntu安装之后要做的事》 1.2.2 测试ROS ROS 内置了一些小程序，可以通过运行这些小程序以检测 ROS 环境是否可以正常运行 首先启动三个命令行(ctrl + alt + T) 命令行1键入:roscore 命令行2键入:rosrun turtlesim turtlesim_node(此时会弹出图形化界面) 命令行3键入:rosrun turtlesim turtle_teleop_key(在3中可以通过上下左右控制2中乌龟的运动) 最终结果如下所示: 1.3 ROS快速体验 1.3.1 HelloWorld实现简介 以HelloWorld程序为例，实现流程大致如下： 先创建一个工作空间； 再创建一个功能包； 编辑源文件； 编辑配置文件； 编译并执行。 1.创建工作空间并初始化 mkdir -p 自定义空间名称/src cd 自定义空间名称 catkin_make 上述命令，首先会创建一个工作空间以及一个 src 子目录，然后再进入工作空间调用 catkin_make 命令编译。 2.进入 src 创建 ros 包并添加依赖 cd src catkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs 上述命令，会在工作空间下生成一个功能包，该功能包依赖于 roscpp、rospy 与 std_msgs，其中 roscpp 是使用 C++ 实现的库，而 rospy 则是使用 python实现的库，std_msgs 是标准消息库，创建ROS功能包时，一般都会依赖这三个库实现。 1.3.2 HelloWorld实现 1.在demo01_ws/src/helloworld目录下 添加 scripts 目录并编辑 python 文件 cd ros包 mkdir scripts 新建 python 文件: helloworld_p.py #! /usr/bin/env python #step.0 指定解释器 #1.导包 import rospy #2.编写主入口 if __name__ == \"__main__\": #3.初始化ros节点 rospy.init_node(\"hello_p\"); #4.输出日志 rospy.loginfo(\"hello world! by python\"); 2.为 python 文件添加可执行权限 chmod +x helloworld_p.py 3.编辑 ros 包下的 CamkeList.txt 文件 catkin_install_python(PROGRAMS scripts/自定义文件名.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) 4.进入工作空间目录并编译 cd demo01_ws catkin_make 5.进入工作空间目录并执行 先启动命令行1： roscore 再启动命令行2： cd demo01_ws source ./devel/setup.bash rosrun 包名 自定义文件名.py 最终结果: 1.4 ROS集成开发环境搭建 1.4.1 安装终端 在 ROS 中，需要频繁的使用到终端，且可能需要同时开启多个窗口，推荐一款较为好用的终端:Terminator。 1.安装 sudo apt install terminator 2.添加到收藏夹 显示应用程序 ---> 搜索 terminator ---> 右击 选择 添加到收藏夹 3.Terminator 常用快捷键 第一部份：关于在同一个标签内的操作 Alt+Up //移动到上面的终端 Alt+Down //移动到下面的终端 Alt+Left //移动到左边的终端 Alt+Right //移动到右边的终端 Ctrl+Shift+O //水平分割终端 Ctrl+Shift+E //垂直分割终端 Ctrl+Shift+Right //在垂直分割的终端中将分割条向右移动 Ctrl+Shift+Left //在垂直分割的终端中将分割条向左移动 Ctrl+Shift+Up //在水平分割的终端中将分割条向上移动 Ctrl+Shift+Down //在水平分割的终端中将分割条向下移动 Ctrl+Shift+S //隐藏/显示滚动条 Ctrl+Shift+F //搜索 Ctrl+Shift+C //复制选中的内容到剪贴板 Ctrl+Shift+V //粘贴剪贴板的内容到此处 Ctrl+Shift+W //关闭当前终端 Ctrl+Shift+Q //退出当前窗口，当前窗口的所有终端都将被关闭 Ctrl+Shift+X //最大化显示当前终端 Ctrl+Shift+Z //最大化显示当前终端并使字体放大 Ctrl+Shift+N or Ctrl+Tab //移动到下一个终端 Ctrl+Shift+P or Ctrl+Shift+Tab //Crtl+Shift+Tab 移动到之前的一个终端 第二部份：有关各个标签之间的操作 F11 //全屏开关 Ctrl+Shift+T //打开一个新的标签 Ctrl+PageDown //移动到下一个标签 Ctrl+PageUp //移动到上一个标签 Ctrl+Shift+PageDown //将当前标签与其后一个标签交换位置 Ctrl+Shift+PageUp //将当前标签与其前一个标签交换位置 Ctrl+Plus (+) //增大字体 Ctrl+Minus (-) //减小字体 Ctrl+Zero (0) //恢复字体到原始大小 Ctrl+Shift+R //重置终端状态 Ctrl+Shift+G //重置终端状态并clear屏幕 Super+g //绑定所有的终端，以便向一个输入能够输入到所有的终端 Super+Shift+G //解除绑定 Super+t //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端 Super+Shift+T //解除绑定 Ctrl+Shift+I //打开一个窗口，新窗口与原来的窗口使用同一个进程 Super+i //打开一个新窗口，新窗口与原来的窗口使用不同的进程 1.4.2 安装VScode VSCode 全称 Visual Studio Code，是微软出的一款轻量级代码编辑器，免费、开源而且功能强大。它支持几乎所有主流的程序语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux。 1.下载 vscode 下载:https://code.visualstudio.com/docs?start=true 历史版本下载链接: https://code.visualstudio.com/updates 2.vscode 安装与卸载 2.1 安装 方式1:双击安装即可(或右击选择安装) 方式2:sudo dpkg -i xxxx.deb 2.2 卸载 sudo dpkg --purge code 3.vscode 集成 ROS 插件 使用 VScode 开发 ROS 程序，需要先安装一些插件 4.vscode 使用_基本配置 4.1 创建 ROS 工作空间 mkdir -p xxx_ws/src(必须得有 src) cd xxx_ws catkin_make 4.2 启动 vscode 进入 xxx_ws 启动 vscode cd xxx_ws code . 4.3 vscode 中编译 ros 快捷键 ctrl + shift + B 调用编译，选择:catkin_make:build 可以点击配置设置为默认，修改.vscode/tasks.json 文件 { // 有关 tasks.json 格式的文档，请参见 // https://go.microsoft.com/fwlink/?LinkId=733558 \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"catkin_make:debug\", //代表提示的描述性信息 \"type\": \"shell\", //可以选择shell或者process,如果是shell代码是在shell里面运行一个命令，如果是process代表作为一个进程来运行 \"command\": \"catkin_make\",//这个是我们需要运行的命令 \"args\": [],//如果需要在命令后面加一些后缀，可以写在这里，比如-DCATKIN_WHITELIST_PACKAGES=“pac1;pac2” \"group\": {\"kind\":\"build\",\"isDefault\":true}, \"presentation\": { \"reveal\": \"always\"//可选always或者silence，代表是否输出信息 }, \"problemMatcher\": \"$msCompile\" } ] } 4.4 创建 ROS 功能包 选定 src 右击 ---> create catkin package 设置包名 添加依赖 4.5 python 实现 在 功能包 下新建 scripts 文件夹，添加 python 文件，并添加可执行权限 #! /usr/bin/env python \"\"\" Python 版本的 HelloVScode，执行在控制台输出 HelloVScode 实现: 1.导包 2.初始化 ROS 节点 3.日志输出 HelloWorld \"\"\" import rospy # 1.导包 if __name__ == \"__main__\": rospy.init_node(\"Hello_Vscode_p\") # 2.初始化 ROS 节点 rospy.loginfo(\"Hello VScode, 我是 Python ....\") #3.日志输出 HelloWorld 4.6 配置 CMakeLists.txt Python 配置: catkin_install_python(PROGRAMS scripts/自定义文件名.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) 4.7 编译执行 编译: ctrl + shift + B 执行: 和之前一致，只是可以在 VScode 中添加终端，首先执行:source ./devel/setup.bash 1.4.3 launch文件演示 1.需求 一个程序中可能需要启动多个节点，比如:ROS 内置的小乌龟案例，如果要控制乌龟运动，要启动多个窗口，分别启动 roscore、乌龟界面节点、键盘控制节点。如果每次都调用 rosrun 逐一启动，显然效率低下，如何优化? 官方给出的优化策略是使用 launch 文件，可以一次性启动多个 ROS 节点。 2.实现 选定功能包右击 ---> 添加 launch 文件夹 选定 launch 文件夹右击 ---> 添加 launch 文件 编辑 launch 文件内容 --> 运行 launch 文件 roslaunch hello_vscode start_turtle.launch 运行结果: 一次性启动了多个节点 1.5 ROS架构 1.5.1 ROS文件系统 ROS文件系统级指的是在硬盘上ROS源代码的组织形式，其结构大致可以如下图所示： WorkSpace --- 自定义的工作空间 |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。 |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&静态链接库、可执行文件等。 |--- src: 源码 |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成 |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件 |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml) |-- scripts 存储python文件 |-- src 存储C++源文件 |-- include 头文件 |-- msg 消息通信格式文件 |-- srv 服务通信格式文件 |-- action 动作格式文件 |-- launch 可一次性运行多个节点 |-- config 配置信息 |-- CMakeLists.txt: 编译的基本配置 ROS 文件系统中部分目录和文件前面编程中已经有所涉及，比如功能包的创建、src目录下cpp文件的编写、scripts目录下python文件的编写、launch目录下launch文件的编写，并且也配置了 package.xml 与 CMakeLists.txt 文件。其他目录下的内容后面教程将会再行介绍，当前我们主要介绍: package.xml 与 CMakeLists.txt 这两个配置文件。 1.package.xml 该文件定义有关软件包的属性，例如软件包名称，版本号，作者，维护者以及对其他catkin软件包的依赖性。请注意，该概念类似于旧版 rosbuild 构建系统中使用的manifest.xml文件。 demo01_hello_vscode 0.0.0 The demo01_hello_vscode package Jane Doe --> xuzuo TODO http://wiki.ros.org/demo01_hello_vscode --> Jane Doe --> roscpp --> roscpp --> roscpp --> message_generation --> message_generation --> catkin --> message_runtime --> gtest --> doxygen --> catkin roscpp rospy std_msgs roscpp rospy std_msgs roscpp rospy std_msgs 2.CMakelists.txt 文件CMakeLists.txt是CMake构建系统的输入，用于构建软件包。任何兼容CMake的软件包都包含一个或多个CMakeLists.txt文件，这些文件描述了如何构建代码以及将代码安装到何处。 cmake_minimum_required(VERSION 3.0.2) #所需 cmake 版本 project(demo01_hello_vscode) #包名称，会被 ${PROJECT_NAME} 的方式调用 ## Compile as C++11, supported in ROS Kinetic and newer # add_compile_options(-std=c++11) ## Find catkin macros and libraries ## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz) ## is used, also find other catkin packages #设置构建所需要的软件包 find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs ) ## System dependencies are found with CMake's conventions #默认添加系统依赖 # find_package(Boost REQUIRED COMPONENTS system) ## Uncomment this if the package has a setup.py. This macro ensures ## modules and global scripts declared therein get installed ## See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html # 启动 python 模块支持 # catkin_python_setup() ################################################ ## Declare ROS messages, services and actions ## ## 声明 ROS 消息、服务、动作... ## ################################################ ## To declare and build messages, services or actions from within this ## package, follow these steps: ## * Let MSG_DEP_SET be the set of packages whose message types you use in ## your messages/services/actions (e.g. std_msgs, actionlib_msgs, ...). ## * In the file package.xml: ## * add a build_depend tag for \"message_generation\" ## * add a build_depend and a exec_depend tag for each package in MSG_DEP_SET ## * If MSG_DEP_SET isn't empty the following dependency has been pulled in ## but can be declared for certainty nonetheless: ## * add a exec_depend tag for \"message_runtime\" ## * In this file (CMakeLists.txt): ## * add \"message_generation\" and every package in MSG_DEP_SET to ## find_package(catkin REQUIRED COMPONENTS ...) ## * add \"message_runtime\" and every package in MSG_DEP_SET to ## catkin_package(CATKIN_DEPENDS ...) ## * uncomment the add_*_files sections below as needed ## and list every .msg/.srv/.action file to be processed ## * uncomment the generate_messages entry below ## * add every package in MSG_DEP_SET to generate_messages(DEPENDENCIES ...) ## Generate messages in the 'msg' folder # add_message_files( # FILES # Message1.msg # Message2.msg # ) ## Generate services in the 'srv' folder # add_service_files( # FILES # Service1.srv # Service2.srv # ) ## Generate actions in the 'action' folder # add_action_files( # FILES # Action1.action # Action2.action # ) ## Generate added messages and services with any dependencies listed here # 生成消息、服务时的依赖包 # generate_messages( # DEPENDENCIES # std_msgs # ) ################################################ ## Declare ROS dynamic reconfigure parameters ## ## 声明 ROS 动态参数配置 ## ################################################ ## To declare and build dynamic reconfigure parameters within this ## package, follow these steps: ## * In the file package.xml: ## * add a build_depend and a exec_depend tag for \"dynamic_reconfigure\" ## * In this file (CMakeLists.txt): ## * add \"dynamic_reconfigure\" to ## find_package(catkin REQUIRED COMPONENTS ...) ## * uncomment the \"generate_dynamic_reconfigure_options\" section below ## and list every .cfg file to be processed ## Generate dynamic reconfigure parameters in the 'cfg' folder # generate_dynamic_reconfigure_options( # cfg/DynReconf1.cfg # cfg/DynReconf2.cfg # ) ################################### ## catkin specific configuration ## ## catkin 特定配置## ################################### ## The catkin_package macro generates cmake config files for your package ## Declare things to be passed to dependent projects ## INCLUDE_DIRS: uncomment this if your package contains header files ## LIBRARIES: libraries you create in this project that dependent projects also need ## CATKIN_DEPENDS: catkin_packages dependent projects also need ## DEPENDS: system dependencies of this project that dependent projects also need # 运行时依赖 catkin_package( # INCLUDE_DIRS include # LIBRARIES demo01_hello_vscode # CATKIN_DEPENDS roscpp rospy std_msgs # DEPENDS system_lib ) ########### ## Build ## ########### ## Specify additional locations of header files ## Your package locations should be listed before other locations # 添加头文件路径，当前程序包的头文件路径位于其他文件路径之前 include_directories( # include ${catkin_INCLUDE_DIRS} ) ## Declare a C++ library # 声明 C++ 库 # add_library(${PROJECT_NAME} # src/${PROJECT_NAME}/demo01_hello_vscode.cpp # ) ## Add cmake target dependencies of the library ## as an example, code may need to be generated before libraries ## either from message generation or dynamic reconfigure # 添加库的 cmake 目标依赖 # add_dependencies(${PROJECT_NAME} ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) ## Declare a C++ executable ## With catkin_make all packages are built within a single CMake context ## The recommended prefix ensures that target names across packages don't collide # 声明 C++ 可执行文件 add_executable(Hello_VSCode src/Hello_VSCode.cpp) ## Rename C++ executable without prefix ## The above recommended prefix causes long target names, the following renames the ## target back to the shorter version for ease of user use ## e.g. \"rosrun someones_pkg node\" instead of \"rosrun someones_pkg someones_pkg_node\" #重命名c++可执行文件 # set_target_properties(${PROJECT_NAME}_node PROPERTIES OUTPUT_NAME node PREFIX \"\") ## Add cmake target dependencies of the executable ## same as for the library above #添加可执行文件的 cmake 目标依赖 add_dependencies(Hello_VSCode ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) ## Specify libraries to link a library or executable target against #指定库、可执行文件的链接库 target_link_libraries(Hello_VSCode ${catkin_LIBRARIES} ) ############# ## Install ## ## 安装 ## ############# # all install targets should use catkin DESTINATION variables # See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html ## Mark executable scripts (Python etc.) for installation ## in contrast to setup.py, you can choose the destination #设置用于安装的可执行脚本 catkin_install_python(PROGRAMS scripts/Hi.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) ## Mark executables for installation ## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_executables.html # install(TARGETS ${PROJECT_NAME}_node # RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} # ) ## Mark libraries for installation ## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_libraries.html # install(TARGETS ${PROJECT_NAME} # ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION} # LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION} # RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION} # ) ## Mark cpp header files for installation # install(DIRECTORY include/${PROJECT_NAME}/ # DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION} # FILES_MATCHING PATTERN \"*.h\" # PATTERN \".svn\" EXCLUDE # ) ## Mark other files for installation (e.g. launch and bag files, etc.) # install(FILES # # myfile1 # # myfile2 # DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION} # ) ############# ## Testing ## ############# ## Add gtest based cpp test target and link libraries # catkin_add_gtest(${PROJECT_NAME}-test test/test_demo01_hello_vscode.cpp) # if(TARGET ${PROJECT_NAME}-test) # target_link_libraries(${PROJECT_NAME}-test ${PROJECT_NAME}) # endif() ## Add folders to be run by python nosetests # catkin_add_nosetests(test) 1.5.2 ROS文件系统相关命令 ROS 的文件系统本质上都还是操作系统文件，我们可以使用Linux命令来操作这些文件，不过，在ROS中为了更好的用户体验，ROS专门提供了一些类似于Linux的命令，这些命令较之于Linux原生命令，更为简介、高效。文件操作，无外乎就是增删改查与执行等操作，接下来，我们就从这五个维度，来介绍ROS文件系统的一些常用命令。 1.增 catkin_create_pkg 自定义包名 依赖包 === 创建新的ROS功能包 sudo apt install xxx === 安装 ROS功能包 2.删 sudo apt purge xxx ==== 删除某个功能包 3.查 rospack list === 列出所有功能包 rospack find 包名 === 查找某个功能包是否存在，如果存在返回安装路径 roscd 包名 === 进入某个功能包 rosls 包名 === 列出某个包下的文件 apt search xxx === 搜索某个功能包 4.改 rosed 包名 文件名 === 修改功能包文件 需要安装 vim 比如:rosed turtlesim Color.msg 5.执行 5.1 roscore roscore === 是 ROS 的系统先决条件节点和程序的集合， 必须运行 roscore 才能使 ROS 节点进行通信。 roscore 将启动: ros master ros 参数服务器 rosout 日志节点 用法: roscore 或(指定端口号) roscore -p xxxx 5.2 rosrun rosrun 包名 可执行文件名 === 运行指定的ROS节点 rosrun turtlesim turtlesim_node 5.3 roslaunch roslaunch 包名 launch文件名 === 执行某个包下的 launch 文件 1.5.3 ROS计算图 1.计算图简介 前面介绍的是ROS文件结构，是磁盘上 ROS 程序的存储结构，是静态的，而 ros 程序运行之后，不同的节点之间是错综复杂的，ROS 中提供了一个实用的工具:rqt_graph。 rqt_graph能够创建一个显示当前系统运行情况的动态图形。ROS 分布式系统中不同进程需要进行数据交互，计算图可以以点对点的网络形式表现数据交互过程。rqt_graph是rqt程序包中的一部分。 2.计算图安装 如果前期把所有的功能包（package）都已经安装完成，则直接在终端窗口中输入 rosrun rqt_graph rqt_graph 如果未安装则在终端（terminal）中输入 $ sudo apt install ros-noetic-rqt $ sudo apt install ros-noetic-rqt-common-plugins 3.计算图演示 接下来以 ROS 内置的小乌龟案例来演示计算图 首先，按照前面所示，运行案例 然后，启动新终端，键入: rqt_graph 或 rosrun rqt_graph rqt_graph，可以看到网络拓扑图，该图可以显示不同节点之间的关系。 1.6 本章小结 第2章 ROS通信机制 2.1 话题通信 2.1.1 话题通信理论模型 话题通信实现模型是比较复杂的，该模型如下图所示,该模型中涉及到三个角色: ROS Master (管理者) Talker (发布者) Listener (订阅者) ROS Master 负责保管 Talker 和 Listener 注册的信息，并匹配话题相同的 Talker 与 Listener，帮助 Talker 与 Listener 建立连接，连接建立后，Talker 可以发布消息，且发布的消息会被 Listener 订阅。 整个流程由以下步骤实现: 0.Talker注册 Talker启动后，会通过RPC在 ROS Master 中注册自身信息，其中包含所发布消息的话题名称。ROS Master 会将节点的注册信息加入到注册表中。 1.Listener注册 Listener启动后，也会通过RPC在 ROS Master 中注册自身信息，包含需要订阅消息的话题名。ROS Master 会将节点的注册信息加入到注册表中。 2.ROS Master实现信息匹配 ROS Master 会根据注册表中的信息匹配Talker 和 Listener，并通过 RPC 向 Listener 发送 Talker 的 RPC 地址信息。 3.Listener向Talker发送请求 Listener 根据接收到的 RPC 地址，通过 RPC 向 Talker 发送连接请求，传输订阅的话题名称、消息类型以及通信协议(TCP/UDP)。 4.Talker确认请求 Talker 接收到 Listener 的请求后，也是通过 RPC 向 Listener 确认连接信息，并发送自身的 TCP 地址信息。 5.Listener与Talker件里连接 Listener 根据步骤4 返回的消息使用 TCP 与 Talker 建立网络连接。 6.Talker向Listener发送消息 2.1.2 话题通信基本操作 在plumbing_pub_sub功能包中创建scripts文件夹 在scripts文件夹中创建python文件demo01_pub_p.py，demo02_sub_p.py 添加可执行权限chmod +x *.py 在CMakeLists中修改文件名称，放开注释 编译 启动roscore 运行ros节点rosrun plumbing_pub_sub demo01_pub_p.py 运行ros节点rosrun plumbing_pub_sub demo02_sub_p.py 发布方 #! /usr/bin/env python #指定解释器 import rospy #导包 from std_msgs.msg import String #发布消息的类型 \"\"\" 使用python实现消息发布 1.导包 2.初始化ros节点 3.创建发布者对象 4.编写发布逻辑并发布数据 \"\"\" if __name__ == \"__main__\": #2.初始化ros节点，调用rospy中的函数 rospy.init_node(\"sanDai\") #传入节点名称name #init_node函数定义 #def init_node(name,argv=None,anonymous=False,log_level=None, #disable_rostime=False,disable_rosout=False,disable_signals=False,xmlrpc_port=0,tcpros_port=0): #3.创建发布者对象 pub = rospy.Publisher(\"che\",String,queue_size =10) #括号内给定Publishier函数的参数，其中queue_size为消息堆叠容量是10,\"che\"为话题名称 #4.编写发布逻辑并发布数据 #创建数据 msg = String() #指定发布频率 rate = rospy.Rate(1) #设置计数器 count = 0 #使用循环发布数据 rospy.sleep(3) while not rospy.is_shutdown(): #如果节点关闭自增1 count += 1 msg.data = \"hello\" + str(count) #发布数据 pub.publish(msg) rospy.loginfo(\"发布的数据:%s\",msg.data) #日志输出 rate.sleep() #休眠 订阅方 #! /usr/bin/env python #指定解释器 import rospy #导包 from std_msgs.msg import String #导包 \"\"\" 订阅实现流程： 1.导包 2.初始化ros节点 3.创建订阅者对象 4.回调函数处理数据 5.spin() \"\"\" #创建回调函数 def doMsg(msg): rospy.loginfo(\"我订阅的数据:%s\",msg.data) #日志输出 if __name__ ==\"__main__\": #2.初始化ros节点 rospy.init_node(\"huahua\") #3.创建订阅者对象 sub = rospy.Subscriber(\"che\",String,doMsg,queue_size = 10)#传入参数name，指定订阅消息类型data_class，回调函数callback，消息堆叠数queue_size #4.回调函数处理数据 #5.spin()，回调函数需要循环执行时加 rospy.spin() 2.1.3 话题通信自定义msg 在 ROS 通信协议中，数据载体是一个较为重要组成部分，ROS 中通过 std_msgs 封装了一些原生的数据类型,比如:String、Int32、Int64、Char、Bool、Empty.... 但是，这些数据一般只包含一个 data 字段，结构的单一意味着功能上的局限性，当传输一些复杂的数据，比如: 激光雷达的信息... std_msgs 由于描述性较差而显得力不从心，这种场景下可以使用自定义的消息类型 msgs只是简单的文本文件，每行具有字段类型和字段名称，可以使用的字段类型有： int8, int16, int32, int64 (或者无符号类型: uint*) float32, float64 string time, duration other msg files variable-length array[] and fixed-length array[C] 创建自定义消息，该消息包含人的信息:姓名、身高、年龄等流程： 按照固定格式创建 msg 文件 编辑配置文件 编译生成可以被 Python 调用的中间文件 具体步骤： 定义msg文件 在功能包下创建msg文件夹，添加文件Person.msg，在文件中编写以下内容 string name uint16 age float64 height 编辑配置文件 package.xml中添加编译依赖与执行依赖: message_generation message_runtime CMakeLists.txt编辑 msg 相关配置: find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation ) 需要加入 message_generation,必须有 std_msgs 配置msg源文件 add_message_files( FILES Person.msg ) 生成消息时依赖于 std_msgs generate_messages( DEPENDENCIES std_msgs ) 执行时依赖 #执行时依赖,添加message_runtime catkin_package( # INCLUDE_DIRS include # LIBRARIES demo02_talker_listener CATKIN_DEPENDS roscpp rospy std_msgs message_runtime # DEPENDS system_lib ) 编译 2.1.4 话题通信自定义msg调用 需求: 编写发布订阅实现，要求发布方以1HZ(每秒1次)的频率发布自定义消息，订阅方订阅自定义消息并将消息内容打印输出。 分析: 在模型实现中，ROS master 不需要实现，而连接的建立也已经被封装了，需要关注的关键点有三个: 发布方 接收方 数据 0.vscode配置 为了方便代码提示以及误抛异常，需要先配置 vscode，将前面生成的 python 文件路径配置进 settings.json，在终端中通过pwd获取路径，将路径粘贴到settings.json文件中 { \"python.autoComplete.extraPaths\": [ \"/opt/ros/noetic/lib/python3/dist-packages\", \"/home/jayson/demo/demo03_ws/devel/lib/python3/dist-packages/plumbing_pub_sub/msg\" ], \"python.analysis.extraPaths\": [ \"/opt/ros/noetic/lib/python3/dist-packages\" ] } 其中\"/home/jayson/demo/demo03_ws/devel/lib/python3/dist-packages/plumbing_pub_sub/msg\"为粘贴的文件路径 发布方 #! /usr/bin/env python import rospy from plumbing_pub_sub.msg import Person \"\"\" 发布方：发布人的消息 1.导包 2.初始化ros节点 3.创建发布者对象 4.组织发布逻辑并发布数据 \"\"\" if __name__ == \"__main__\": #2.初始化ros节点 rospy.init_node(\"daMa\") #3.创建发布者对象 pub = rospy.Publisher(\"jiaoSheTou\",Person,queue_size=10) #4.组织发布逻辑并发布数据 #4-1创建Person数据 p =Person() p.name = \"奥特曼\" p.age = 8 p.height = 1.85 #4-2创建Rate对象 rate = rospy.Rate(1) #4-3循环发布数据 while not rospy.is_shutdown(): pub.publish(p) rospy.loginfo(\"发布的消息:%s,%d,%.2f\",p.name,p.age,p.height) rate.sleep() 订阅方 #! /usr/bin/env python import rospy from plumbing_pub_sub.msg import Person \"\"\" 订阅方：订阅人的消息 1.导包 2.初始化ros节点 3.创建订阅者对象 4.通过回调函数处理订阅数据 5.spin() \"\"\" def doPerson(p): rospy.loginfo(\"小伙子的数据:%s,%d,%.2f\",p.name,p.age,p.height) if __name__ == \"__main__\": #2.初始化ros节点 rospy.init_node(\"daYe\") #3.创建订阅者对象 sub = rospy.Subscriber(\"jiaoSheTou\",Person,doPerson) #4.通过回调函数处理订阅数据 #5.spin() rospy.spin() 权限设置 终端下进入 scripts 执行:chmod +x *.py 配置 CMakeLists.txt catkin_install_python(PROGRAMS scripts/demo01_pub_p.py scripts/demo_02_sub_p.py scripts/demo03_pub_person_p.py scripts/demo04_sub_person_p.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) 执行 启动 roscore; 启动发布节点; 启动订阅节点。 2.2 服务通信 2.2.1 服务通信理论模型 服务通信较之于话题通信更简单些，理论模型如下图所示，该模型中涉及到三个角色: ROS master(管理者) Server(服务端) Client(客户端) ROS Master 负责保管 Server 和 Client 注册的信息，并匹配话题相同的 Server 与 Client ，帮助 Server 与 Client 建立连接，连接建立后，Client 发送请求信息，Server 返回响应信息。 整个流程由以下步骤实现: 0.Server注册 Server 启动后，会通过RPC在 ROS Master 中注册自身信息，其中包含提供的服务的名称。ROS Master 会将节点的注册信息加入到注册表中。 1.Client注册 Client 启动后，也会通过RPC在 ROS Master 中注册自身信息，包含需要请求的服务的名称。ROS Master 会将节点的注册信息加入到注册表中。 2.ROS Master实现信息匹配 ROS Master 会根据注册表中的信息匹配Server和 Client，并通过 RPC 向 Client 发送 Server 的 TCP 地址信息。 3.Client发送请求 Client 根据步骤2 响应的信息，使用 TCP 与 Server 建立网络连接，并发送请求数据。 4.Server发送响应 Server 接收、解析请求的数据，并产生响应结果返回给 Client。 2.2.2 服务通信自定义srv 需求: 服务通信中，客户端提交两个整数至服务端，服务端求和并响应结果到客户端，请创建服务器与客户端通信的数据载体。 流程: srv 文件内的可用数据类型与 msg 文件一致，且定义 srv 实现流程与自定义 msg 实现流程类似: 按照固定格式创建srv文件 编辑配置文件 编译生成中间文件 具体步骤： 在工作空间中创建srv文件夹，定义srv文件AddInts.srv int32 num1 int32 num2 --- int32 sum 编辑配置文件 package.xml中添加编译依赖与执行依赖message_generation message_runtime CMakeLists.txt编辑 srv 相关配置add_service_files( FILES AddInts.srv ) 其中部分配置在话题通信中已完成。 编译 2.2.3 服务通信自定义srv调用 需求:编写服务通信，客户端提交两个整数至服务端，服务端求和并响应结果到客户端。 分析: 在模型实现中，ROS master 不需要实现，而连接的建立也已经被封装了，需要关注的关键点有三个: 服务端 客户端 数据 流程： 编写服务端实现； 编写客户端实现； 为python文件添加可执行权限 编辑配置文件 编译并执行 具体步骤： vscode配置 配置settings.json文件，复制dist-packages的绝对路径到settings.json文件中 \"python.autoComplete.extraPaths\": [ \"/opt/ros/noetic/lib/python3/dist-packages\", \"/home/jayson/demo/demo03_ws/devel/lib/python3/dist-packages\" ] 服务端 #! /usr/bin/env python import rospy #导包 from plumbing_server_client.srv import AddInts,AddIntsRequest,AddIntsResponse #from plumbing_server_client.srv import * 两种不同的导包方式 \"\"\" 服务端：解析客户端请求，产生响应。 1.导包 2.初始化ros节点 3.创建服务端对象 4.编写处理逻辑（回调函数） 5.spin() \"\"\" #参数：封装了请求数据 #返回值：响应数据 def doNum(request): #1.解析提交的两个整数 num1 = request.num1 num2 = request.num2 #2.求和 sum = num1 +num2 #3.将结果sum封装进响应 response = AddIntsResponse() response.sum = sum rospy.loginfo(\"服务器解析的数据num1 = %d, num2 = %d, 响应的结果: sum = %d\",num1,num2,sum) return response if __name__ == \"__main__\": #2.初始化ros节点 rospy.init_node(\"heishui\") #3.创建服务端对象 server = rospy.Service(\"addInts\",AddInts,doNum) #三个参数分别为：话题名称，消息对应的类型，回调函数 rospy.loginfo(\"服务器已经启动了\") #输出日志 #4.编写处理逻辑（回调函数） #5.spin() rospy.spin() 客户端 #! /usr/bin/env python import rospy from plumbing_server_client.srv import AddInts,AddIntsRequest,AddIntsResponse import sys #“sys”即“system”，“系统”之意。该模块提供了一些接口，用于访问 Python 解释器自身使用和维护的变量，同时模块中还提供了一部分函数，可以与解释器进行比较深度的交互。 \"\"\" 客户端：组织并提交请求，处理服务端响应 1.导包 2.初始化ros节点 3.创建客户端对象 4.组织请求数据，并发送请求 5.处理响应 优化实现： 可以在执行节点时，动态传入参数 问题： 客户端先于服务端启动，会抛出异常 需要： 客户端先于服务员启动，不抛出异常而是挂起，等待服务启动后，再次发送请求 实现： ROS中内置了相关函数,这些函数可以判断服务器状态,如果服务没有启动,那么就可以让客户端挂起 方案1: client.wais_for_service() 方案2: rospy.wait_for_service(\"话题名称\") \"\"\" if __name__ == \"__main__\": #判断参数长度 if len(sys.argv) != 3: #“argv”即“argument value”的简写，是一个列表对象，其中存储的是在命令行调用 Python 脚本时提供的“命令行参数”。 #这个列表中的第一个参数是被调用的脚本名称，包含传入的两个参数，正常情况下共有三个参数。 rospy.logerr(\"传入的参数个数不对。\") sys.exit(1) #有错误退出 #sys.exit()会引发一个异常：SystemExit，如果这个异常没有被捕获，那么python解释器将会退出。如果有捕获此异常的代码，那么这些代码还是会执行。捕获这个异常可以做一些额外的清理工作。0为正常退出，其他数值（1-127）为不正常，可抛异常事件供捕获。 #2.初始化ros节点 rospy.init_node(\"erHei\") #3.创建客户端对象 client = rospy.ServiceProxy(\"addInts\",AddInts) #两个参数分别为：话题名称，消息类型 rospy.loginfo(\"客户端对象创建\") #4.组织请求数据，并发送请求 #解析传入的参数 num1 = int(sys.argv[1]) num2 = int(sys.argv[2]) #等待服务器启动,第一种实现策略： #client.wait_for_service() #第二种实现策略 rospy.wait_for_service(\"addInts\") response = client.call(num1,num2) #5.处理响应 rospy.loginfo(\"响应的数据:%d\",response.sum) 设置权限 终端下进入 scripts 执行:chmod +x *.py 配置CMakeLists.txt catkin_install_python(PROGRAMS scripts/demo01_server_p.py scripts/demo02_client_p.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) 执行 流程: 需要先启动服务:rosrun 包名 服务 rosrun plumbing_server_client demo01_server_p.py 然后再调用客户端 :rosrun 包名 客户端 参数1 参数2 rosrun plumbing_server_client demo02_client_p.py 12 34 结果: 会根据提交的数据响应相加后的结果。 2.3 参数服务器 2.3.1 参数服务器理论模型 参数服务器实现是最为简单的，该模型如下图所示,该模型中涉及到三个角色: ROS Master (管理者) Talker (参数设置者) Listener (参数调用者) ROS Master 作为一个公共容器保存参数，Talker 可以向容器中设置参数，Listener 可以获取参数。 整个流程由以下步骤实现: Talker 设置参数 Talker 通过 RPC 向参数服务器发送参数(包括参数名与参数值)，ROS Master 将参数保存到参数列表中。 Listener 获取参数 Listener 通过 RPC 向参数服务器发送参数查找请求，请求中包含要查找的参数名。 ROS Master 向 Listener 发送参数值 ROS Master 根据步骤2请求提供的参数名查找参数值，并将查询结果通过 RPC 发送给 Listener。 2.3.2 参数操作 需求:实现参数服务器参数的增删改查操作。 参数服务器新增(修改)参数 #! /usr/bin/env python import rospy \"\"\" 演示参数的新增与修改 需求：在参数服务器中设置机器人属性，型号，半径 实现： rospy.set_param() \"\"\" if __name__ == \"__main__\": #初始化ros节点 rospy.init_node(\"param_set_p\") #新增参数 rospy.set_param(\"type_p\",\"xiaoHuangChe\") rospy.set_param(\"radius_p\",0.15) #修改参数 rospy.set_param(\"radius_p\",0.2) #两个语句键一样，后面语句将前面语句的值覆盖 参数服务器获取参数 #! /usr/bin/env python import rospy \"\"\" 演示参数查询 get_param(键,默认值) 当键存在时，返回对应的值，如果不存在返回默认值 get_param_cached 和get_param 使用一致，只是效率高 get_param_names 获取所有的参数的键的集合 has_param 判断是否包含某个键 search_param 查找某个键，并返回完整的键名 \"\"\" if __name__ == \"__main__\": rospy.init_node(\"get_param_p\") #1.get_param radius = rospy.get_param(\"radius_p\",0.5) radius2 = rospy.get_param(\"radius_p_xxx\",0.5) rospy.loginfo(\"radius= %.2f\",radius) rospy.loginfo(\"radius2= %.2f\",radius2) #2.get_param_cached radius3 = rospy.get_param_cached(\"radius_p\",0.5) radius4 = rospy.get_param_cached(\"radius_p_xxx\",0.5) rospy.loginfo(\"radius3= %.2f\",radius3) rospy.loginfo(\"radius4= %.2f\",radius4) #3.get_param_names names = rospy.get_param_names() for name in names: rospy.loginfo(\"name = %s\",name) #4.has_param flag1 = rospy.has_param(\"radius_p\") if flag1: rospy.loginfo(\"radius_p 存在\") else: rospy.loginfo(\"radius_p 不存在\") flag2 = rospy.has_param(\"radius_p_xxx\") if flag2: rospy.loginfo(\"radius_p_xxx 存在\") else: rospy.loginfo(\"radius_p_xxx 不存在\") #5.search_param key = rospy.search_param(\"radius_p\") rospy.loginfo(\"key = %s\",key) 参数服务器删除参数 #! usr/bin/env python import rospy \"\"\" 演示参数删除： delete_param() \"\"\" if __name__ ==\"__main__\": rospy.init_node(\"del_param_p\") try: #用于优化，捕获异常给出提示 #删除参数 rospy.delete_param(\"radius_p\") except Exception as e: rospy.loginfo(\"被删除的参数不存在\") 2.4 常用命令 2.4.1 rosnode rosnode 是用于获取节点信息的命令 rosnode ping 测试到节点的连接状态 rosnode list 列出活动节点 rosnode info 打印节点信息 rosnode machine 列出指定设备上节点 rosnode kill 杀死某个节点 rosnode cleanup 清除不可连接的节点 rosnode ping 测试节点的连接状态 rosnode list 列出活动节点 rosnode info 打印节点信息 rosnode machine 列出指定设备上的节点 rosnode kill 杀死某个正在运行的节点 rosnode cleanup 清除无用节点，启动乌龟节点，然后 ctrl + c 关闭，该节点并没被彻底清除，通过rosnode list仍可列出被关闭的节点，可以使用 cleanup 清除节点 2.4.2 rostopic rostopic包含rostopic命令行工具，用于显示有关ROS 主题的调试信息，包括发布者，订阅者，发布频率和ROS消息。它还包含一个实验性Python库，用于动态获取有关主题的信息并与之交互。 rostopic bw 显示主题使用的带宽 rostopic delay 显示带有 header 的主题延迟 rostopic echo 打印消息到屏幕 rostopic find 根据类型查找主题 rostopic hz 显示主题的发布频率 rostopic info 显示主题相关信息 rostopic list 显示所有活动状态下的主题 rostopic pub 将数据发布到主题 rostopic type 打印主题类型 rostopic list 显示当前正在活跃的话题 rostopic echo 获取指定话题当前发布的消息 rostopic pub 可以直接调用命令向订阅者发布消息 rostopic info 获取当前话题的相关信息 rostopic type 列出话题的消息类型 rostopic find 消息类型 根据消息类型查找话题 rostopic hz 列出消息发布频率 rostopic bw 列出消息发布带宽 2.4.3 rosmsg rosmsg是用于显示有关 ROS消息类型的 信息的命令行工具。 rosmsg show 显示消息描述 rosmsg info 显示消息信息 rosmsg list 列出所有消息 rosmsg md5 显示 md5 加密后的消息 rosmsg package 显示某个功能包下的所有消息 rosmsg packages 列出包含消息的功能包 rosmsg list 列出当前 ROS 中的所有 msg rosmsg packages 列出包含消息的所有包 rosmsg show 显示消息描述 rosmsg info 作用与 rosmsg show 一样 2.4.4 rosservice rosservice包含用于列出和查询ROSServices的rosservice命令行工具。 调用部分服务时，如果对相关工作空间没有配置 path，需要进入工作空间调用 source ./devel/setup.bash rosservice args 打印服务参数 rosservice call 使用提供的参数调用服务 rosservice find 按照服务类型查找服务 rosservice info 打印有关服务的信息 rosservice list 列出所有活动的服务 rosservice type 打印服务类型 rosservice uri 打印服务的 ROSRPC uri rosservice list 列出所有活动的服务 rosservice args 打印服务参数 rosservice call 扮演客户端角色，可以向服务器发请求，调用服务 rosservice find 根据消息类型获取话题 rosservice info 获取服务话题详情 rosservice type 获取消息类型 2.4.5 rossrv rossrv是用于显示有关ROS服务类型的信息的命令行工具，与 rosmsg 使用语法高度雷同。 rossrv show 显示服务消息详情 rossrv info 显示服务消息相关信息 rossrv list 列出所有服务信息 rossrv md5 显示 md5 加密后的服务消息 rossrv package 显示某个包下所有服务消息 rossrv packages 显示包含服务消息的所有包 rossrv list 列出当前 ROS 中的所有 srv 消息 rossrv packages 列出包含服务消息的所有包 rossrv show 显示消息描述 rossrv info 作用与 rossrv show 一致 2.4.6 rosparam rosparam包含rosparam命令行工具，用于使用YAML编码文件在参数服务器上获取和设置ROS参数。 rosparam set 设置参数 rosparam get 获取参数 rosparam load 从外部文件加载参数 rosparam dump 将参数写出到外部文件 rosparam delete 删除参数 rosparam list 列出所有参数 rosparam list 列出所有参数 rosparam set 设置参数 rosparam get 获取参数 rosparam delete 删除参数 2.5 通信机制实操 2.5.1 话题发布 运行乌龟案例后 使用rqt_graph获取乌龟案例不同节点之间的话题，为 /turtle1/cmd_vel 使用rostopic info /turtle1/cmd_vel获取指定话题的信息，得到消息类型为 geometry_msgs/Twist 使用rosmsg info geometry_msgs/Twist获取消息格式为 geometry_msgs/Vector3 linear #线速度 float64 x float64 y float64 z geometry_msgs/Vector3 angular #角速度 float64 x float64 y float64 z 使用rostopic echo turtle1/cmd_vel可以获取乌龟运动时的线速度和角速度的值 使用rostopic pub命令可让乌龟实现圆周运动 rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist \"linear: x: 1.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 1.0\" python实现代码： #! /usr/bin/env python import rospy from geometry_msgs.msg import Twist \"\"\" 发布方：发布速度消息 话题名称：/turtle1/cmd_vel 消息类型:geometry_msgs/Twist 1.导包 2.初始化ros节点 3.创建发布者对象 4.组织数据并发布数据 \"\"\" if __name__ == \"__main__\": #2.初始化ros节点 rospy.init_node(\"my_control_p\") #3.创建发布者对象 pub = rospy.Publisher(\"/turtle1/cmd_vel\",Twist,queue_size=10) #4.组织数据并发布数据 #设置发布频率 rate = rospy.Rate(10) #创建速度消息 twist = Twist() twist.linear.x = 1.0 twist.linear.y = 0.0 twist.linear.z = 0.0 twist.angular.x = 0.0 twist.angular.y = 0.0 twist.angular.z = 1.0 #循环发布 while not rospy.is_shutdown(): pub.publish(twist) rate.sleep() 2.5.2 话题订阅 在功能包中创建launch文件夹，并在文件夹中创建start_turtle.launch文件 编写好代码后 使用rostopic list获取位姿话题为/turtle1/pose 使用rostopic info /turtle1/pose获取消息类型为turtlesim/Pose 使用rosmsg info turtlesim/Pose获取消息格式为 float32 x float32 y float32 theta float32 linear_velocity float32 angular_velocity 实时获取乌龟位姿信息python代码 #! /usr/bin/env python import rospy from turtlesim.msg import Pose \"\"\" 需求：订阅并输出乌龟位姿信息 1.导包 2.初始化ros节点 3.创建订阅者对象 4.使用回调函数处理订阅到的消息 5.spin() \"\"\" def doPose(pose): rospy.loginfo(\"P->乌龟位姿信息:左边(%.2f,%.2f),朝向:%.2f,线速度:%.2f, 角速度:%.2f\",pose.x,pose.y,pose.theta,pose.linear_velocity,pose.angular_velocity) if __name__ == \"__main__\": #2.初始化ros节点 rospy.init_node(\"sub_pose_p\") #3.创建订阅者对象 sub = rospy.Subscriber(\"/turtle1/pose\",Pose,doPose,queue_size= 100) #4.使用回调函数处理订阅到的消息 #5.spin() rospy.spin() 2.5.3 服务调用 启动launch文件，使用rosservice list查询存在的服务 通过命令形式调用服务并给定相应参数，生成乌龟 rosservice call /spawn \"x: 1.0 y: 4.0 theta: 1.57 name: 'turtle2'\" python代码： #! /usr/bin/env python import rospy from turtlesim.srv import Spawn,SpawnRequest,SpawnResponse \"\"\" 需求：向服务器发送请求，生成一只乌龟 话题：/spawn 消息:turtlesim/Spawn 1.导包 2.初始化ros节点 3.创建服务的客户端对象 4.组织数据并发送请求 5.处理响应结果 \"\"\" if __name__ == \"__main__\": #2.初始化ros节点 rospy.init_node(\"service_call_p\") #3.创建服务的客户端对象 client = rospy.ServiceProxy(\"/spawn\",Spawn) #4.组织数据并发送请求 #4-1组织数据 request = SpawnRequest() request.x = 4.5 request.y = 2.0 request.theta = -3 request.name = \"turtle3\" #4-2判断服务器状态并发送 client.wait_for_service() try: response = client.call(request) #5.处理响应结果 rospy.loginfo(\"生成乌龟的名字叫:%s\",response.name) except Exception as e: rospy.logerr(\"请求处理异常\") 2.5.4 参数设置 通过命令修改乌龟背景颜色参数 rosparam set /turtlesim/background_r 255 rosparam set /turtlesim/background_g 0 rosparam set /turtlesim/background_b 0 python代码实现： #! /usr/bin/env python import rospy \"\"\" 需求:修改乌龟GUI的背景色 1.初始化ros节点 2.设置参数 \"\"\" if __name__ == \"__main__\": rospy.init_node(\"change_bgColor_p\") #修改背景色 rospy.set_param(\"/turtlesim/background_r\",100) rospy.set_param(\"/turtlesim/background_r\",50) rospy.set_param(\"/turtlesim/background_r\",200) 2.6 通信机制比较 三种通信机制中，参数服务器是一种数据共享机制，可以在不同的节点之间共享数据，话题通信与服务通信是在不同的节点之间传递数据的，三者是ROS中最基础也是应用最为广泛的通信机制。 这其中，话题通信和服务通信有一定的相似性也有本质上的差异，在此将二者做一下简单比较: 二者的实现流程是比较相似的，都是涉及到四个要素: 要素1: 消息的发布方/客户端(Publisher/Client) 要素2: 消息的订阅方/服务端(Subscriber/Server) 要素3: 话题名称(Topic/Service) 要素4: 数据载体(msg/srv) 可以概括为: 两个节点通过话题关联到一起，并使用某种类型的数据载体实现数据传输。 二者的实现也是有本质差异的，具体比较如下: 同步性: 服务通信，由客户端发送请求给服务端，服务端处理完成后再响应给客户端；客户端再发送请求，服务端处理并响应，按照顺序依次执行。 话题通信,发布方发布消息后不用管订阅方是否处理完数据，为异步。 不同通信机制有一定的互补性，都有各自适应的应用场景。尤其是话题与服务通信，需要结合具体的应用场景与二者的差异，选择合适的通信机制。 2.7 本章小结 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/ROS1/chapter2.html":{"url":"Markdown/ROS1/chapter2.html","title":"2 实践","keywords":"","body":"2 实践 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/ROS1/chapter2-1.html":{"url":"Markdown/ROS1/chapter2-1.html","title":"2.1 自主导航","keywords":"","body":"2.1 自主导航 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/ROS1/chapter2-2.html":{"url":"Markdown/ROS1/chapter2-2.html","title":"2.2 自主抓取","keywords":"","body":"2.2 自主抓取 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/":{"url":"Markdown/Resource/","title":"A 常用资源","keywords":"","body":"优秀资源汇总 1 综合导航 1 AIGC导航：https://www.aigc.cn/ --> 综合导航⭐️⭐️ 2 柒夜导航：https://nav.qinight.com/ --> 综合导航⭐️⭐️ 3 导航文库：https://docs.apachecn.org/ --> 编程学习♓ 4 熊猫搜书：https://xmsoushu.com/?mpyit.com --> 电子书查找➿ 5 简视频：https://www.aewz.com/ --> 视频素材⛺ 2 在线工具箱 ① 即时工具：https://www.67tool.com/ ② Toolfun：https://tools.fun/ ③ TinyWow: https://tinywow.com/ 3 PPT 1 第1PPT：https://www.1ppt.com/ --> PPT模板 2 优品PPT：https://www.ypppt.com/ --> PPT模板 3 51PPT：https://www.51pptmoban.com/ --> PPT模板 4 PPT超级市场: https://www.pptsupermarket.com/ --> 可以当导航页面使用，下面的工具比较好用 4 其他 1 廖雪峰官网：https://www.liaoxuefeng.com/ --> 编程语言自学 2 书栈网：https://www.bookstack.cn/ --> 编程语言自学 3 汉典：https://www.zdic.net/ -- > 汉字、词组、古籍、书法等 4 Groupdocs：https://products.groupdocs.app/translation/zh/total --> 在线文档翻译和转换 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/ubuntu.html":{"url":"Markdown/Resource/ubuntu.html","title":"1 Ubuntu","keywords":"","body":"1 Ubuntu 1 Linux命令大全(手册): https://www.linuxcool.com/ 2 鸟哥的Linux私房菜：https://linux.vbird.org/ 3 肝下25万字的《决战Linux到精通》笔记，你的Linux水平将从入门到入魔 点击传送 4 史上最全的Linux常用命令汇总（超全面！超详细！）收藏这一篇就够了！点击传送 5 Linux学习教程，Linux入门教程（超详细）：http://c.biancheng.net/linux_tutorial/ new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/ros.html":{"url":"Markdown/Resource/ros.html","title":"2 ROS1","keywords":"","body":"2 ROS ROS1 1 ROS Index: https://index.ros.org/ 2 赵虚左讲义：http://www.autolabor.com.cn/book/ROSTutorials/ 3 创客制造-ROS1轻松学：https://www.ncnynl.com/ros1.html 4 鱼香ROS：http://fishros.com/#/fish_home Github: https://github.com/fishros/install 5 ROS Robots: https://robots.ros.org/ ROS2 1 古月居ROS2入门教程：https://book.guyuehome.com/new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/c++.html":{"url":"Markdown/Resource/c++.html","title":"3 C++","keywords":"","body":"3 C++ 1 cppreference：https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5 2 LEARN C++：https://www.learncpp.com/ 3 cplusplus：https://cplusplus.com/ 4 tutorialspoint：https://www.tutorialspoint.com/index.htm 5 Awesome C++：https://github.com/fffaraz/awesome-cpp new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/python.html":{"url":"Markdown/Resource/python.html","title":"4 Python","keywords":"","body":"4 Python 1 Python - 100天从新手到大：https://github.com/jackfrued/Python-100-Days --> Python推荐学习资源 网盘链接：链接：https://pan.baidu.com/s/19_5fDewSwfM5qGSWYG38dA?pwd=6666 提取码：6666 2 Python标准库：https://docs.python.org/zh-cn/3/new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/vim.html":{"url":"Markdown/Resource/vim.html","title":"5 Vim","keywords":"","body":"5 Vim 1 Vim 在线学习：https://www.lanqiao.cn/courses/2/learning/?id=16new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/docker.html":{"url":"Markdown/Resource/docker.html","title":"6 Docker","keywords":"","body":"6 Docker 1 Docker 教程：https://www.runoob.com/docker/docker-tutorial.html 2 Docker Hub: https://hub.docker.com/new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/":{"url":"Markdown/Tools/","title":"B 常用工具","keywords":"","body":"B 常用工具 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/Git-1.html":{"url":"Markdown/Tools/Git-1.html","title":"1 廖雪峰Git教程","keywords":"","body":"[搬]Git 教程--廖雪峰 廖雪峰Git教程链接：https://www.liaoxuefeng.com/wiki/896043488029600 Git大全：https://gitee.com/all-about-git Git命令在线学习：https://oschina.gitee.io/learn-git-branching/ 史上最浅显易懂的Git教程！ 为什么要编写这个教程？因为我在学习Git的过程中，买过书，也在网上Google了一堆Git相关的文章和教程，但令人失望的是，这些教程不是难得令人发指，就是简单得一笔带过，或者，只支离破碎地介绍Git的某几个命令，还有直接从Git手册粘贴帮助文档的，总之，初学者很难找到一个由浅入深，学完后能立刻上手的Git教程。 既然号称史上最浅显易懂的Git教程，那这个教程有什么让你怦然心动的特点呢？ 首先，本教程绝对面向初学者，没有接触过版本控制概念的读者也可以轻松入门，不必担心起步难度； 其次，本教程实用性超强，边学边练，一点也不觉得枯燥。而且，你所学的Git命令是“充分且必要”的，掌握了这些东西，你就可以通过Git轻松地完成你的工作。 文字+图片还看不明白？有视频！！！ 本教程只会让你成为Git用户，不会让你成为Git专家。很多Git命令只有那些专家才明白（事实上我也不明白，因为我不是Git专家），但我保证这些命令可能你一辈子都不会用到。既然Git是一个工具，就没必要把时间浪费在那些“高级”但几乎永远不会用到的命令上。一旦你真的非用不可了，到时候再自行Google或者请教专家也未迟。 如果你是一个开发人员，想用上这个世界上目前最先进的分布式版本控制系统，那么，赶快开始学习吧！ 1 Git 简介 Git是什么？ Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Git有什么特点？简单来说就是：高端大气上档次！ 那什么是版本控制系统？ 如果你用Microsoft Word写过长篇大论，那你一定有这样的经历： 想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样： 过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。 看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。 更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。 于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？ 这个软件用起来就应该像这个样子，能记录每次文件的改动： 这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。 1 Git的诞生 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 2 集中式vs分布式 Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。 CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。 微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。 分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！ 1.1 安装Git 最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。 要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字： 1 在Linux上安装Git 首先，你可以试着输入git，看看系统有没有安装Git： $ git The program 'git' is currently not installed. You can install it by typing: sudo apt-get install git 像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。 如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。 老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。 如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。 2 在Mac OS X上安装Git 如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。 第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”->“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！ 3 在Windows上安装Git 在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入： $ git config --global user.name \"Your Name\" $ git config --global user.email \"email@example.com\" 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 1.2 创建版本库 1 创建版本库 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： $ mkdir learngit $ cd learngit $ pwd /Users/michael/learngit pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。 如果你使用 Windows 系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 第二步，通过git init命令把这个目录变成 Git 可以管理的仓库： $ git init Initialized empty Git repository in /Users/michael/learngit/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。 2 把文件添加到版本库 首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 使用Windows的童鞋要特别注意： 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Visual Studio Code代替记事本，不但功能强大，而且免费！ 言归正传，现在我们编写一个readme.txt文件，内容如下： Git is a version control system. Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令git add告诉Git，把文件添加到仓库： $ git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： $ git commit -m \"wrote a readme file\" [master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入-m \"xxx\"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m \"add 3 files.\" 3 疑难解答 Q：输入git add readme.txt，得到错误：fatal: not a git repository (or any of the parent directories)。 A：Git命令必须在Git仓库目录内执行（git init除外），在仓库目录外执行是没有意义的。 Q：输入git add readme.txt，得到错误fatal: pathspec 'readme.txt' did not match any files。 A：添加某个文件时，该文件必须在当前目录下存在，用ls或者dir命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。 4 小结 现在总结一下今天学的两点内容： 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add ，注意，可反复多次使用，添加多个文件； 使用命令git commit -m ，完成。 2 时光机穿梭 1 时光机穿梭 我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容： Git is a distributed version control system. Git is free software. 现在，运行git status命令看看结果： $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： $ git diff readme.txt diff --git a/readme.txt b/readme.txt index 46d49bf..9247db6 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add $ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: readme.txt git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： $ git commit -m \"add distributed\" [master e475afc] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： $ git status On branch master nothing to commit, working tree clean Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。 2 小结 要随时掌握工作区的状态，使用`git status`命令。 如果`git status`告诉你有文件被修改过，用`git diff`可以查看修改内容。 2.1 版本回退 1 版本回退 现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下： Git is a distributed version control system. Git is free software distributed under the GPL. 然后尝试提交： $ git add readme.txt $ git commit -m \"append GPL\" [master 1094adb] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了： 版本1：wrote a readme file Git is a version control system. Git is free software. 版本2：add distributed Git is a distributed version control system. Git is free software. 版本3：append GPL Git is a distributed version control system. Git is free software distributed under the GPL. 当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： $ git log commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) Author: Michael Liao Date: Fri May 18 21:06:15 2018 +0800 append GPL commit e475afc93c209a690c39c13a46716e8fa000c366 Author: Michael Liao Date: Fri May 18 21:03:36 2018 +0800 add distributed commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 Author: Michael Liao Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： $ git log --pretty=oneline 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) append GPL e475afc93c209a690c39c13a46716e8fa000c366 add distributed eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线： 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令： $ git reset --hard HEAD^ HEAD is now at e475afc add distributed --hard参数有啥意义？这个后面再讲，现在你先放心使用。 看看readme.txt的内容是不是版本add distributed： $ cat readme.txt Git is a distributed version control system. Git is free software. 果然被还原了。 还可以继续回退到上一个版本wrote a readme file，不过且慢，让我们用git log再看看现在版本库的状态： $ git log commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -> master) Author: Michael Liao Date: Fri May 18 21:03:36 2018 +0800 add distributed commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 Author: Michael Liao Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本： $ git reset --hard 1094a HEAD is now at 83b0afe append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 再小心翼翼地看看readme.txt的内容： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. 果然，我胡汉三又回来了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： $ git reflog e475afc HEAD@{1}: reset: moving to HEAD^ 1094adb (HEAD -> master) HEAD@{2}: commit: append GPL e475afc HEAD@{3}: commit: add distributed eaadf4e HEAD@{4}: commit (initial): wrote a readme file 终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。 2 小结 现在总结一下： `HEAD`指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`。 穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本 2.2 工作区和暂存区 1 工作区和暂存区 Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 先来看名词解释。 1.1 工作区（Working Directory） 就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 1.2 版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步：用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步：用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态： $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt Untracked files: (use \"git add ...\" to include in what will be committed) LICENSE no changes added to commit (use \"git add\" and/or \"git commit -a\") Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: LICENSE modified: readme.txt 现在，暂存区的状态就变成这样了： 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 $ git commit -m \"understand how stage works\" [master e43a48b] understand how stage works 2 files changed, 2 insertions(+) create mode 100644 LICENSE 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： $ git status On branch master nothing to commit, working tree clean 现在版本库变成了这样，暂存区就没有任何内容了： 2 小结 暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。 没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。 2.3 管理修改 1 管理修改 现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。 你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes. 然后，添加： $ git add readme.txt $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: readme.txt 然后，再修改readme.txt： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. 提交： $ git commit -m \"git tracks changes\" [master 519219b] git tracks changes 1 file changed, 1 insertion(+) 提交后，再看看状态： $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 咦，怎么第二次的修改没有被提交？ 别激动，我们回顾一下操作过程： 第一次修改 -> git add -> 第二次修改 -> git commit 你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交。但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别： $ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txt index 76d770f..a9c5755 100644 --- a/readme.txt +++ b/readme.txt @@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. -Git tracks changes. +Git tracks changes of files. 可见，第二次修改确实没有被提交。 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了： 第一次修改 -> git add -> 第二次修改 -> git add -> git commit 好，现在，把第二次修改提交了，然后开始小结。 2 小结 现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中。 2.4 撤销修改 1 撤销修改 自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了stupid boss可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改： $ git checkout -- readme.txt 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 现在，看看readme.txt的文件内容： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. 文件内容果然复原了。 git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. My stupid boss still prefers SVN. $ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交： $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: readme.txt Git同样告诉我们，用命令git reset HEAD 可以把暂存区的修改撤销掉（unstage），重新放回工作区： $ git reset HEAD readme.txt Unstaged changes after reset: M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt 还记得如何丢弃工作区的修改吗？ $ git checkout -- readme.txt $ git status On branch master nothing to commit, working tree clean 整个世界终于清静了！ 现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把stupid boss提交推送到远程版本库，你就真的惨了…… 2 小结 又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD ，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 2.5 删除文件 1 删除文件 在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交： $ git add test.txt $ git commit -m \"add test.txt\" [master b84166e] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： $ rm test.txt 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： $ git status On branch master Changes not staged for commit: (use \"git add/rm ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) deleted: test.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： $ git rm test.txt rm 'test.txt' $ git commit -m \"remove test.txt\" [master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中被删除了。 小提示：先手动删除文件，然后使用git rm 和git add效果是一样的。 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： $ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ 2 小结 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删。但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 3 远程仓库 1 远程仓库 到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。 可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。 没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？ 其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。 实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。 完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C \"youremail@example.com\" 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的Key： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。 2 小结 “有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机 3.1 添加远程库 1 添加远程库 现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步。这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的。GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： $ git remote add origin git@github.com:michaelliao/learngit.git 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master Counting objects: 20, done. Delta compression using up to 4 threads. Compressing objects: 100% (15/15), done. Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done. Total 20 (delta 5), reused 0 (delta 0) remote: Resolving deltas: 100% (5/5), done. To github.com:michaelliao/learngit.git * [new branch] master -> master Branch 'master' set up to track remote branch 'master' from 'origin'. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ 2 SSH警告 当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added 'github.com' (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 3 删除远程库 如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm 命令。使用前，建议先用git remote -v查看远程库信息： $ git remote -v origin git@github.com:michaelliao/learn-git.git (fetch) origin git@github.com:michaelliao/learn-git.git (push) 然后，根据名字删除，比如删除origin： $ git remote rm origin 此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。 4 小结 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 3.2 从远程库克隆 1 从远程库克隆 上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills： 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： $ git clone git@github.com:michaelliao/gitskills.git Cloning into 'gitskills'... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3 Receiving objects: 100% (3/3), done. 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了： $ cd gitskills $ ls README.md 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 2 小结 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但ssh协议速度最快。 4 分支管理 1 分支管理 分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。 4.1 创建与合并分支 1 创建与合并分支 在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： HEAD │ │ ▼ master │ │ ▼ ┌───┐ ┌───┐ ┌───┐ │ │───▶│ │───▶│ │ └───┘ └───┘ └───┘ 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： master │ │ ▼ ┌───┐ ┌───┐ ┌───┐ │ │───▶│ │───▶│ │ └───┘ └───┘ └───┘ ▲ │ │ dev ▲ │ │ HEAD 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： master │ │ ▼ ┌───┐ ┌───┐ ┌───┐ ┌───┐ │ │───▶│ │───▶│ │───▶│ │ └───┘ └───┘ └───┘ └───┘ ▲ │ │ dev ▲ │ │ HEAD 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： HEAD │ │ ▼ master │ │ ▼ ┌───┐ ┌───┐ ┌───┐ ┌───┐ │ │───▶│ │───▶│ │───▶│ │ └───┘ └───┘ └───┘ └───┘ ▲ │ │ dev 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： HEAD │ │ ▼ master │ │ ▼ ┌───┐ ┌───┐ ┌───┐ ┌───┐ │ │───▶│ │───▶│ │───▶│ │ └───┘ └───┘ └───┘ └───┘ 真是太神奇了，你看得出来有些提交是通过分支完成的吗？ 下面开始实战。 首先，我们创建dev分支，然后切换到dev分支： $ git checkout -b dev Switched to a new branch 'dev' git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： $ git branch dev $ git checkout dev Switched to branch 'dev' 然后，用git branch命令查看当前分支： $ git branch * dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行： Creating a new branch is quick. 然后提交： $ git add readme.txt $ git commit -m \"branch test\" [dev b17d20e] branch test 1 file changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支： $ git checkout master Switched to branch 'master' 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 现在，我们把dev分支的工作成果合并到master分支上： $ git merge dev Updating d46f35e..b17d20e Fast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： $ git branch -d dev Deleted branch dev (was b17d20e). 删除后，查看branch，就只剩下master分支了： $ git branch * master 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 2 switch 我们注意到切换分支使用git checkout ，而前面讲过的撤销修改则是git checkout -- ，同一个命令，有两种作用，确实有点令人迷惑。 实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支： 创建并切换到新的dev分支，可以使用： $ git switch -c dev 直接切换到已有的master分支，可以使用： $ git switch master 使用新的git switch命令，比git checkout要更容易理解。 3 小结 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 或者git switch 创建+切换分支：git checkout -b 或者git switch -c 合并某分支到当前分支：git merge 删除分支：git branch -d 4.2 解决冲突 1 解决冲突 人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： $ git switch -c feature1 Switched to a new branch 'feature1' 修改readme.txt最后一行，改为： Creating a new branch is quick AND simple. 在feature1分支上提交： $ git add readme.txt $ git commit -m \"AND simple\" [feature1 14096d0] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支： $ git switch master Switched to branch 'master' Your branch is ahead of 'origin/master' by 1 commit. (use \"git push\" to publish your local commits) Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行改为： Creating a new branch is quick & simple. 提交： $ git add readme.txt $ git commit -m \"& simple\" [master 5dc6824] & simple 1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： HEAD │ │ ▼ master │ │ ▼ ┌───┐ ┌─▶│ │ ┌───┐ ┌───┐ ┌───┐ │ └───┘ │ │───▶│ │───▶│ │──┤ └───┘ └───┘ └───┘ │ ┌───┐ └─▶│ │ └───┘ ▲ │ │ feature1 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： $ git merge feature1 Auto-merging readme.txt CONFLICT (content): Merge conflict in readme.txt Automatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： $ git status On branch master Your branch is ahead of 'origin/master' by 2 commits. (use \"git push\" to publish your local commits) You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge) Unmerged paths: (use \"git add ...\" to mark resolution) both modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 我们可以直接查看readme.txt的内容： Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. >>>>>> feature1 Git用，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存： Creating a new branch is quick and simple. 再提交： $ git add readme.txt $ git commit -m \"conflict fixed\" [master cf810e4] conflict fixed 现在，master分支和feature1分支变成了下图所示： HEAD │ │ ▼ master │ │ ▼ ┌───┐ ┌───┐ ┌─▶│ │───▶│ │ ┌───┐ ┌───┐ ┌───┐ │ └───┘ └───┘ │ │───▶│ │───▶│ │──┤ ▲ └───┘ └───┘ └───┘ │ ┌───┐ │ └─▶│ │──────┘ └───┘ ▲ │ │ feature1 用带参数的git log也可以看到分支的合并情况： $ git log --graph --pretty=oneline --abbrev-commit * cf810e4 (HEAD -> master) conflict fixed |\\ | * 14096d0 (feature1) AND simple * | 5dc6824 & simple |/ * b17d20e branch test * d46f35e (origin/master) remove test.txt * b84166e add test.txt * 519219b git tracks changes * e43a48b understand how stage works * 1094adb append GPL * e475afc add distributed * eaadf4e wrote a readme file 最后，删除feature1分支： $ git branch -d feature1 Deleted branch feature1 (was 14096d0). 工作完成。 2 小结 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log --graph命令可以看到分支合并图。 4.3 分支管理策略 1 分支管理策略 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下--no-ff方式的git merge： 首先，仍然创建并切换dev分支： $ git switch -c dev Switched to a new branch 'dev' 修改readme.txt文件，并提交一个新的commit： $ git add readme.txt $ git commit -m \"add merge\" [dev f52c633] add merge 1 file changed, 1 insertion(+) 现在，我们切换回master： $ git switch master Switched to branch 'master' 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： $ git merge --no-ff -m \"merge with no-ff\" dev Merge made by the 'recursive' strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： $ git log --graph --pretty=oneline --abbrev-commit * e1e9c68 (HEAD -> master) merge with no-ff |\\ | * f52c633 (dev) add merge |/ * cf810e4 conflict fixed ... 可以看到，不使用Fast forward模式，merge后就像这样： 2 分支策略 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 3 小结 Git分支十分强大，在团队开发中应该充分应用。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 4.4 Bug分支 1 Bug分支 软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它。但是，等等，当前正在dev上进行的工作还没有提交： $ git status On branch dev Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: hello.py Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： $ git stash Saved working directory and index state WIP on dev: f52c633 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： $ git checkout master Switched to branch 'master' Your branch is ahead of 'origin/master' by 6 commits. (use \"git push\" to publish your local commits) $ git checkout -b issue-101 Switched to a new branch 'issue-101' 现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交： $ git add readme.txt $ git commit -m \"fix bug 101\" [issue-101 4c805e2] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： $ git switch master Switched to branch 'master' Your branch is ahead of 'origin/master' by 6 commits. (use \"git push\" to publish your local commits) $ git merge --no-ff -m \"merged bug fix 101\" issue-101 Merge made by the 'recursive' strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！ $ git switch dev Switched to branch 'dev' $ git status On branch dev nothing to commit, working tree clean 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： $ git stash list stash@{0}: WIP on dev: f52c633 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： $ git stash pop On branch dev Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: hello.py Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt Dropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a) 再用git stash list查看，就看不到任何stash内容了： $ git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： $ git stash apply stash@{0} 在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。 那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？ 有木有更简单的方法？ 有！ 同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。 为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支： $ git branch * dev master $ git cherry-pick 4c805e2 [master 1d4b803] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) Git自动给dev分支做了一次提交，注意这次提交的commit是1d4b803，它并不同于master的4c805e2。因为这两个commit只是改动相同，但确实是两个不同的commit。用git cherry-pick，我们就不需要在dev分支上手动再把修bug的过程重复一遍。 有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要git stash命令保存现场，才能从dev分支切换到master分支。 2 小结 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug。修复后，再git stash pop，回到工作现场； 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 4.5 Feature分支 1 Feature分支 软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了。所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： $ git switch -c feature-vulcan Switched to a new branch 'feature-vulcan' 5分钟后，开发完毕： $ git add vulcan.py $ git status On branch feature-vulcan Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: vulcan.py $ git commit -m \"add feature vulcan\" [feature-vulcan 287773e] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py 切回dev，准备合并： $ git switch dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是！ 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： $ git branch -d feature-vulcan error: The branch 'feature-vulcan' is not fully merged. If you are sure you want to delete it, run 'git branch -D feature-vulcan'. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。 现在我们强行删除： $ git branch -D feature-vulcan Deleted branch feature-vulcan (was 287773e). 终于删除成功！ 2 小结 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 4.6 多人协作 1 多人协作 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了。并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： $ git remote origin 或者，用git remote -v显示更详细的信息： $ git remote -v origin git@github.com:michaelliao/learngit.git (fetch) origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 2 推送分支 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： $ git push origin master 如果要推送其他分支，比如dev，就改成： $ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 3 抓取分支 多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： $ git clone git@github.com:michaelliao/learngit.git Cloning into 'learngit'... remote: Counting objects: 40, done. remote: Compressing objects: 100% (21/21), done. remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0 Receiving objects: 100% (40/40), done. Resolving deltas: 100% (14/14), done. 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： $ git branch * master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： $ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： $ git add env.txt $ git commit -m \"add env\" [dev 7a5e5dd] add env 1 file changed, 1 insertion(+) create mode 100644 env.txt $ git push origin dev Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git f52c633..7a5e5dd dev -> dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： $ cat env.txt env $ git add env.txt $ git commit -m \"add new env\" [dev 7bd91f1] add new env 1 file changed, 1 insertion(+) create mode 100644 env.txt $ git push origin dev To github.com:michaelliao/learngit.git ! [rejected] dev -> dev (non-fast-forward) error: failed to push some refs to 'git@github.com:michaelliao/learngit.git' hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： $ git pull There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details. git pull If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/ dev git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接。根据提示，设置dev和origin/dev的链接： $ git branch --set-upstream-to=origin/dev dev Branch 'dev' set up to track remote branch 'dev' from 'origin'. 再pull： $ git pull Auto-merging env.txt CONFLICT (add/add): Merge conflict in env.txt Automatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： $ git commit -m \"fix env conflict\" [dev 57c53ab] fix env conflict $ git push origin dev Counting objects: 6, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done. Total 6 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git 7a5e5dd..57c53ab dev -> dev 因此，多人协作的工作模式通常是这样： 1 首先，可以试图用git push origin 推送自己的修改；2 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；3 如果合并有冲突，则解决冲突，并在本地提交；4 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to origin/。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 4 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 4.7 Rebase 1 Rebase 在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。 每次合并再push后，分支变成了这样： $ git log --graph --pretty=oneline --abbrev-commit * d1be385 (HEAD -> master, origin/master) init hello * e5e69f1 Merge branch 'dev' |\\ | * 57c53ab (origin/dev, dev) fix env conflict | |\\ | | * 7a5e5dd add env | * | 7bd91f1 add new env | |/ * | 12a631b merged bug fix 101 |\\ \\ | * | 4c805e2 fix bug 101 |/ / * | e1e9c68 merge with no-ff |\\ \\ | |/ | * f52c633 add merge |/ * cf810e4 conflict fixed 总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？ 其实是可以做到的！ Git有一种称为rebase的操作，有人把它翻译成“变基”。 先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。 在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看： $ git log --graph --pretty=oneline --abbrev-commit * 582d922 (HEAD -> master) add author * 8875536 add comment * d1be385 (origin/master) init hello * e5e69f1 Merge branch 'dev' |\\ | * 57c53ab (origin/dev, dev) fix env conflict | |\\ | | * 7a5e5dd add env | * | 7bd91f1 add new env ... 注意到Git用(HEAD -> master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。 现在我们尝试推送本地分支： $ git push origin master To github.com:michaelliao/learngit.git ! [rejected] master -> master (fetch first) error: failed to push some refs to 'git@github.com:michaelliao/learngit.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下： $ git pull remote: Counting objects: 3, done. remote: Compressing objects: 100% (1/1), done. remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0 Unpacking objects: 100% (3/3), done. From github.com:michaelliao/learngit d1be385..f005ed4 master -> origin/master * [new tag] v1.0 -> v1.0 Auto-merging hello.py Merge made by the 'recursive' strategy. hello.py | 1 + 1 file changed, 1 insertion(+) 再用git status看看状态： $ git status On branch master Your branch is ahead of 'origin/master' by 3 commits. (use \"git push\" to publish your local commits) nothing to commit, working tree clean 加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。 用git log看看： $ git log --graph --pretty=oneline --abbrev-commit * e0ea545 (HEAD -> master) Merge branch 'master' of github.com:michaelliao/learngit |\\ | * f005ed4 (origin/master) set exit=1 * | 582d922 add author * | 8875536 add comment |/ * d1be385 init hello ... 对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？ 有！ 什么问题？ 不好看！ 有没有解决方法？ 有！ 这个时候，rebase就派上了用场。我们输入命令git rebase试试： $ git rebase First, rewinding head to replay your work on top of it... Applying: add comment Using index info to reconstruct a base tree... M hello.py Falling back to patching base and 3-way merge... Auto-merging hello.py Applying: add author Using index info to reconstruct a base tree... M hello.py Falling back to patching base and 3-way merge... Auto-merging hello.py 输出了一大堆操作，到底是啥效果？再用git log看看： $ git log --graph --pretty=oneline --abbrev-commit * 7e61ed4 (HEAD -> master) add author * 3611cfe add comment * f005ed4 (origin/master) set exit=1 * d1be385 init hello ... 原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的。但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。 这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。 最后，通过push操作把本地分支推送到远程： Mac:~/learngit michael$ git push origin master Counting objects: 6, done. Delta compression using up to 4 threads. Compressing objects: 100% (5/5), done. Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done. Total 6 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), completed with 1 local object. To github.com:michaelliao/learngit.git f005ed4..7e61ed4 master -> master 再用git log看看效果： $ git log --graph --pretty=oneline --abbrev-commit * 7e61ed4 (HEAD -> master, origin/master) add author * 3611cfe add comment * f005ed4 set exit=1 * d1be385 init hello ... 远程分支的提交历史也是一条直线。 2 小结 rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 5 标签管理 1 标签管理 发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 Git有commit，为什么还要引入tag？ “请把上周一的那个版本打包发布，commit号是6a5819e...” “一串乱七八糟的数字不好找！” 如果换一个办法： “请把上周一的那个版本打包发布，版本号是v1.2” “好的，按照tag v1.2查找commit就行！” 所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 5.1 创建标签 1 创建标签 在Git中打标签非常简单，首先，切换到需要打标签的分支上： $ git branch * dev master $ git checkout master Switched to branch 'master' 然后，敲命令git tag 就可以打一个新标签： $ git tag v1.0 可以用命令git tag查看所有标签： $ git tag v1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： $ git log --pretty=oneline --abbrev-commit 12a631b (HEAD -> master, tag: v1.0, origin/master) merged bug fix 101 4c805e2 fix bug 101 e1e9c68 merge with no-ff f52c633 add merge cf810e4 conflict fixed 5dc6824 & simple 14096d0 AND simple b17d20e branch test d46f35e remove test.txt b84166e add test.txt 519219b git tracks changes e43a48b understand how stage works 1094adb append GPL e475afc add distributed eaadf4e wrote a readme file 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令： $ git tag v0.9 f52c633 再用命令git tag查看标签： $ git tag v0.9 v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show 查看标签信息： $ git show v0.9 commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9) Author: Michael Liao Date: Fri May 18 21:56:54 2018 +0800 add merge diff --git a/readme.txt b/readme.txt ... 可以看到，v0.9确实打在add merge这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： $ git tag -a v0.1 -m \"version 0.1 released\" 1094adb 用命令git show 可以看到说明文字： $ git show v0.1 tag v0.1 Tagger: Michael Liao Date: Fri May 18 22:48:43 2018 +0800 version 0.1 released commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1) Author: Michael Liao Date: Fri May 18 21:06:15 2018 +0800 append GPL diff --git a/readme.txt b/readme.txt ... 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 2 小结 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m \"blablabla...\"可以指定标签信息； 命令git tag可以查看所有标签。 5.2 操作标签 1 操作标签 如果标签打错了，也可以删除： $ git tag -d v0.1 Deleted tag 'v0.1' (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin ： $ git push origin v1.0 Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v1.0 -> v1.0 或者，一次性推送全部尚未推送到远程的本地标签： $ git push origin --tags Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v0.9 -> v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： $ git tag -d v0.9 Deleted tag 'v0.9' (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下： $ git push origin :refs/tags/v0.9 To github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 2 小结 命令git push origin 可以推送一个本地标签到远程； 命令git push origin --tags可以推送全部未推送过的本地标签到远程； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 6 使用Github 1 使用Github 我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。 在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的。因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。 但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。 如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone： git clone git@github.com:michaelliao/bootstrap.git 一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。 Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样： ┌─ GitHub ────────────────────────────────────┐ │ │ │ ┌─────────────────┐ ┌─────────────────┐ │ │ │ twbs/bootstrap │────>│ my/bootstrap │ │ │ └─────────────────┘ └─────────────────┘ │ │ ▲ │ └──────────────────────────────────┼──────────┘ ▼ ┌─────────────────┐ │ local/bootstrap │ └─────────────────┘ 如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。 如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。 如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：https://github.com/michaelliao/learngit，创建一个`your-github-id.txt`的文本文件，写点自己学习Git的心得，然后推送一个pull request给我，我会视心情而定是否接受。 2 小结 在GitHub上，可以任意Fork开源仓库； 自己拥有Fork后的仓库的读写权限； 可以推送pull request给官方仓库来贡献代码。 7 使用Gitee 1 使用Gitee 使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。 如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——Gitee（gitee.com）。 和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。 Gitee的免费版本也提供私有库功能，只是有5人的成员上限。 Gitee企业版正在优惠中： 买1年送1个月：优惠码lhkYPzFJ 买2年送3个月：优惠码YGyEBFZC 买3年送6个月：优惠码qBNwfvET Gitee企业版专属购买通道 >> 小提示：记得先复制优惠码信息，在购买页面输入优惠码即可。 使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -> 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去： 点击“确定”即可完成并看到刚才添加的Key： 如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？ 首先，我们在Gitee上创建一个新的项目，选择右上角用户头像 -> 菜单“控制面板”，然后点击“创建项目”： 项目名称最好与本地库保持一致： 然后，我们在本地库上使用命令git remote add把它和Gitee的远程库关联： git remote add origin git@gitee.com:liaoxuefeng/learngit.git 之后，就可以正常地用git push和git pull推送了！ 如果在使用命令git remote add时报错： git remote add origin git@gitee.com:liaoxuefeng/learngit.git fatal: remote origin already exists. 这说明本地库已经关联了一个名叫origin的远程库，此时，可以先用git remote -v查看远程库信息： git remote -v origin git@github.com:michaelliao/learngit.git (fetch) origin git@github.com:michaelliao/learngit.git (push) 可以看到，本地库已经关联了origin的远程库，并且，该远程库指向GitHub。 我们可以删除已有的GitHub远程库： git remote rm origin 再关联Gitee的远程库（注意路径中需要填写正确的用户名）： git remote add origin git@gitee.com:liaoxuefeng/learngit.git 此时，我们再查看远程库信息： git remote -v origin git@gitee.com:liaoxuefeng/learngit.git (fetch) origin git@gitee.com:liaoxuefeng/learngit.git (push) 现在可以看到，origin已经被关联到Gitee的远程库了。通过git push命令就可以把本地库推送到Gitee上。 有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联Gitee呢？ 答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。 使用多个远程库时，我们要注意，git给远程库起的默认名称是origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。 仍然以learngit本地库为例，我们先删除已关联的名为origin的远程库： git remote rm origin 然后，先关联GitHub的远程库： git remote add github git@github.com:michaelliao/learngit.git 注意，远程库的名称叫github，不叫origin了。 接着，再关联Gitee的远程库： git remote add gitee git@gitee.com:liaoxuefeng/learngit.git 同样注意，远程库的名称叫gitee，不叫origin。 现在，我们用git remote -v查看远程库信息，可以看到两个远程库： git remote -v gitee git@gitee.com:liaoxuefeng/learngit.git (fetch) gitee git@gitee.com:liaoxuefeng/learngit.git (push) github git@github.com:michaelliao/learngit.git (fetch) github git@github.com:michaelliao/learngit.git (push) 如果要推送到GitHub，使用命令： git push github master 如果要推送到Gitee，使用命令： git push gitee master 这样一来，我们的本地库就可以同时与多个远程库互相同步： ┌─────────┐ ┌─────────┐ │ GitHub │ │ Gitee │ └─────────┘ └─────────┘ ▲ ▲ └─────┬─────┘ │ ┌─────────────┐ │ Local Repo │ └─────────────┘ Gitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：https://gitee.com/liaoxuefeng/learngit，创建一个your-gitee-id.txt的文本文件， 写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在Gitee和GitHub做双向同步。 8 自定义Git 1 自定义Git 在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。 比如，让Git显示颜色，会让命令输出看起来更醒目： $ git config --global color.ui true 这样，Git会适当地显示不同的颜色，比如git status命令： 文件名就会标上颜色。 我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。 8.1 忽略特殊文件 1 忽略特殊文件 有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files ...，有强迫症的童鞋心里肯定不爽。 好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 注意：.gitignore文件本身应该提交给Git管理，这样可以确保所有人在同一项目下都使用相同的.gitignore文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 1 忽略操作系统自动生成的文件，比如缩略图等； 2 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 3 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 举个例子： 假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件了。如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件： # Windows: Thumbs.db ehthumbs.db Desktop.ini 然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录： # Python: *.py[cod] *.so *.egg *.egg-info dist build 加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下： # Windows: Thumbs.db ehthumbs.db Desktop.ini # Python: *.py[cod] *.so *.egg *.egg-info dist build # My configurations: db.ini deploy_key_rsa 最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。 使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。 有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了： $ git add App.class The following paths are ignored by one of your .gitignore files: App.class Use -f if you really want to add them. 如果你确实想添加该文件，可以用-f强制添加到Git： $ git add -f App.class 或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查： $ git check-ignore -v App.class .gitignore:3:*.class App.class Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。 还有些时候，当我们编写了规则排除了部分文件时： # 排除所有.开头的隐藏文件: .* # 排除所有.class文件: *.class 但是我们发现.*这个规则把.gitignore也排除了，并且App.class需要被添加到版本库，但是被*.class规则排除了。 虽然可以用git add -f强制添加进去，但有强迫症的童鞋还是希望不要破坏.gitignore规则，这个时候，可以添加两条例外规则： # 排除所有.开头的隐藏文件: .* # 排除所有.class文件: *.class # 不排除.gitignore和App.class: !.gitignore !App.class 把指定文件排除在.gitignore规则外的写法就是!+文件名，所以，只需把例外文件添加进去即可。 可以通过https://gitignore.itranswarp.com在线生成.gitignore文件。 2 小结 忽略某些文件时，需要编写.gitignore； .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ 8.2 配置别名 1 配置别名 有没有经常敲错命令？比如git status？status这个单词真心不好记。 如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。 我们只需要敲一行命令，告诉Git，以后st就表示status： $ git config --global alias.st status 好了，现在敲git st看看效果。 当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch： $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch 以后提交就可以简写成： $ git ci -m \"bala bala bala...\" --global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。 在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名： $ git config --global alias.unstage 'reset HEAD' 当你敲入命令： $ git unstage test.py 实际上Git执行的是： $ git reset HEAD test.py 配置一个git last，让其显示最后一次提交信息： $ git config --global alias.last 'log -1' 这样，用git last就能显示最近一次的提交： $ git last commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2 Merge: bd6ae48 291bea8 Author: Michael Liao Date: Thu Aug 22 22:49:22 2013 +0800 merge & fix hello.py 甚至还有人丧心病狂地把lg配置成了： git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit\" 来看看git lg的效果： 为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！ 2 配置文件 配置Git的时候，加上--global是针对当前用户起作用的。如果不加，那只针对当前的仓库起作用。 配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中： $ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [remote \"origin\"] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master [alias] last = log -1 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中： $ cat .gitconfig [alias] co = checkout ci = commit br = branch st = status [user] name = Your Name email = your@email.com 配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 3 小结 给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。 8.3 搭建Git服务器 1 搭建Git服务器 在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。 GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。 搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。 假设你已经有sudo权限的用户账号，下面，正式开始安装。 第一步，安装git： $ sudo apt-get install git 第二步，创建一个git用户，用来运行git服务： $ sudo adduser git 第三步，创建证书登录： 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 第四步，初始化Git仓库： 先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令： $ sudo git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区。因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git： $ sudo chown -R git:git sample.git 第五步，禁用shell登录： 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行： git:x:1001:1001:,,,:/home/git:/bin/bash 改为： git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 第六步，克隆远程仓库： 现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行： $ git clone git@server:/srv/sample.git Cloning into 'sample'... warning: You appear to have cloned an empty repository. 剩下的推送就简单了。 2 管理公钥 如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。 这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。 3 管理权限 有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。 这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。 4 小结 搭建Git服务器非常简单，通常10分钟即可完成； 要方便管理公钥，用Gitosis； 要像SVN那样变态地控制权限，用Gitolite。 9 使用SourceTree 1 使用SourceTree 当我们对Git的提交、分支已经非常熟悉，可以熟练使用命令操作Git后，再使用GUI工具，就可以更高效。 Git有很多图形界面工具，这里我们推荐SourceTree，它是由Atlassian开发的免费Git图形界面工具，可以操作任何Git库。 首先从官网下载SourceTree并安装，然后直接运行SourceTree。 第一次运行SourceTree时，SourceTree并不知道我们的Git库在哪。如果本地已经有了Git库，直接从资源管理器把文件夹拖拽到SourceTree上，就添加了一个本地Git库： 也可以选择“New”-“Clone from URL”直接从远程克隆到本地。 2 提交 我们双击learngit这个本地库，SourceTree会打开另一个窗口，展示这个Git库的当前所有分支以及文件状态。选择左侧面板的“WORKSPACE”-“File status”，右侧会列出当前已修改的文件（Unstaged files）： 选中某个文件，该文件就自动添加到“Staged files”，实际上是执行了git add README.md命令： 然后，我们在下方输入Commit描述，点击“Commit”，就完成了一个本地提交： 实际上是执行了git commit -m \"update README.md\"命令。 使用SourceTree进行提交就是这么简单，它的优势在于可以可视化地观察文件的修改，并以红色和绿色高亮显示。 3 分支 在左侧面板的“BRANCHES”下，列出了当前本地库的所有分支。当前分支会加粗并用○标记。要切换分支，我们只需要选择该分支，例如master，然后点击右键，在弹出菜单中选择“Checkout master”，实际上是执行命令git checkout master： 要合并分支，同样选择待合并分支，例如dev，然后点击右键，在弹出菜单中选择“Merge dev into master”，实际上是执行命令git merge dev： 4 推送 在SourceTree的工具栏上，分别有Pull和Push，分别对应命令git pull和git push，只需注意本地和远程分支的名称要对应起来，使用时十分简单。 注意到使用SourceTree时，我们只是省下了敲命令的麻烦，SourceTree本身还是通过Git命令来执行任何操作。如果操作失败，SourceTree会自动显示执行的Git命令以及错误信息，我们可以通过Git返回的错误信息知道出错的原因： 5 小结 使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便。 SourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。 10 期末总结 终于到了期末总结的时刻了！ 经过几天的学习，相信你对Git已经初步掌握。一开始，可能觉得Git上手比较困难，尤其是已经熟悉SVN的童鞋，没关系，多操练几次，就会越用越顺手。 Git虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。 友情附赠Git Cheat Sheet，建议打印出来备用： Git Cheat Sheet 现在告诉你Git的官方网站：http://git-scm.com，英文自我感觉不错的童鞋，可以经常去官网看看。 如果你学了Git后，工作效率大增，有更多的空闲时间健身看电影，那我的教学目标就达到了。 谢谢观看！new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/Git-2.html":{"url":"Markdown/Tools/Git-2.html","title":"2 Git常用指令","keywords":"","body":"Git常用指令 1 使用远程仓库 1 Git 全局设置 创建版本库之前，首先要进行 Git 全局设置。 因为使用了--global参数，这个设置一次即可，所有版本库都会使用这个参数 git config --global user.name \"Your Name\" git config --global user.email \"email@example.com\" 2 创建版本库第一步：创建空目录 cd ~ mkdir GitRepo 第二步：通过git init命令把这个目录变成 Git 可以管理的仓库 cd GitRepo git init 3 把文件添加到版本库 touch README.md git add README.md 4 提交文件到暂存库 git commit -m \"first commit\" 5 添加SSH Key第一步：创建SSH Key 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件。如果已经有了，可直接跳过此步骤。如果没有，打开终端，创建SSH Key： ssh-keygen -t rsa -C \"youremail@example.com\" 第二步：添加SSH Key 登陆GitHub，打开“Account settings”，“SSH Keys”页面。然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。点“Add Key”，你就应该看到已经添加的Key。 6 添加远程库第一步：新建仓库 登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库。在Repository name填入GitRepo，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。 第二步：关联远程仓库 把一个已有的本地仓库与远程仓库关联，把本地仓库的内容推送到GitHub仓库。在本地的GitRepo仓库下运行命令： git remote add origin git@github.com:YourGitRepoName/gitrepo.git 远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。后面的 URL 使用 HTTPS 或者 SSH 都可以，一般使用 SSH。 7 本地推送到远程执行完上述步骤，就可以把本地库的所有内容推送到远程库上： git push -u origin master 备注： 第一次推送时使用-u参数，用于将本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令，不使用-u参数 当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告。这是因为 Git 使用 SSH 连接，而 SSH 连接在第一次验证 GitHub 服务器的 Key 时，需要你确认 GitHub 的 Key 的指纹信息是否真的来自 GitHub 的服务器，输入yes回车即可。 8 拉取远程仓库内容语法：git pull : git pull origin next:master 9 查询和删除远程仓库查询远程仓库： git remote -v 删除远程仓库： git remote rm origin 10 从远程仓库克隆 mkdir RemoteRepo cd RemoteRepo git clone git@github.com:YourGitRepoName/RepoName.git 2 Git Cheat Sheet 1 GIT BASICS 命令 解释 git init 在指定的目录下创建一个空的 git repo。不带参数将在当前目录下创建一个 git repo。 git clone 克隆一个指定repo到本地。指定的可以是由 HTTP 或 SSH 指定的远程仓库路径或者本地文件系统。 git add 将指定目录的所有修改加入到下一次 commit 中。把 替换成 将添加指定文件的修改。 git commit -m \"\" 提交暂存区的修改，使用指定的 作为提交信息，而不是打开文本编辑器输入提交信息。 git status 显示哪些文件已被 staged、未被 staged 以及未跟踪 untracked。 git log 以缺省格式显示全部 commit 历史。更多自定义参数请参考后续部分。 repo 表示 仓库 2 GIT DIFF 命令 解释 git diff ⽐较⼯作区和暂存区的修改。 git diff HEAD ⽐较⼯作区和上⼀次 commit 后的修改。 git diff --cached ⽐较暂存区和上⼀次 commit 后的修改。 3 UNDOING CHANGEAS 命令 解释 git revert 对指定 创建⼀个 undo 的 commit，并应⽤到当前分⽀。 git reset 将 从暂存区移除，但保持⼯作区不变。此操作不会修改⼯作区的任何⽂件。 4 REWRITING GIT HISTORY 命令 解释 git commit -m --amend 将当前 staged 修改合并到最近⼀次的 commit 中。 git rebase 基于 对当前分⽀进⾏ rebase。 可以是 commit、分⽀名称、tag 或相对于 HEAD 的 commit。 git reflog 显示本地 repo 的所有 commit ⽇志。 5 GIT BRANCHES 命令 解释 git branch 显示本地 repo 的所有分⽀。 git switch -c 创建并切换到⼀个新的名为 的分⽀。去掉 -c 参数将切换到⼀个已有分⽀。 git merge 将指定 分⽀合并到当前分⽀。 6 REMOTE REPOSITORIES 命令 解释 git remote add 添加⼀个新的远程连接。添加后可使⽤ 作为指定 远程连接的名称。 git fetch 从指定 抓取指定 的所有 commit 到本地 repo。去掉 将抓取远程所有分⽀的修改。 git pull 从指定 抓取所有分⽀的 commit 并⽴刻合并到本地 repo。 git push 将本地指定 推送到指定远程 。如果远程没有对应的分⽀，将⾃动在远程创建此分⽀。 7 GIT CONFIG 命令 解释 git config --global user.name 配置当前⽤户名，使⽤--global参数将针对当前系统登录⽤户⽣效。 git config --global user.email 配置当前⽤户Email。 git config --global alias. 配置⼀个 git 命令的快捷⽅式。例如：配置”alias.glog log --graph --oneline”使”git glog”相当于”git log --graph --oneline”. git config --system core.editor 配置⽂本编辑器，例如vi，在必要时⾃动打开此⽂本编辑器。 git config --global --edit 打开当前⽤户的 git 全局配置并编辑。 8 GIT LOG 命令 解释 git log - 限制 log 的显示数量。例如：”git log -5” 仅显示最新 5 条 commit。 git log --oneline 每⾏显示⼀条commit。 git log --author=\"\" 按提交者名字搜索并显示 commit。 git log --grep=\"\" 按指定内容搜索并显示 commit。 git log .. 显示指定范围的 commit。范围参数可以是 commit ID、分⽀名称、HEAD或任意相对位置。 git log -- 仅显示包含指定⽂件修改的 commit。 git log --graph 使⽤--graph参数显示图形化的 branch 信息。 9 GIT RESET 命令 解释 git reset 移除所有暂存区的修改，但不会修改⼯作区。 git reset --hard 移除所有暂存区的修改，并强制删除所有⼯作区的修改。 git reset > 将当前分⽀回滚到指定 ，清除暂存区的修改，但保持⼯作区状态不变。 git reset --hard 将当前分⽀回滚到指定 ，清除暂存区的修改，并强制删除所有⼯作区的修改。 10 GIT REBASE 命令 解释 git rebase -i 以交互模式对当前分⽀做rebase。 11 GIT PULL 命令 解释 git pull --rebase 抓取所有远程分⽀，并以 rebase 模式并⼊本地 repo ⽽不是 merge。 12 GIT PUSH 命令 解释 git push --force 将本地分⽀推送到远程。不要使⽤--force参数，除⾮你完全明⽩此操作的后果。 git push --tags 使⽤ push 命令并不会⾃动将本地 tag 推送到远程。加上--tags参数会将所有本地 tag 推送到远程。 3 工作区、版本库和暂存区示意图 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/Git-3.html":{"url":"Markdown/Tools/Git-3.html","title":"3 Git疑难解答","keywords":"","body":"Git 疑难解答 1 git pull的用法 git pull命令用于从另一个存储库或本地分支获取并集成(整合)。git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式如下： git pull [options] [ […]] 常见格式： git pull : 1 描述 将远程存储库中的更改合并到当前分支中。在默认模式下，git pull是git fetch后跟git merge FETCH_HEAD的缩写。 更准确地说，git pull使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中。 使用–rebase，它运行git rebase而不是git merge。 2 示例 取回 origin 主机的 next 分支，与本地的 master 分支合并： git pull origin next:master 如果远程分支 next 要与当前分支合并，则冒号后面的部分可以省略: git pull origin next 上面命令表示，取回 origin/next 分支，再与当前分支合并。实质上，这等同于先做 git fetch，再执行 git merge。 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git也允许手动建立追踪关系。 git branch --set-upstream master origin/next 上面命令指定master分支追踪origin/next分支。如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名: git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”(remote-tracking branch)进行合并。 如果当前分支只有一个追踪分支，连远程主机名都可以省略: git pull 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用rebase模式，可以使用–rebase选项: git pull --rebase : 3 git fetch 和 git pull 的区别 git fetch：相当于是从远程获取最新版本到本地，不会自动合并。 git fetch origin master git log -p master..origin/master git merge origin/master 以上命令的含义： 首先从远程的origin的master主分支下载最新的版本到origin/master分支上，然后比较本地的master分支和origin/master分支的差别最后进行合并 git pull：相当于是从远程获取最新版本并merge到本地 git pull origin master 上述命令其实相当于git fetch 和 git merge。 在实际使用中，git fetch更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。 原文出自【易百教程】 原文链接：https://www.yiibai.com/git/git_pull.htmlnew Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/Markdown-1.html":{"url":"Markdown/Tools/Markdown-1.html","title":"1 Markdown基本语法","keywords":"","body":"Markdown 基本语法 Markdown官方教程： https://markdown.com.cn/ 1 标题 语法： # 一级标题 （快捷键Ctrl+1） ## 二级标题 （快捷键Ctrl+2） ### 三级标题 （快捷键Ctrl+3） #### 四级标题 （快捷键Ctrl+4） ##### 五级标题 （快捷键Ctrl+5） ###### 六级标题 （快捷键Ctrl+6） 执行效果： 2 段落 语法： 使用空白行将一行或多行文本进行分隔: 第一段: I really like using Markdown. 第二段: I think I'll use it to format all of my documents from now on. 执行效果：使用空白行将一行或多行文本进行分隔:第一段: I really like using Markdown. 第二段: I think I'll use it to format all of my documents from now on. 3 换行 语法1： 在一行末尾加两个空格后回车进行换行: 第一段: I really like using Markdown. 第二段: I think I'll use it to format all of my documents from now on. 执行效果：在一行末尾加两个空格后回车进行换行:第一段: I really like using Markdown.第二段: I think I'll use it to format all of my documents from now on. 语法2： 使用进行换行: 第一段: I really like using Markdown. 第二段: I think I'll use it to format all of my documents from now on. 执行效果：使用进行换行:第一段: I really like using Markdown. 第二段: I think I'll use it to format all of my documents from now on. 4 首行缩进 语法： 不同特殊占位符所占空白不一样大。 1 &emsp; 或 &#8195;  //全角 举例1： &emsp;&emsp;这是2个&emsp;字节的首行缩进效果 &#8195;&#8195;这是2个&#8195;字节的首行缩进效果 这是没有首行缩进效果 2 &ensp; 或 &#8194;  //半角 举例2： &ensp;&ensp; 这是2个&ensp;字节的首行缩进效果 &&#8194;&#8194;这是2个&#8194;字节的首行缩进效果 这是没有首行缩进效果 执行效果： 举例1：   这是2个&emsp;字节的首行缩进效果   这是2个&#8195;字节的首行缩进效果 这是没有首行缩进效果 举例2：   这是2个&ensp;字节的首行缩进效果   这是2个&#8194;字节的首行缩进效果 这是没有首行缩进效果 5 强调 语法： 1. 加粗 （快捷键Ctrl+B） 在单词或短语前后各加两个**星号**或下划线，__下划线__ 前后不能有字。 2. 斜体 （快捷键Ctrl+I） 在单词或短语前后各加一个*星号*或 _下划线_。 3. 斜体和加粗 在单词或短语的前后各添加三个 ***星号***或 ___下划线___。也可以进行组合，例如：**_A_** 或 __*B*__。 4. 删除 在单词或短语前后各加两个~~飘(Tab上面那个键)~~ 执行效果：1 加粗在单词或短语前后各加两个星号或下划线，下划线 前后不能有字。 2 斜体在单词或短语前后各加一个星号或 下划线。 3 斜体和加粗在单词或短语的前后各添加三个 星号或 下划线。也可以进行组合，例如：A 或 B。 4 删除 在单词或短语前后各加两个飘(Tab上面那个键) 6 引用 语法： 1. 块引用 在段落前添加一个 > 号，例如 >Dorothy followed her through many of the beautiful rooms in her castle. 2. 多个段落块引用 > Dorothy followed her through many of the beautiful rooms in her castle. > > The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 3. 嵌套块引用 >一级嵌套第一段 > >一级嵌套第二段 >>二级嵌套第一段 >> >>二级嵌套第二段 >> >>二级嵌套第三段 >> >>>三级嵌套第一段 >>>三级嵌套第二段 4. 带有其他语法的块引用 > #### The quarterly results look great! > > - Revenue was off the chart. > - Profits were higher than ever. > > *Everything* is going according to **plan**. 执行效果：1 块引用在段落前添加一个 > 号，例如 Dorothy followed her through many of the beautiful rooms in her castle. 2 多个段落块引用 Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 3 嵌套块引用 一级嵌套第一段 一级嵌套第二段 二级嵌套第一段 二级嵌套第二段 二级嵌套第三段 三级嵌套第一段三级嵌套第二段 4 带有其他语法的块引用 The quarterly results look great! Revenue was off the chart. Profits were higher than ever. Everything is going according to plan. 7 列表 语法： 1 有序列表 在列表前添加数字和英文句点，数字必须以1开头，后续不必按照顺序排列。 1. aaa 2. bbb 3. ccc 4. 789 2 无序列表 在列表前添加破折号(-)、(*)或(+)，缩进一个或多个列表项可以创建嵌套列表。 - aaa - bbb - ccc - ddd - eee - fff - ggg - hhh 3 列表中嵌套其他元素 3.1 嵌套段落 * 第一项 * 第二项 需要在第二项下加入其他项目 * 第三项 * 第四项 3.2 引用块 * 第一项 * 第二项 >引用块在第二个项下方 > > * 第三项 3.3 代码块 1. 第一步骤 2. 第二步骤，代码相关操作：（采用两个制表符缩进） Test 3. 第三步骤 4. 第四步骤 3.4 图片 1. 第一步骤 2. 第二步骤，图片相关操作： ![图片不显示时显示](相对路径 \"图片显示时鼠标悬停时显示名称\") 举例：![test picture](images/a.png \"Picture\") > 根据实操结果，markdown中的图片路径最好使用相对路径的方式，如果要引用其他文件夹的图片，需要使用相对路径表示法，表述出其他文件的路径信息，例如: \"../../\"这种方式 3. 第三步骤 3.5 列表 1. 第一项 2. 第二项 3. 第三项 - 缩进项目 - 缩进项目 4. 第四项 5. 第五项 4 任务列表 - [x] Java - [x] 大数据 - [ ] 人工智能 - [x] 机器学习 执行效果：1 有序列表在列表前添加数字和英文句点，数字必须以1开头，后续不必按照顺序排列。 aaa bbb ccc 789 2 无序列表在列表前添加破折号(-)、(*)或(+)，缩进一个或多个列表项可以创建嵌套列表。 aaa bbb ccc ddd eee fff ggg hhh 3 列表中嵌套其他元素3.1 嵌套段落 第一项 第二项需要在第二项下加入其他项目 第三项 第四项 3.2 引用块 第一项 第二项 引用块在第二个项下方 第三项 3.3 代码块 第一步骤 第二步骤，代码相关操作：（采用两个制表符缩进） Test 第三步骤 第四步骤 3.4 图片 第一步骤 第二步骤，图片相关操作： 举例： 根据实操结果，markdown中的图片路径最好使用相对路径的方式，如果要引用其他文件夹的图片，需要使用相对路径表示法，表述出其他文件的路径信息，例如: \"../../\"这种方式 第三步骤 3.5 列表 第一项 第二项 第三项 缩进项目 缩进项目 第四项 第五项 4 任务列表 [x] Java [x] 大数据 [ ] 人工智能 [x] 机器学习 8 代码 语法： 1. 反引号包裹代码 命令提示，`nano`类型 2. 转义反引号 代码的单词或短语中包含多个反引号时使用 ``Use `code` in Markdown file.`` 3. 代码块 3个反引号(```将以下代码填入此处```) Test 执行效果： 1 反引号包裹代码命令提示，nano类型 2 转义反引号代码的单词或短语中包含多个反引号时使用Use `code` in Markdown file. 3 代码块 Test 9 分割线 语法： 使用三个或多个星号(*)、破折号(-)或下划线(_)可创建分割线 *** --- ___ 执行效果：使用三个或多个星号(*)、破折号(-)或下划线(_)可创建分割线 10 链接 语法： 1. 语法代码 [超链接显示名](超链接地址 \"超链接title\") 超链接：[Markdown语法教学](https://markdown.com.cn \"Markdown语法教学链接\") 2. 网址和Email地址 使用尖括号将网址括起 3. 带格式化的链接 在链接语法前后加星号(*)，可以对链接进行加粗 在方括号中加反引号，可将链接表示为代码 Markdown指引网站 **[Markdown Guide](https://www.markdownguide.org)**。 代码链接[`code`](https://eff.org) 执行效果：1 语法代码超链接显示名超链接：Markdown语法教学 2 网址和Email地址 使用尖括号将网址括起https://markdown.com.cnfake@example.com 3 带格式化的链接在链接语法前后加星号(**)，可以对链接进行加粗Markdown指引网站 Markdown Guide。在方括号中加反引号，可将链接表示为代码代码链接code 11 图片 语法： 1. 本地图片连接 ![替代文本](图片相对路径 \"图片title\") ![picture](images/a.png \"1\") 2. 网络图片链接 ![picture2](https://img0.baidu.com/it/u=2767790527,3674585198&fm=253&fmt=auto&app=138&f=JPEG?w=667&h=500\"Shiprock\") 执行效果：1 本地图片连接 2 网络图片链接 12 表格 语法： 默认左对齐 - | 表头1 | 表头2 | | - | - | | 1行1列 | 1行2列 | | 2行1列 | 2行2列 | 表格行和列还可以扩展，格式相同 居中对齐 :-: | 表头1 | 表头2 | | :-: | :-: | | 1行1列 | 1行2列 | | 2行1列 | 2行2列 | 右对齐 -: | 表头1 | 表头2 | | -: | -: | | 1行1列 | 1行2列 | | 2行1列 | 2行2列 | 执行效果： 默认左对齐 - 表头1 表头2 1行1列 1行2列 2行1列 2行2列 表格行和列还可以扩展，格式相同 居中对齐 :-: 表头1 表头2 1行1列 1行2列 2行1列 2行2列 右对齐 -: 表头1 表头2 1行1列 1行2列 2行1列 2行2列 13 转义字符 语法： Markdown中的转义字符为\\，转义的有： \\\\ 反斜杠 \\` 反引号 \\* 星号 \\_ 下划线 \\{\\} 大括号 \\[\\] 中括号 \\(\\) 小括号 \\# 井号 \\+ 加号 \\- 减号 \\. 英文句号 \\! 感叹号 执行效果： \\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句号 ! 感叹号 14 字体、字号、颜色 语法： 我是黑体字 我是微软雅黑 我是华文彩云 黑体 gray null 执行效果： 我是黑体字 我是微软雅黑 我是华文彩云 黑体 gray null new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/Markdown-2.html":{"url":"Markdown/Tools/Markdown-2.html","title":"2 Markdown数学公式","keywords":"","body":"Markdown 使用LaTeX插入数学公式 [info] 说明 此网页不支持渲染LaTeX公式，但Markdown是支持的，在Markdown中直接使用算式对应的内容，即可看到公式. 1 LaTeX编辑数学公式基本语法元素 ​LaTeX中的数学模式有两种形式:inline (行内公式)和 display(块间公式)。前者是指在正文插入行间数学公式, 后者独立排列, 可以有或没有编号。 行间公式(inline):用$...$将公式括起来。 块间公式(displayed)，用$$...$$将公式括起来是无编号的形式，块间元素默认是居中显示的。 2 公式语法 1 上/下标 算式 语法 $x2$ x^2 $y1$​ y_1 注意：若上/下标的内容超过一个字符，则内容需要使用花括号括起来，下同 例如： $x^2+y_0+y_{n+1}$ 执行效果为： $x^2+y0+y{n+1}$ 2 分式 算式 语法 $1/2$ 1/2 $\\frac{1}{2}$​ \\frac{1}{2} 例如： $1/2+\\frac{y+x}{2}+(x+y)/2$ 执行效果为： $1/2+\\frac{y+x}{2}+(x+y)/2$ 3 开方 算式 语法 $\\sqrt{2}$ \\sqrt{2} $\\sqrt[3]{2}$​ \\sqrt[3]{2} 4 累加累乘 算式 语法 $\\sum{a}$ \\sum{a} $\\sum_{n=1}^{100}{a_n}$​ \\sum_{n=1}^{100}{a_n} $\\sum\\limits_{n=1}^{100}{a_n}$ \\sum\\limits_{n=1}^{100}{a_n} $\\prod{x} $​ \\prod{x} $\\prod_{n=1}^{99}{x_n}$ \\prod_{n=1}^{99}{x_n} $\\prod\\limits_{n=1}^{99}{x_n} $​ \\prod\\limits_{n=1}^{99}{x_n} 注意：仅当行内公式时，需要使用\\limits调整下标位置，公式块对一些符号默认上下标在最上下面，因此不需要使用\\limits，下同 举例： $$\\prod_{n=1}^{99}{x_n}$$ 执行效果为： $$\\prod_{n=1}^{99}{x_n}$$ 5 积分 算式 语法 $\\int_0^1f(x)dx$ \\int_0^1f(x)dx 6 极限 算式 语法 $\\lim_{n\\rightarrow\\infty}{n}$ \\lim_{n\\rightarrow\\infty}{n} $\\lim\\limits_{n\\rightarrow\\infty}{n}$ \\lim\\limits_{n\\rightarrow\\infty}{n} 7 对数 算式 语法 $\\ln{x}$ \\ln{x} $\\lg{x}$ \\lg{x} $\\log_a{x}$ \\log_a{x} 8 希腊字母 大写 语法 小写 语法 $A$ A $\\alpha $ \\alpha $B$ B $\\beta $ \\beta $ \\Gamma $ \\Gamma $ \\gamma$ \\gamma $\\Delta$ \\Delta $\\delta$ \\delta $E$ E $ \\epsilon$ \\epsilon $\\varepsilon $ \\varepsilon $Z$ Z $ \\zeta$ \\zeta $H$ H $\\eta $ \\eta $\\Theta$ \\Theta $\\theta $ \\theta $I $ I $\\iota $ \\iota $K$ K $ \\kappa$ \\kappa $\\Lambda$ \\Lambda $ \\lambda$ \\lambda $M$ M $\\mu $ \\mu $N$ N $\\nu $ \\nu $\\Xi$ \\Xi $ \\xi$ \\xi $O$ O $ \\omicron$ \\omicron $\\Pi$ \\Pi $ \\pi$ \\pi $P$ P $\\rho $ \\rho $\\Sigma$ \\Sigma $\\sigma $ \\sigma $T$ T $\\tau $ \\tau $\\Upsilon$ \\Upsilon $ \\upsilon$ \\upsilon $\\Phi$ \\Phi $ \\phi$ \\phi $ \\varphi$ \\varphi $X$ X $ \\chi$ \\chi $\\Psi$ \\Psi $\\psi $ \\psi $\\Omega$ \\Omega $ \\omega$ \\omega 9 三角函数 算式 语法 $\\sin{x} $ \\sin{x} $\\cos{x} $ \\cos{x} $ \\tan{x} $ \\tan{x} $\\arcsin{x}$ \\arcsin{x} $\\arccos{x} $ \\arccos{x} $\\arctan{x}$ \\arctan{x} 10 运算符 算式 语法 $\\pm $ \\pm $\\times $ \\times $ \\cdot $ \\cdot $\\div$ \\div $\\neq $ \\neq $\\equiv$ \\equiv $\\leq$ \\leq $\\geq$ \\geq $\\approx$ \\approx 11 特殊字符 算式 语法 $ \\forall $ \\forall $\\exists $ \\exists $ \\infty$ \\infty $\\emptyset$ \\emptyset $\\cdots $ \\cdots $\\nabla$ \\nabla $\\bot$ \\bot $\\angle$ \\angle $\\because$ \\because $\\therefore$ \\therefore 空格 \\quad $\\approx$ \\approx $360^\\circ$ 360^\\circ $\\in$ \\in $\\notin$ \\notin ${$ { $}$ } 12 箭头 算式 语法 $ \\uparrow $ \\uparrow $\\downarrow $ \\downarrow $\\Uparrow $ \\Uparrow $ \\Downarrow$ \\Downarrow $\\updownarrow$ \\updownarrow $\\Updownarrow $ \\Updownarrow $\\rightarrow$ \\rightarrow $\\leftarrow$ \\leftarrow $\\Rightarrow$ \\Rightarrow $\\Leftarrow$ \\Leftarrow $\\leftrightarrow$ \\leftrightarrow $\\Leftrightarrow$ \\Leftrightarrow $\\longrightarrow$ \\longrightarrow $\\longleftarrow$ \\longleftarrow $\\Longrightarrow$ \\Longrightarrow $\\Longleftarrow$ \\Longleftarrow $\\longleftrightarrow$ \\longleftrightarrow $\\Longleftrightarrow$ \\Longleftrightarrow 13 上\\下花括号 算式 语法 $ \\overbrace{a+b+\\dots+n}^{m个} $ \\overbrace{a+b+\\dots+n}^{m个} $\\underbrace{a+b+\\dots+n}_{m个} $ \\underbrace{a+b+\\dots+n}_{m个} 14 分段函数\\方程组 语法： \\left左符号(左符号'.'表示省略，下同) \\begin{cases} 第一行\\\\(其中，\\\\是换行，下同) 第二行\\\\ ... \\end{cases} \\right右符号(若左符号和右符号都为'.'，则\\left\\right可以省略) 举例： $$ \\left. \\begin{cases} a_1x+b_1y+c_1z=d_1\\\\ a_2x+b_2y+c_2z=d_2\\\\ a_3x+b_3y+c_3z=d_3 \\end{cases} \\right\\} \\Rightarrow \\begin{cases} x=z=1\\\\ y=2 \\end{cases} $$ 执行效果： $$ \\left. \\begin{cases} a_1x+b_1y+c_1z=d_1\\ a_2x+b_2y+c_2z=d_2\\ a_3x+b_3y+c_3z=d_3 \\end{cases} \\right} \\Rightarrow \\begin{cases} x=z=1\\ y=2 \\end{cases} $$ 15 连等式 语法： \\begin{align} 第一行左式 &= 第一行右式\\\\ 第二行左式 &= 第二行右式\\\\ ... \\end{align} 举例： $$ \\begin{align} f(x) &= x^2+2x+1\\\\ &=(x+1)^2 \\end{align} $$ 执行效果： $$ \\begin{align} f(x) &= x^2+2x+1\\ &=(x+1)^2 \\end{align} $$ 16 矩阵 语法： \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}\\\\ \\begin{matrix} 0 & 1 \\\\ 1 & 0 \\end{matrix}\\\\ \\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix}\\\\ \\begin{Bmatrix} 1 & 0 \\\\ 0 & -1 \\end{Bmatrix}\\\\ \\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix}\\\\ \\begin{Vmatrix} i & 0 \\\\ 0 & -i \\end{Vmatrix} 执行效果： $$ \\begin{bmatrix} 0 & -1 \\ 1 & 0 \\end{bmatrix}\\ \\begin{matrix} 0 & 1 \\ 1 & 0 \\end{matrix}\\ \\begin{pmatrix} 0 & -i \\ i & 0 \\end{pmatrix}\\ \\begin{Bmatrix} 1 & 0 \\ 0 & -1 \\end{Bmatrix}\\ \\begin{vmatrix} a & b \\ c & d \\end{vmatrix}\\ \\begin{Vmatrix} i & 0 \\ 0 & -i \\end{Vmatrix} $$new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/Cmake-1.html":{"url":"Markdown/Tools/Cmake-1.html","title":"3 Cmake","keywords":"","body":"Cmake CMake Practice（CMake 实践） -- Cjacker 为了阅读方便，本文档整理摘抄自互联网上的PDF版本，仅供学习参考使用。 PDF及练习参考代码：https://pan.baidu.com/s/14tSQq5ggZ4e1xCrCl_BUSw 提取码：6666 前言 cmake 已经开发了 5、6 年的时间，如果没有 KDE4，也许不会有人或者 Linux 发行版本重视 cmake，因为除了 Kitware 似乎没有人使用它。通过 KDE4 的选型和开发，cmake 逐渐进入了人们的视线，在实际的使用过程中，cmake 的优势也逐渐的被大家所认识，至少 KDE 的开发者们给予了 cmake 极高的评价，同时庞大的 KDE 项目使用 cmake 来作为构建工具也证明了 cmake 的可用性和大项目管理能力。 所以，cmake 应该感谢 KDE，也正因为如此，cmake 的开发者投入了 KDE 从 autotools 到 cmake 的迁移过程中，并相当快速和顺利的完成了迁移，现在整个 KDE4 开发版本全部使用 cmake 构建。 这也是促使我们学习 cmake 的原因，首先 cmake 被接受并成功应用，其次，cmake 的优势在实际使用中不断的体现出来。 我们为什么不来认识一下这款优秀的工程构建工具呢？ 在 2006 年 KDE 大会，听 cmake 开发者当面介绍了 cmake 之后，我就开始关注 cmake，并将 cmake 纳入了 Everest 发行版，作为系统默认组件。最近 QT-4.3 也正式进入了 Everest 系统，为 KDE4 构建完成了准备工作。 但是，在学习 cmake 的过程中，发现官方的文档非常的少，而且错误也较多，比如：在介绍 Find 模块编写的文档中，模块名称为 FOO，但是后面却出现了 Foo_FIND_QUIETLY 的定义，这显然是错误的，这样的定义永远不可能有效，正确的定义是 FOO_FIND_QUIETLY。种种原因，促使我开始写一份“面向使用和实用”的 cmake 文档，也就是本教程《cmake 实践》(Cmake Practice)。 本文档是边学习边编写的成果，更像是一个学习笔记和 Tutorial，因此难免有失误或者理解不够透彻的地方，比如，我仍然不能理解为什么绝大部分使用变量的情况要通过${}引用，而在 IF 语句中却必须直接使用变量名。也希望能够有 cmake 的高手来指点迷津。 补：从 cmake 的 maillist，我找到了一些答案，原文是： The IF(var)or IF(NOT var) command expects var to be the name of a variable. This is stated in CMake's manual. So, for your situation IF(${libX}) is the same as IF(/usr/lib/xorg) and then CMake will check the value of the variable named /usr/lib/xorg. 也就是说 IF 需要的是变量名而不是变量值。 这个文档是开放的，开放的目的是为了让更多的人能够读到并且能够修改，任何人都可以对它作出修改和补充，但是，为了大家都能够获得你关于 cmake 的经验和积累，如果你发现错误或者添加了新内容后，请务必 CC 给我一份，让我们共同把 cmake 掌握的更好。 一、初识 cmake CMake 不再使你在构建项目时郁闷地想自杀了。 --一位 KDE 开发者 1. 背景知识 cmake 是 kitware 公司以及一些开源开发者在开发几个工具套件(VTK)的过程中的衍生品，最终形成体系，成为一个独立的开放源代码的项目。项目的诞生时间是 2001 年。其官方网站是 www.cmake.org，可以通过访问官方网站获得更多关于 cmake 的信息。cmake 的流行其实要归功于 KDE4 的开发(似乎跟当年的 svn 一样，KDE 将代码仓库从 CVS 迁移到 SVN，同时证明了 SVN 管理大型项目的可用性)，在 KDE 开发者使用了近 10 年 autotools 之后，他们终于决定为 KDE4 选择一个新的工程构建工具，其根本原因用 KDE 开发者的话来说就是：只有少数几个“编译专家”能够掌握 KDE 现在的构建体系(admin/Makefile.common)。在经历了 unsermake， scons 以及 cmake 的选型和尝试之后，KDE4 决定使用 cmake 作为自己的构建系统。在迁移过程中，进展异常的顺利，并获得了 cmake 开发者的支持。所以，目前的 KDE4 开发版本已经完全使用 cmake 来进行构建。像 kdesvn，rosegarden 等项目也开始使用cmake，这也注定了 cmake 必然会成为一个主流的构建体系。 2. 特点 cmake 的特点主要有： 1 开放源代码，使用类 BSD 许可发布 http://cmake.org/HTML/Copyright.html 2 跨平台，并可生成 native 编译配置文件，在 Linux/Unix 平台，生成 makefile；在苹果平台，可以生成 xcode；在 Windows 平台，可以生成 MSVC 的工程文件。 3 能够管理大型项目，KDE4 就是最好的证明。 4 简化编译构建过程和编译过程。Cmake 的工具链非常简单：cmake+make。 5 高效虑，按照 KDE 官方说法，CMake 构建 KDE4 的 kdelibs 要比使用 autotools 来构建 KDE3.5.6 的 kdelibs 快 40%，主要是因为 Cmake 在工具链中没有 libtool。 6 可扩展，可以为 cmake 编写特定功能的模块，扩充 cmake 功能。 3. 问题，难道就没有问题？ 1 cmake 很简单，但绝对没有听起来或者想象中那么简单。 2 cmake 编写的过程实际上是编程的过程，跟以前使用 autotools 一样，不过你需要编写的是 CMakeLists.txt(每个目录一个)，使用的是”cmake 语言和语法”。 3 cmake 跟已有体系的配合并不是特别理想，比如 pkgconfig，您在实际使用中会有所体会，虽然有一些扩展可以使用，但并不理想。 4. 个人的建议 1 如果你没有实际的项目需求，那么看到这里就可以停下来了，因为 cmake 的学习过程就是实践过程，没有实践，读的再多几天后也会忘记。 2 如果你的工程只有几个文件，直接编写 Makefile 是最好的选择。 3 如果使用的是 C/C++/Java 之外的语言，请不要使用 cmake(至少目前是这样)。 4 如果你使用的语言有非常完备的构建体系，比如 java 的 ant，也不需要学习 cmake，虽然有成功的例子，比如 QT4.3 的 csharp 绑定 qyoto。 5 如果项目已经采用了非常完备的工程管理工具，并且不存在维护问题，没有必要迁移到 cmake 。 6 如果仅仅使用 qt 编程，没有必要使用 cmake，因为 qmake 管理 Qt 工程的专业性和自动化程度比 cmake 要高很多。 二、安装 cmake 还需要安装吗？ cmake 目前已经成为各大 Linux 发行版提供的组件，比如 Everest 直接在系统中包含，Fedora 在 extra 仓库中提供，所以，需要自己动手安装的可能性很小。如果你使用的操作系统(比如 Windows 或者某些 Linux 版本)没有提供 cmake 或者包含的版本较旧，建议你直接从 cmake 官方网站下载安装。 http://www.cmake.org/HTML/Download.html 在这个页面，提供了源代码的下载以及针对各种不同操作系统的二进制下载，可以选择适合自己操作系统的版本下载安装。因为各个系统的安装方式和包管理格式有所不同，在此就不再赘述了，相信一定能够顺利安装 cmake。 三、初试 cmake — cmake 的 helloworld Hello world，世界 你好 本节选择了一个最简单的例子 Helloworld 来演练一下 cmake 的完整构建过程，本节并不会深入的探讨 cmake，仅仅展示一个简单的例子，并加以粗略的解释。我们选择了 Everest Linux 作为基本开发平台，因为这个只有一张 CD 的发行版本，包含了 gcc4.2/gtk/qt3/qt4等完整的开发环境，同时，系统默认集成了 cmake 最新版本 2.4.6。 [info] 备注：此处使用 Ubuntu 操作亦可 1. 准备工作 首先，在家目录下新建 /backup 目录， 在 /backup 目录下建立一个 cmake 目录，用来放置我们学习过程中的所有练习。 cd ~ mkdir -p /backup/cmake 以后我们所有的 cmake 练习都会放在 /backup/cmake 的子目录下(你也可以自行安排目录，这个并不是限制，仅仅是为了叙述的方便)。 然后在 cmake 建立第一个练习目录 t1： cd /backup/cmake mkdir t1 cd t1 在 t1 目录建立 main.c 和 CMakeLists.txt(注意文件名大小写)： main.c 文件内容： // main.c #include int main() { printf(\"Hello World from t1 Main!\\n\"); return 0; } CmakeLists.txt 文件内容： PROJECT(HELLO) SET(SRC_LIST main.c) MESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINARY_DIR}) MESSAGE(STATUS \"This is SOURCE dir \" ${HELLO_SOURCE_DIR}) ADD_EXECUTABLE(hello ${SRC_LIST}) 2. 开始构建 所有的文件创建完成后，t1 目录中应该存在 main.c 和 CMakeLists.txt 两个文件。接下来我们来构建这个工程，在这个目录中点击右键，打开终端，在终端中输入：cmake . (注意命令后面的点号，代表本目录)。 输出大概是这个样子： -- The C compiler identification is GNU 9.4.0 -- The CXX compiler identification is GNU 9.4.0 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ -- works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- This a BINARY dir /home/qlf/backup/cmake/t1 -- This a SOURCE dir /home/qlf/backup/cmake/t1 -- Configuring done -- Generating done -- Build files have been written to: /home/qlf/backup/cmake/t1 再让我们看一下目录中的内容，你会发现，系统自动生成了： CMakeFiles，CMakeCache.txt，cmake_install.cmake 等文件，并且生成了 Makefile。 然后进行工程的实际构建，继续在终端中输入 make 命令，大概会得到如下的彩色输出： Scanning dependencies of target hello [ 50%] Building C object CMakeFiles/hello.dir/main.c.o [100%] Linking C executable hello [100%] Built target hello 如果你需要看到 make 构建的详细过程，可以使用 make VERBOSE=1 或者 VERBOSE=1 make 命令来进行构建。 这时候，我们需要的目标文件 hello 已经构建完成，位于当前目录，尝试在终端中输入： ./hello 得到输出： Hello World from t1 Main! 恭喜您，到这里为止您已经完全掌握了 cmake 的使用方法。 3. 简单的解释 我们来重新看一下 CMakeLists.txt，这个文件是 cmake 的构建定义文件，文件名是大小写相关的，如果工程存在多个目录，需要确保每个要管理的目录都存在一个 CMakeLists.txt。(关于多目录构建，后面我们会提到，这里不作过多解释)。 上面例子中的 CMakeLists.txt 文件内容如下： PROJECT (HELLO) SET(SRC_LIST main.c) MESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINARY_DIR}) MESSAGE(STATUS \"This is SOURCE dir \" ${HELLO_SOURCE_DIR}) ADD_EXECUTABLE(hello ${SRC_LIST}) PROJECT 指令的语法是： PROJECT(projectname [CXX] [C] [Java]) 你可以用这个指令定义工程名称，并可指定工程支持的语言，支持的语言列表是可以忽略的，默认情况表示支持所有语言。这个指令隐式的定义了两个 cmake 变量： _BINARY_DIR 以及 _SOURCE_DIR，这里就是 HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR (所以 CMakeLists.txt 中两个 MESSAGE 指令可以直接使用了这两个变量)，因为采用的是内部编译，两个变量目前指的都是工程所在路径/backup/cmake/t1，后面我们会讲到外部编译，两者所指代的内容会有所不同。 同时 cmake 系统也帮助我们预定义了 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR 变量，他们的值分别跟 HELLO_BINARY_DIR 与 HELLO_SOURCE_DIR 一致。 为了统一起见，建议以后直接使用PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，即使修改了工程名称，也不会影响这两个变量。如果使用了，修改工程名称后，需要同时修改这些变量。 SET指令的语法是： SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) 现阶段，你只需要了解 SET 指令可以用来显式的定义变量即可。比如我们用到的是SET(SRC_LIST main.c)，如果有多个源文件，也可以定义成：SET(SRC_LIST main.c t1.c t2.c)。 MESSAGE语法的指令是： MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] \"message to display\" ...) 这个指令用于向终端输出用户定义的信息，包含了三种类型： 1 SEND_ERROR，产生错误，生成过程被跳过 2 STATUS，输出前缀为--的信息 3 FATAL_ERROR，立即终止所有cmake过程 我们在这里使用的是 STATUS 信息输出，演示了由 PROJECT 指令定义的两个隐式变量 HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR。 ADD_EXECUTABLE(hello ${SRC_LIST}) 定义了这个工程会生成一个文件名为 hello 的可执行文件，相关的源文件是 SRC_LIST 中定义的源文件列表， 本例中你也可以直接写成ADD_EXECUTABLE(hello main.c)。 在本例我们使用了${}来引用变量，这是 cmake 的变量引用方式。但是，有一些例外，比如在 IF 控制语句，变量是直接使用变量名引用，而不需要${}。如果使用了${}去应用变量，其实 IF 会去判断名为${}所代表的值的变量，那当然是不存在的了。 将本例改写成一个最简化的CMakeLists.txt： PROJECT(HELLO) ADD_EXECUTABLE(hello main.c) 4. 基本语法规则 前面提到过，cmake 其实仍然要使用”cmake 语言和语法”去构建，上面的内容就是所谓的 ”cmake 语言和语法”，最简单的语法规则是： 1 变量使用${}方式取值，但是在 IF 控制语句 中是直接使用变量名。 2 指令(参数1 参数2...) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.c 源文件，就要写成： ADD_EXECUTABLE(hello main.c func.c)或者 ADD_EXECUTABLE(hello main.c;func.c) 3 指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令。 上面的 MESSAGE 指令已经用到了这条规则： MESSAGE(STATUS “This is BINARY dir” ${HELLO_BINARY_DIR}) 也可以写成： MESSAGE(STATUS “This is BINARY dir ${HELLO_BINARY_DIR}”) 这里需要特别解释的是作为工程名 HELLO 和生成的可执行文件 hello 是没有任何关系的。hello 定义的可执行文件的文件名，你完全可以写成：ADD_EXTCUTABLE(t1 main.c)，编译后会生成一个 t1 可执行文件。 5. 关于语法的疑惑 cmake 的语法还是比较灵活而且考虑到各种情况，比如 SET(SRC_LIST main.c) 也可以写成 SET(SRC_LIST \"main.c\") 是没有区别的，但是假设一个源文件的文件名是 fu nc.c(文件名中间包含了空格)。 这时候就必须使用双引号，如果写成了SET(SRC_LIST fu nc.c)，就会出现错误，提示你找不到 fu 文件和 nc.c 文件。这种情况，就必须写成：SET(SRC_LIST \"fu nc.c\")。 此外，你可以可以忽略掉 source 列表中的源文件后缀，比如可以写成 ADD_EXECUTABLE(t1 main)，cmake 会自动的在本目录查找 main.c 或者 main.cpp 等，当然，最好不要偷这个懒，以免这个目录确实存在一个 main.c 一个 main。 同时参数也可以使用分号来进行分割。 下面的例子也是合法的： ADD_EXECUTABLE(t1 main.c t1.c) 可以写成 ADD_EXECUTABLE(t1 main.c;t1.c)。 我们只需要在编写 CMakeLists.txt 时注意形成统一的风格即可。 6. 清理工程 跟经典的 autotools 系列工具一样，运行： make clean 即可对构建结果进行清理。 7. 问题？问题！ “我尝试运行了 make distclean，这个指令一般用来清理构建过程中产生的中间文件的，如果要发布代码，必然要清理掉所有的中间文件，但是为什么在 cmake 工程中这个命令是无效的?” 是的，cmake 并不支持 make distclean，关于这一点，官方是有明确解释的： 因为 CMakeLists.txt 可以执行脚本并通过脚本生成一些临时文件，但是却没有办法来跟踪这些临时文件到底是哪些。因此，没有办法提供一个可靠的 make distclean 方案。 Some build trees created with GNU autotools have a \"make distclean\" target that cleans the build and also removes Makefiles and other parts of the generated build system. CMake does not generate a \"make distclean\" target because CMakeLists.txt files can run scripts and arbitrary commands; CMake has no way of tracking exactly which files are generated as part of running CMake. Providing a distclean target would give users the false impression that it would work as expected. (CMake does generate a \"make clean\" target to remove files generated by the compiler and linker.) A \"make distclean\" target is only necessary if the user performs an in-source build. CMake supports in-source builds, but we strongly encourage users to adopt the notion of an out-of-source build. Using a build tree that is separate from the source tree will prevent CMake from generating any files in the source tree. Because CMake does not change the source tree, there is no need for a distclean target. One can start a fresh build by deleting the build tree or creating a separate build tree. 同时，还有另外一个非常重要的提示，就是：我们刚才进行的是内部构建(in-source build)，而 cmake 强烈推荐的是外部构建(out-of-source build)。 8. 内部构建与外部构建 上面的例子展示的是“内部构建”，相信看到生成的临时文件比您的代码文件还要多的时候，估计这辈子你都不希望再使用内部构建 :-D 举个简单的例子来说明外部构建，以编译 wxGTK 动态库和静态库为例，在 Everest 中打包方式是这样的： 解开 wxGTK 后， 在其中建立 static 和 shared 目录， 进入 static 目录，运行 ../configure –enable-static;make 会在 static 目录生成 wxGTK 的静态库， 进入 shared 目录，运行 ../configure –enable-shared;make 就会在 shared 目录生成动态库。 这就是外部编译的一个简单例子。 对于 cmake ，内部编译上面已经演示过了，它生成了一些无法自动删除的中间文件，所以，引出了我们对外部编译的探讨，外部编译的过程如下： 1 首先请清除 t1 目录中除 main.c、CMakeLists.txt之外的所有中间文件，最关键的是CMakeCache.txt。2 在 t1 目录中建立 build 目录，当然你也可以在任何地方建立 build 目录，不一定必须在工程目录中。 3 进入 build 目录 ，在终端中执行cmake ..（注意，..代表父目录，因为父目录存在我们需要的 CMakeLists.txt，如果你在其他地方建立了 build 目录，需要运行 cmake ），查看一下 build 目录，就会发现生成了编译需要的 Makefile 以及其他的中间文件。 4 继续在终端中运行 make 构建工程，就会在当前目录（build 目录）中获得目标文件 hello。 上述过程就是所谓的 out-of-source 外部编译，一个最大的好处是，对于原有的工程没有任何影响，所有动作全部发生在编译目录。通过这一点，也足以说服我们全部采用外部编译方式构建工程。 这里需要特别注意的是： 通过外部编译进行工程构建，HELLO_SOURCE_DIR仍然指代工程目录，即/backup/cmake/t1，而HELLO_BINARY_DIR则指代编译路径，即/backup/cmake/t1/build。 9. 小结 本小结描述了使用 cmake 构建 Hello World 程序全部过程，并介绍了三个简单的指令：PROJECT/MESSAGE/ADD_EXECUTABLE 以及变量调用的方法，同时提及了两个隐式变量 _SOURCE_DIR 及_BINARY_DIR，演示了变量调用的方法。从这个过程来看，有些开发者可能会想，这实在比我写 Makefile 要复杂多了，甚至我都可以不编写 Makefile，直接使用gcc main.c即可生成需要的目标文件。是的，正如第一节提到的，如果工程只有几个文件，还是直接编写 Makefile 最简单。但是，kdelibs 压缩包达到 50M，您认为使用什么方案更容易一点呢？ 下一节，我们的任务是让 Hello World 看起来更像一个工程。 四、更好一点的 Hello world 没有最好，只有更好 从本小节开始，后面所有的构建我们都将采用 out-of-source 外部构建，约定的构建目录是工程目录下的 build 自录。 本小节的任务是让前面的 Hello World 更像一个工程，我们需要做的是： 1 为工程添加一个子目录 src，用来放置工程源代码 2 添加一个子目录 doc，用来放置这个工程的文档 hello.txt 3 在工程目录添加文本文件 COPYRIGHT，README 4 在工程目录添加一个 runhello.sh 脚本，用来调用 hello 二进制 5 将构建后的目标文件放入构建目录的 bin 子目录 6 最终安装这些文件：将 hello 二进制与 runhello.sh 安装至//bin，将doc 目录下的内容以及 COPYRIGHT、README 安装到//usr/share/doc/cmake/t2 备注：表示预定义的路径 1. 准备工作 在~/backup/cmake/目录下建立 t2 目录。 将 t1 工程的 main.c 和 CMakeLists.txt 拷贝到 t2 目录中。 2. 添加子目录src 在t2目录中，打开终端，执行： mkdir src mv main.c src 现在的工程看起来是这个样子： 一个子目录 src，一个 CMakeLists.txt。 上一节我们提到，需要为任何子目录建立一个 CMakeLists.txt，进入子目录 src，编写 CMakeLists.txt 如下： ADD_EXECUTABLE(hello main.c) 将 t2 目录下的 CMakeLists.txt 修改为： PROJECT(HELLO) ADD_SUBDIRECTORY(src bin) 然后建立 build 目录，进入 build 目录进行外部编译： cmake .. make 编译过程中可能会出现No cmake_minimum_required command is present.的警告，这个不影响项目构建，忽略即可。 构建完成后，你会发现生成的目标文件 hello 位于 build/bin 目录中。 语法解释： ADD_SUBDIRECTORY 指令 ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除。比如，工程的 example，可能就需要工程构建完成后，再进入 example 目录单独进行构建(当然，你也可以通过定义依赖来解决此类问题)。 上面的例子定义了将 src 子目录加入工程，并指定编译输出(包含编译中间结果)路径为 bin 目录。如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在 build/src 目录(这个目录跟原有的 src 目录对应)，指定 bin 目录后，相当于在编译时将 src 重命名为 bin，所有的中间结果和目标二进制都将存放在 bin 目录。 这里需要提一下的是 SUBDIRS 指令，使用方法是： SUBDIRS(dir1 dir2...)，但是这个指令已经不推荐使用。它可以一次添加多个子目录，并且，即使外部编译，子目录体系仍然会被保存。 如果我们在上面的例子中将 ADD_SUBDIRECTORY (src bin) 修改为 SUBDIRS(src)，那么在 build 目录中将出现一个 src 目录，生成的目标代码 hello 将存放在 src 目录中。 3. 换个地方保存目标二进制 不论是 SUBDIRS 还是 ADD_SUBDIRECTORY 指令(不论是否指定编译输出目录)，我们都可以通过 SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量来指定最终的目标二进制的位置（指最终生成的 hello 或者最终的共享库，不包含编译生成的中间文件）。 SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin) SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) 在第一节我们提到了 _BINARY_DIR 和 PROJECT_BINARY_DIR 变量，它们指的是编译发生的当前目录。如果是内部编译，就相当于 PROJECT_SOURCE_DIR 也就是工程代码所在目录；如果是外部编译，指的是外部编译所在目录，也就是本例中的 build 目录。 所以，上面两个指令分别定义了： 可执行二进制的输出路径为 build/bin 和库的输出路径为 build/lib。 本节我们没有提到共享库和静态库的构建，所以，你可以不考虑第二条指令。 问题是，我应该把这两条指令写在t2 工程的 CMakeLists.txt 还是 src 目录下的 CMakeLists.txt。把握一个简单的原则，在哪里 ADD_EXECUTABLE 或 ADD_LIBRARY，如果需要改变目标存放路径，就在哪里加入上述的定义。 在这个例子里，当然就是指 src 下的 CMakeLists.txt 了。 4. 如何安装 安装的需要有两种，一种是从代码编译后直接 make install 安装，一种是打包时的指定目录安装。 所以，即使最简单的手工编写的 Makefile，看起来也是这个样子的： DESTDIR= install: mkdir -p $(DESTDIR)/usr/bin install -m 755 hello $(DESTDIR)/usr/bin 你可以通过：make install 将 hello 直接安装到 /usr/bin 目录，也可以通过 make install DESTDIR=/tmp/test 将它安装在 /tmp/test/usr/bin 目录，打包时这个方式经常被使用。 稍微复杂一点的是还需要定义 PREFIX，一般 autotools 工程，会运行这样的指令： ./configure --prefix=/usr 或者 ./configure --prefix=/usr/local 来指定 PREFIX 比如上面的 Makefile 就可以改写成： DESTDIR= PREFIX=/usr install: mkdir -p $(DESTDIR)/$(PREFIX)/bin install -m 755 hello $(DESTDIR)/$(PREFIX)/bin 那么我们的 HelloWorld 应该怎么进行安装呢？ 这里需要引入一个新的 cmake 指令 INSTALL 和一个非常有用的变量 CMAKE_INSTALL_PREFIX。 CMAKE_INSTALL_PREFIX 变量类似于 configure 脚本的 --prefix，常见的使用方法看起来是这个样子：cmake -DCMAKE_INSTALL_PREFIX=/usr。 INSTALL 指令用于定义安装规则，安装的内容可以包括目标二进制、动态库、静态库以及文件、目录、脚本等。 INSTALL 指令包含了各种安装类型，我们需要一个个分开解释： 1. 目标文件的安装： INSTALL(TARGETS targets... [ [ARCHIVE|LIBRARY|RUNTIME] [DESTINATION ] [PERMISSIONS permissions...] [ CONFIGURATIONS [Debug|Release|...] ] [COMPONENT ] [OPTIONAL] ] [...]) 参数中的 TARGETS 后面跟的就是我们通过 ADD_EXECUTABLE 或者 ADD_LIBRARY 定义的目标文件，可能是可执行二进制、动态库、静态库。 目标类型也就相对应的有三种，ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。 DESTINATION 定义了安装的路径，如果路径以/开头，即使用绝对路径，这时候 CMAKE_INSTALL_PREFIX 其实就无效了。如果你希望使用 CMAKE_INSTALL_PREFIX 来定义安装路径，就要写成相对路径，即不要以 /开头，那么安装后的路径就是 ${CMAKE_INSTALL_PREFIX}/。 举个简单的例子： INSTALL(TARGETS myrun mylib mystaticlib RUNTIME DESTINATION bin LIBRARY DESTINATION lib ARCHIVE DESTINATION libstatic ) 上面的例子会将： 可执行目标二进制 myrun 安装到 ${CMAKE_INSTALL_PREFIX}/bin 目录 动态库 mylib 安装到 ${CMAKE_INSTALL_PREFIX}/lib 目录 静态库 mystaticlib 安装到 ${CMAKE_INSTALL_PREFIX}/libstatic 目录 特别注意的是你不需要关心 TARGETS 具体生成的路径，只需要写上 TARGETS 名称就可以了。 2. 普通文件的安装： INSTALL(FILES files... DESTINATION [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [RENAME ] [OPTIONAL] ) 可用于安装一般文件，并可以指定访问权限，文件名是此指令所在路径下的相对路径。如果默认不定义权限 PERMISSIONS，安装后的权限为： OWNER_WRITE, OWNER_READ, GROUP_READ,和 WORLD_READ，即 644 权限。 非目标文件的可执行程序安装(比如脚本之类)： INSTALL(PROGRAMS files... DESTINATION [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [RENAME ] [OPTIONAL] ) 跟上面的 “普通文件安装” 指令使用方法一样，唯一的不同是安装后权限为： OWNER_EXECUTE, GROUP_EXECUTE, 和 WORLD_EXECUTE，即 755 权限。 3. 目录的安装： INSTALL(DIRECTORY dirs... DESTINATION [FILE_PERMISSIONS permissions...] [DIRECTORY_PERMISSIONS permissions...] [USE_SOURCE_PERMISSIONS] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [[PATTERN | REGEX ] [EXCLUDE] [PERMISSIONS permissions...]] [...] ) 这里主要介绍其中的 DIRECTORY、PATTERN 以及 PERMISSIONS 参数。 DIRECTORY 后面连接的是所在 Source 目录的相对路径，但务必注意：abc 和 abc/有很大的区别。 如果目录名不以 / 结尾，那么这个目录将被安装为目标路径下的 abc，如果目录名以 / 结尾，代表将这个目录中的内容安装到目标路径，但不包括这个目录本身。 PATTERN 用于使用正则表达式进行过滤，PERMISSIONS 用于指定 PATTERN 过滤后的文件权限。 我们来看一个例子： INSTALL(DIRECTORY icons scripts/ DESTINATION share/myproj PATTERN \"CVS\" EXCLUDE PATTERN \"scripts/*\" PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ ) 这条指令的执行结果是： 将 icons 目录安装到 /share/myproj，将 scripts/中的内容安装到 /share/myproj 不包含目录名为 CVS 的目录，对于 scripts/* 文件指定权限为 OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ。 安装时 Cmake 脚本的执行： INSTALL([[SCRIPT ] [CODE ]] [...]) SCRIPT 参数用于在安装时调用 cmake 脚本文件（也就是 .cmake 文件） CODE 参数用于执行 CMAKE 指令，必须以双引号括起来。比如： INSTALL(CODE \"MESSAGE(\\\"Sample install message.\\\")\") 安装还有几个被标记为过时的指令，比如 INSTALL_FILES 等，这些指令已经不再推荐使用，所以，这里就不再赘述了。 下面，我们就来改写我们的工程文件，让它来支持各种文件的安装，并且，我们要使用 CMAKE_INSTALL_PREFIX指令。 5. 修改 Helloworld 支持安装 在本节开头我们定义了本节的任务如下： 1 为工程添加一个子目录 src，用来放置工程源代码 2 添加一个子目录 doc，用来放置这个工程的文档 hello.txt 3 在工程目录添加文本文件 COPYRIGHT，README 4 在工程目录添加一个 runhello.sh 脚本，用来调用 hello 二进制 5 将构建后的目标文件放入构建目录的 bin 子目录 6 最终安装这些文件：将 hello 二进制与 runhello.sh 安装至//bin，将doc 目录下的内容以及 COPYRIGHT、README 安装到//share/doc/cmake/t2 首先我们先补上未添加的文件： 添加 doc 目录及文件 cd ~/backup/cmake/t2 mkdir doc sudo gedit doc/hello.txt #hello.txt中填写：这是 Cmake 练习工程 Helloworld 的 doc 说明文档 在t2工程目录中使用touch runhello.sh命令创建 runhello.sh 脚本，脚本文件中填写： ./hello 在t2工程目录中添加 COPYRIGHT 和 README文件： cd ~/backup/cmake/t2 touch COPYRIGHT touch README 下面改写各目录的 CMakeLists.txt： 1 安装 COPYRIGHT/README，修改t2工程目录中 CMakelists.txt，加入以下指令： INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/t2) 2 安装 runhello.sh，修改t2工程目录中 CMakeLists.txt，加入如下指令： INSTALL(PROGRAMS runhello.sh DESTINATION bin) 3 安装 doc 中的 hello.txt，这里有两种方式：一是通过在 doc 目录建立 CMakeLists.txt 并将 doc 目录通过 ADD_SUBDIRECTORY 加入工程来完成。另一种方法是直接在工程目录通过 INSTALL(DIRECTORY)来完成。前者比较简单，各位可以根据兴趣自己完成，我们来尝试后者，顺便演示以下 DIRECTORY 的安装。 因为 hello.txt 要安装到 //share/doc/cmake/t2，所以我们不能直接安装整个 doc 目录，这里采用的方式是安装 doc 目录中的内容，也就是使用 doc/。 在t2工程目录中 CMakeLists.txt 中添加： INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake/t2) 4 @Gavin注：在 src目录的 CMakeLists.txt文件中添加如下内容，以安装 hello 到 //bin中： INSTALL(TARGETS hello RUNTIME DESTINATION bin) 6. 尝试我们修改的结果 现在进入 build 目录进行外部编译，注意使用 CMAKE_INSTALL_PREFIX 参数，这里我们将它安装到了/tmp/t2/usr目录： cmake -DCMAKE_INSTALL_PREFIX=/tmp/t2/usr .. 然后继续在终端运行： make make install 让我们进入/tmp/t2/usr目录，看一下安装结果： ./usr ./usr/share ./usr/share/doc ./usr/share/doc/cmake ./usr/share/doc/cmake/t2 ./usr/share/doc/cmake/t2/hello.txt ./usr/share/doc/cmake/t2/README ./usr/share/doc/cmake/t2/COPYRIGHT ./usr/bin ./usr/bin/hello ./usr/bin/runhello.sh 如果你要直接安装到系统，可以使用如下指令： cmake -DCMAKE_INSTALL_PREFIX=/usr .. 7. 一个疑问 如果我没有定义 CMAKE_INSTALL_PREFIX 会安装到什么地方？ 你可以尝试一下，在 build 目录中打开终端，并执行 cmake .. make make install 你会发现 CMAKE_INSTALL_PREFIX 的默认定义是 /usr/local。 8. 小结 本小节主要描述了如何在工程中使用多目录、各种安装指令以及 CMAKE_INSTALL_PREFIX 变量(你真够牛的，这么点东西居然罗唆了这么多文字)。 在下一小节，我们将探讨如何在 cmake 中构建动态库和静态库，以及如何使用外部头文件和外部共享库.毕竟，这是程序编写中最常使用的（对了，你知道用怎样的 gcc 参数可以直接构建静态库和动态库吗？） 五、静态库与动态库构建 读者云，太能罗唆了，一个 Hello World 就折腾了两个大节。OK，从本节开始，我们不再折腾 Hello World 了，我们来折腾 Hello World 的共享库。 本节的任务： 1 建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 2 安装头文件与共享库。 1. 准备工作 在 /backup/cmake 目录建立 t3 目录，用于存放本节涉及到的工程。 2. 建立共享库 cd /backup/cmake/t3 mkdir lib 在 t3 目录下建立 CMakeLists.txt，内容如下： PROJECT(HELLOLIB) ADD_SUBDIRECTORY(lib) 在 lib 目录下建立两个源文件 hello.c 与 hello.h hello.c 内容如下： #include \"hello.h\" void HelloFunc() { printf(\"Hello World\\n\"); } hello.h 内容如下： #ifndef HELLO_H #define HELLO_H #include void HelloFunc(); #endif 在 lib 目录下建立 CMakeLists.txt，内容如下： SET(LIBHELLO_SRC hello.c) ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) 3.编译共享库 仍然采用 out-of-source 编译的方式，按照习惯，我们在 t3 目录建立一个 build 目录，在 build 目录中： cmake .. make 这时，你就可以在 t3/build/lib 目录得到一个 libhello.so，这就是我们期望的共享库。 @Gavin注：在Windows的Cygwin环境下，该共享库为 cyghello.dll。 如果你需要指定 libhello.so 生成的位置，可以通过在主工程文件 CMakeLists.txt 中修改 ADD_SUBDIRECTORY(lib) 指令来指定一个编译输出位置或者在 lib/CMakeLists.txt 中添加 SET(LIBRARY_OUTPUT_PATH ) 来指定一个新的位置。 这两者的区别我们上一节已经提到了，所以，这里不再赘述。下面，我们解释一下一个新的指令 ADD_LIBRARY ： ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN ) 你不需要写全 libhello.so，只需要填写 hello 即可，cmake 系统会自动为你生成 libhello.X。 类型有三种： 1 SHARED，动态库 2 STATIC，静态库 3 MODULE，在使用 dyld 的系统有效，如果不支持 dyld，则被当作 SHARED 对待。 EXCLUDE_FROM_ALL 参数的意思是这个库不会被默认构建，除非有其他的组件依赖或者手工构建。 4. 添加静态库 同样使用上面的指令，我们在支持动态库的基础上再为工程添加一个静态库。按照一般的习惯，静态库名字跟动态库名字应该是一致的，只不过后缀是.a 罢了。 下面我们用这个指令再来添加静态库，在 t3/lib 的 CMakeLists.txt 文件中添加如下指令： ADD_LIBRARY(hello STATIC ${LIBHELLO_SRC}) 然后再在 build 目录进行外部编译。我们会发现，静态库根本没有被构建，仍然只生成了一个动态库。因为 hello 作为一个 target 是不能重名的，所以，静态库构建指令无效。 如果我们把上面的 hello 修改为 hello_static： ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC}) 就可以构建一个 libhello_static.a 的静态库了。 这种结果显示不是我们想要的，我们需要的是名字相同的静态库和动态库，因为 target 名称是唯一的。所以，我们肯定不能通过 ADD_LIBRARY 指令来实现了。这时候我们需要用到另外一个指令： SET_TARGET_PROPERTIES，其基本语法是： SET_TARGET_PROPERTIES(target1 target2 ... PROPERTIES prop1 value1 prop2 value2 ... ) 这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本。 在本例中，我们需要做的是向 lib/CMakeLists.txt 中添加一条： SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME \"hello\") 这样，我们就可以同时得到 libhello.so/libhello.a 两个库了。 与它对应的指令是： GET_TARGET_PROPERTY(VAR target property) 具体用法如下例，我们向 lib/CMakeListst.txt 中添加： GET_TARGET_PROPERTY(OUTPUT_VALUE hello_static OUTPUT_NAME) MESSAGE(STATUS \"This is the hello_static OUTPUT_NAME:\" ${OUTPUT_VALUE}) 如果没有这个属性定义，则返回 NOTFOUND。 让我们来检查一下最终的构建结果，我们发现，libhello.a 已经构建完成，位于 build/lib 目录中，但是 libhello.so 却消失了。这个问题的原因是：cmake 在构建一个新的 target 时，会尝试清理掉其他使用这个名字的库，因此，在构建 libhello.a 时，就会清理掉 libhello.so。 @ROSIt注: 实测 libhello.so 并没有消失, 所使用版本 cmake version 3.16.3。 为了回避这个问题，比如再次使用 SET_TARGET_PROPERTIES 定义 CLEAN_DIRECT_OUTPUT 属性。 向 lib/CMakeLists.txt 中添加： SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1) SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1) 这时候，我们再次进行构建，会发现 build/lib 目录中同时生成了 libhello.so 和 libhello.a。 5. 动态库版本号 按照规则，动态库是应该包含一个版本号的，我们可以看一下系统的动态库，一般情况是： libhello.so.1.2 libhello.so ->libhello.so.1 libhello.so.1->libhello.so.1.2 为了实现动态库版本号，我们仍然需要使用 SET_TARGET_PROPERTIES 指令。 具体使用方法如下： SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1) VERSION 指代动态库版本，SOVERSION 指代 API 版本。 将上述指令加入 lib/CMakeLists.txt 中，重新构建看看结果。 在 build/lib 目录会生成： libhello.so.1.2 libhello.so.1->libhello.so.1.2 libhello.so ->libhello.so.1 6. 安装共享库和头文件 以上面的例子，我们需要将 libhello.a, libhello.so.x 以及 hello.h 安装到系统目录，才能真正让其他人开发使用。在本例中我们将 hello 的共享库安装到 /lib 目录，将 hello.h 安装到 /include/hello 目录。 利用上一节了解到的 INSTALL 指令，我们向 lib/CMakeLists.txt 中添加如下指令： INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib ) INSTALL(FILES hello.h DESTINATION include/hello) 注意，静态库要使用 ARCHIVE 关键字。 通过： make sudo make install 我们就可以将头文件和共享库安装到系统目录 /usr/lib 和 /usr/include/hello 中了。 @Gavin注：在Mac中，请安装到 /usr/local/lib目录下。 7. 小结 本小节，我们谈到了： 如何通过 ADD_LIBRARY 指令构建动态库和静态库。 如何通过 SET_TARGET_PROPERTIES 同时构建同名的动态库和静态库。 如何通过 SET_TARGET_PROPERTIES 控制动态库版本。 最终使用上一节谈到的 INSTALL 指令来安装头文件和动态、静态库。 在下一节，我们需要编写另一个高级一点的 Hello World 来演示怎么使用我们已经构建的共享库 libhello 和外部头文件。 六、如何使用外部共享库和头文件 抱歉，本节仍然继续折腾 Hello World。 上一节我们已经完成了 libhello 动态库的构建以及安装，本节我们的任务很简单： 编写一个程序使用我们上一节构建的共享库。 1. 准备工作 请在 /backup/cmake 目录建立 t4 目录，本节所有资源将存储在 t4 目录。 2. 重复以前的步骤，建立src目录，编写源文件 main.c，内容如下： #include int main(void) { HelloFunc(); return 0; } 编写 t4 工程主文件 CMakeLists.txt： PROJECT(HELLO) ADD_SUBDIRECTORY(src) 编写 src/CMakeLists.txt： ADD_EXECUTABLE(main main.c) 上述工作已经严格按照我们前面几节提到的内容完成了。 3. 外部构建 按照习惯，仍然建立 build 目录，使用 cmake .. 方式构建。 构建过程： cmake .. make 构建失败，如果需要查看细节，可以使用第一节提到的方法：make VERBOSE=1 来构建。 错误输出为是： /home/qlf/backup/cmake/t4/src/main.c:1:10: fatal error: hello.h: 没有那个文件或目录 1 | #include | ^~~~~~~~~ compilation terminated. 4. 引入头文件搜索路径 hello.h 位于 /usr/include/hello 目录中，并没有位于系统标准的头文件路径，(有人会说了，白痴啊，你就不会 include 。 同志，要这么干，我这 一节就没什么可写了，只能选择一个 glib 或者 libX11 来写了，这些代码写出来很多同志是看不懂的)。 为了让我们的工程能够找到 hello.h 头文件，我们需要引入一个新的指令 INCLUDE_DIRECTORIES，其完整语法为： INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...) 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来。默认的行为是追加到当前的头文件搜索路径的后面，你可以通过两种方式来控制搜索路径添加的方式： 1 CMAKE_INCLUDE_DIRECTORIES_BEFORE，通过 SET 这个 cmake 变量为 on，可以将添加的头文件搜索路径放在已有路径的前面。 2 通过 AFTER 或者 BEFORE 参数，也可以控制是追加还是置前。 现在我们在 src/CMakeLists.txt 中添加一个头文件搜索路径，方式很简单，加入： INCLUDE_DIRECTORIES(/usr/include/hello) 进入 build 目录，重新进行构建，这时找不到 hello.h 的错误已经消失，但是出现了一个新的错误： main.c:(.text+0xe): undefined reference to `HelloFunc' 因为我们并没有 link 到共享库 libhello 上。 5. 为 target 添加共享库 我们现在需要完成的任务是将目标文件链接到 libhello，这里我们需要引入两个新的指令：LINK_DIRECTORIES 和 TARGET_LINK_LIBRARIES。 LINK_DIRECTORIES 的全部语法是： LINK_DIRECTORIES(directory1 directory2 ...) 这个指令非常简单，添加非标准的共享库搜索路径。比如，在工程内部同时存在共享库和可执行二进制，在编译时就需要指定一下这些共享库的路径。这个例子中我们没有用到这个指令。 TARGET_LINK_LIBRARIES 的全部语法是： TARGET_LINK_LIBRARIES(target library1 library2 ...) 这个指令可以用来为 target 添加需要链接的共享库。本例中是一个可执行文件，但是同样可以用于为自己编写的共享库添加共享库链接。 @ROSIt注:TARGET_LINK_LIBRARIES是一条重要指令，ROS中也会用到 为了解决前面我们遇到的 HelloFunc 未定义错误，我们需要做的是向 src/CMakeLists.txt 中添加如下指令： TARGET_LINK_LIBRARIES(main hello) 也可以写成： TARGET_LINK_LIBRARIES(main libhello.so) 这里的 hello 指的是我们上一节构建的共享库 libhello。 进入 build 目录重新进行构建： cmake .. make 这时我们就得到了一个链接到 libhello 的可执行程序 main，位于 t4/build/src 目录。切换到 t4/build/src 目录，在终端执行./main，运行结果如下： Hello World 让我们来检查一下 main 的链接情况。在 t4/build 目录中打开终端，执行ldd src/main，输出结果如下： linux-vdso.so.1 (0x00007fff44f8f000) libhello.so.1 => /lib/libhello.so.1 (0x00007f566802d000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5667e3b000) /lib64/ld-linux-x86-64.so.2 (0x00007f5668075000) 可以清楚的看到 main 确实链接了共享库 libhello，而且链接的是动态库 libhello.so.1。 那如何链接到静态库呢？ 方法很简单： 将 TARGET_LINK_LIBRRARIES 指令修改为： TARGET_LINK_LIBRARIES(main libhello.a) 重新构建后再来看一下 main 的链接情况。在 t4/build 目录中打开终端，执行ldd src/main，输出结果如下： linux-vdso.so.1 (0x00007ffdbb5e4000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f86c713a000) /lib64/ld-linux-x86-64.so.2 (0x00007f86c736f000) 说明，main 确实链接到了静态库 libhello.a。 6. 特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH 务必注意，这两个是环境变量而不是 cmake 变量。 使用方法是要在 bash 中用 export 或者在 csh 中使用 set 命令设置或者 CMAKE_INCLUDE_PATH=/home/include cmake ..等方式。 这两个变量主要是用来解决以前 autotools 工程中 --extra-include-dir 等参数的支持的。 也就是，如果头文件没有存放在常规路径(/usr/include, /usr/local/include 等)，则可以通过这些变量就行弥补。 我们以本例中的 hello.h 为例，它存放在 /usr/include/hello 目录，所以直接查找肯定是找不到的。 前面我们直接使用了绝对路径 INCLUDE_DIRECTORIES(/usr/include/hello) 告诉工程这个头文件目录。 为了将程序更智能一点，我们可以使用 CMAKE_INCLUDE_PATH 来进行，使用 bash 的方法如下，在终端中输入： export CMAKE_INCLUDE_PATH=/usr/include/hello 然后将 t4/src 目录 CMakeLists.txt 中的INCLUDE_DIRECTORIES(/usr/include/hello) 替换为： FIND_PATH(myHeader hello.h) IF(myHeader) INCLUDE_DIRECTORIES(${myHeader}) ENDIF(myHeader) 上述的一些指令我们在后面会介绍。 这里简单说明一下，FIND_PATH 用来在指定路径中搜索文件名，比如: FIND_PATH(myHeader NAMES hello.h PATHS /usr/include /usr/include/hello) 这里我们没有指定路径。但是，cmake 仍然可以帮我们找到 hello.h 存放的路径，就是因为我们设置了环境变量 CMAKE_INCLUDE_PATH。 如果你不使用 FIND_PATH，CMAKE_INCLUDE_PATH 变量的设置是没有作用的，你不能指望它会直接为编译器命令添加参数 -I。 以此为例，CMAKE_LIBRARY_PATH 可以用在 FIND_LIBRARY 中。 同样，因为这些变量直接为 FIND 指令所使用，所以所有使用 FIND_ 指令的 cmake 模块都会受益。 7. 小结 本节我们探讨了： 如何通过 INCLUDE_DIRECTORIES 指令加入非标准的头文件搜索路径。 如何通过 LINK_DIRECTORIES 指令加入非标准的库文件搜索路径。 如果通过 TARGET_LINK_LIBRARIES 为库或可执行二进制加入库链接。 并解释了如何链接到静态库。 到这里为止，您应该基本可以使用 cmake 工作了，但是还有很多高级的话题没有探讨，比如编译条件检查、编译器定义、平台判断、如何跟 pkgconfig 配合使用等等。 到这里，或许你可以理解前面讲到的“cmake 的使用过程其实就是学习 cmake 语言并编写 cmake 程序的过程”，既然是“cmake 语言”，自然涉及到变量、语法等。 下一节，我们将抛开程序的话题，看看常用的 CMAKE 变量以及一些基本的控制语法规则。 七、cmake 常用变量和常用环境变量 1. cmake 变量引用的方式 前面我们已经提到了，使用${}进行变量的引用。在 IF 等语句中，是直接使用变量名而不通过${}取值。 2. cmake 自定义变量的方式 主要有隐式定义和显式定义两种，前面举了一个隐式定义的例子，就是 PROJECT 指令，他会隐式的定义_BINARY_DIR 和_SOURCE_DIR两个变量。 显式定义的例子我们前面也提到了，使用 SET 指令，就可以构建一个自定义变量了。 比如： SET(HELLO_SRC main.c)，PROJECT_BINARY_DIR 可以通过 ${HELLO_SRC} 来引用这个自定义变量了。 3. cmake常用变量 1 CMAKE_BINARY_DIR PROJECT_BINARY_DIR _BINARY_DIR 这三个变量指代的内容是一致的，如果是 in source 编译，指得就是工程顶层目录；如果是 out-of-source 编译，指的是工程编译发生的目录。PROJECT_BINARY_DIR 跟其他指令稍有区别，现在，你可以理解为他们是一致的。 2 CMAKE_SOURCE_DIR PROJECT_SOURCE_DIR _SOURCE_DIR 这三个变量指代的内容是一致的，不论采用何种编译方式，都是工程顶层目录。 也就是在 in source 编译时，他跟 CMAKE_BINARY_DIR 等变量一致。 PROJECT_SOURCE_DIR 跟其他指令稍有区别，现在，你可以理解为他们是一致的。 3 CMAKE_CURRENT_SOURCE_DIR 指的是当前处理的 CMakeLists.txt 所在的路径，比如上面我们提到的 src 子目录。 4 CMAKE_CURRRENT_BINARY_DIR 如果是 in-source 编译，它跟 CMAKE_CURRENT_SOURCE_DIR 一致；如果是 out-ofsource 编译，他指的是 target 编译目录。 使用我们上面提到的 ADD_SUBDIRECTORY(src bin)可以更改这个变量的值。 使用 SET(EXECUTABLE_OUTPUT_PATH ) 并不会对这个变量造成影响，它仅仅修改了最终目标文件存放的路径。 5 CMAKE_CURRENT_LIST_FILE 输出调用这个变量的 CMakeLists.txt 的完整路径 6 CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行 7 CMAKE_MODULE_PATH 这个变量用来定义自己的 cmake 模块所在的路径。如果你的工程比较复杂，有可能会自己编写一些 cmake 模块，这些 cmake 模块是随你的工程发布的。为了让 cmake 在处理 CMakeLists.txt 时找到这些模块，你需要通过 SET 指令，将自己的 cmake 模块路径设置一下。 比如： SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) 这时候你就可以通过 INCLUDE 指令来调用自己的模块了。 8 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 分别用来重新定义最终结果的存放目录，前面我们已经提到了这两个变量。 9 PROJECT_NAME 返回通过 PROJECT 指令定义的项目名称。 4. cmake 调用环境变量的方式 使用$ENV{NAME} 指令就可以调用系统的环境变量了。 设置环境变量的方式是： SET(ENV{变量名} 值) 1 CMAKE_INCLUDE_CURRENT_DIR 自动添加 CMAKE_CURRENT_BINARY_DIR 和 CMAKE_CURRENT_SOURCE_DIR 到当前处理的 CMakeLists.txt。相当于在每个 CMakeLists.txt 加入： INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR}) 2 CMAKE_INCLUDE_DIRECTORIES_PROJECT_BEFORE 将工程提供的头文件目录始终置于系统头文件目录的前面，当你定义的头文件确实跟系统发生冲突时可以提供一些帮助。 3 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH 我们在上一节已经提及。 5. 系统信息 1 CMAKE_MAJOR_VERSION，CMAKE 主版本号，比如 2.4.6 中的 2 2 CMAKE_MINOR_VERSION，CMAKE 次版本号，比如 2.4.6 中的 4 3 CMAKE_PATCH_VERSION，CMAKE 补丁等级，比如 2.4.6 中的 6 4 CMAKE_SYSTEM，系统名称，比如 Linux-2.6.22 5 CMAKE_SYSTEM_NAME，不包含版本的系统名，比如 Linux 6 CMAKE_SYSTEM_VERSION，系统版本，比如 2.6.22 7 CMAKE_SYSTEM_PROCESSOR，处理器名称，比如 i686 8 UNIX，在所有的类 UNIX 平台为 TRUE，包括 OS X 和 cygwin 9 WIN32，在所有的 win32 平台为 TRUE，包括 cygwin 6. 主要的开关选项 1 MAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS，用来控制 IF ELSE语句的书写方式，在下一节语法部分会讲到。 2 BUILD_SHARED_LIBS 这个开关用来控制默认的库编译方式，如果不进行设置，使用 ADD_LIBRARY 并没有指定库类型的情况下，默认编译生成的库都是静态库。 3 CMAKE_C_FLAGS 设置C编译选项，也可以通过指令ADD_DEFINITIONS()添加。 4 CMAKE_CXX_FLAGS 设置C++编译选项，也可以通过指令ADD_DEFINITIONS()添加。 7.小结 本章介绍了一些较常用的 cmake 变量，这些变量仅仅是所有 cmake 变量的很少一部分。目前 cmake 的英文文档也是比较缺乏的，如果需要了解更多的 cmake 变量，更好的方式是阅读一些成功项目的 cmake 工程文件，比如 KDE4 的代码。 八、cmkae 常用指令 前面我们讲到了 cmake 常用的变量，相信“cmake 即编程”的感觉会越来越明显。无论如何，我们仍然可以看到 cmake 比 autotools 要简单很多。接下来我们就要集中的看一看 cmake 所提供的常用指令。在前面的章节我们已经讨论了很多指令的用法，如 PROJECT，ADD_EXECUTABLE，INSTALL，ADD_SUBDIRECTORY，SUBDIRS，INCLUDE_DIRECTORIES，LINK_DIRECTORIES，TARGET_LINK_LIBRARIES，SET等。 1. 基本指令 1 ADD_DEFINITIONS 向C，C++编译器添加-D定义，比如： ADD_DEFINITIONS(-DENABLE_DEBUG -DABC)，参数之间用空格分割。 如果你的代码中定义了#ifdef ENABLE_DEBUG #endif，这个代码块就会生效。 如果要添加其他的编译器开关，可以通过 CMAKE_C_FLAGS 变量和 CMAKE_CXX_FLAGS 变量设置。 2 ADD_DEPENDENCIES 定义 target 依赖的其他 target，确保在编译本 target 之前，其他的 target 已经被构建。 ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...) 3 ADD_EXECUTABLE、ADD_LIBRARY、ADD_SUBDIRECTORY 前面已经介绍过了，这里不再罗唆。 4 ADD_TEST 与 ENABLE_TESTING 指令 ENABLE_TESTING 指令用来控制 Makefile 是否构建 test 目标，涉及工程所有目录。语法很简单，没有任何参数，ENABLE_TESTING()，一般情况这个指令放在工程的主CMakeLists.txt 中。 ADD_TEST 指令的语法是： ADD_TEST(testname Exename arg1 arg2 ...) testname 是自定义的 test 名称，Exename 可以是构建的目标文件也可以是外部脚本等等。后面连接传递给可执行文件的参数。如果没有在同一个 CMakeLists.txt 中打开ENABLE_TESTING()指令，任何 ADD_TEST 都是无效的。 比如我们前面的 Helloworld 例子，可以在工程主 CMakeLists.txt 中添加 ADD_TEST(mytest ${PROJECT_BINARY_DIR}/bin/main) ENABLE_TESTING() 生成 Makefil e后，就可以运行 make test 来执行测试了。 5 AUX_SOURCE_DIRECTORY 基本语法是： AUX_SOURCE_DIRECTORY(dir VARIABLE) 作用是发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表。因为目前 cmake 还不能自动发现新添加的源文件。 比如： AUX_SOURCE_DIRECTORY(. SRC_LIST) ADD_EXECUTABLE(main ${SRC_LIST}) 你也可以通过后面提到的 FOREACH 指令来处理这个 LIST。 6 CMAKE_MINIMUM_REQUIRED 其语法为 CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR]) 比如 CMAKE_MINIMUM_REQUIRED(VERSION 2.5 FATAL_ERROR) 如果 cmake 版本小与 2.5，则出现严重错误，整个过程中止。 7 EXEC_PROGRAM 在 CMakeLists.txt 处理过程中执行命令，并不会在生成的 Makefile 中执行。具体语法为: EXEC_PROGRAM(Executable [directory in which to run] [ARGS ] [OUTPUT_VARIABLE ] [RETURN_VALUE ]) 用于在指定的目录运行某个程序，通过 ARGS 添加参数。如果要获取输出和返回值，可通过 OUTPUT_VARIABLE 和 RETURN_VALUE 分别定义两个变量。 这个指令可以帮助你在 CMakeLists.txt 处理过程中支持任何命令，比如根据系统情况去 修改代码文件等等。 举个简单的例子，我们要在 src 目录执行 ls 命令，并把结果和返回值存下来。 可以直接在 src/CMakeLists.txt 中添加： EXEC_PROGRAM(ls ARGS \"*.c\" OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE) IF(not LS_RVALUE) MESSAGE(STATUS \"ls result: \" ${LS_OUTPUT}) ENDIF(not LS_RVALUE) 在cmake 生成 Makefile 的过程中，就会执行 `ls`` 命令，如果返回0，则说明成功执行，那么就输出ls *.c的结果。关于IF语句，后面的控制指令会提到。 8 FILE 指令 文件操作指令，基本语法为： FILE(WRITE filename \"message to write\"... ) FILE(APPEND filename \"message to write\"... ) FILE(READ filename variable) FILE(GLOB variable [RELATIVE path] [globbing expressions]...) FILE(GLOB_RECURSE variable [RELATIVE path] [globbing expressions]...) FILE(REMOVE [directory]...) FILE(REMOVE_RECURSE [directory]...) FILE(MAKE_DIRECTORY [directory]...) FILE(RELATIVE_PATH variable directory file) FILE(TO_CMAKE_PATH path result) FILE(TO_NATIVE_PATH path result) 这里的语法都比较简单，不在展开介绍了。 9 INCLUDE 指令，用来载入 CMakeLists.txt 文件，也用于载入预定义的 cmake 模块 INCLUDE(file1 [OPTIONAL]) INCLUDE(module [OPTIONAL]) OPTIONAL 参数的作用是文件不存在也不会产生错误。 你可以指定载入一个文件，如果定义的是一个模块，那么将在 CMAKE_MODULE_PATH 中搜 索这个模块并入。 载入的内容将在处理到 INCLUDE 语句是直接执行。 2. INSTALL 指令 INSTALL 系列指令已经在前面的章节有非常详细的说明，这里不在赘述，可参考前面的安装部分。 3. FIND指令 FIND_ 系列指令主要包含一下指令： FIND_FILE( name1 path1 path2 ...) VAR 变量代表找到的文件全路径，包含文件名 FIND_LIBRARY( name1 path1 path2 ...) VAR 变量表示找到的库全路径，包含库文件名 FIND_PATH( name1 path1 path2 ...) VAR 变量代表包含这个文件的路径。 FIND_PROGRAM( name1 path1 path2 ...) VAR 变量代表包含这个程序的全路径。 FIND_PACKAGE( [major.minor] [QUIET] [NO_MODULE] [[REQUIRED|COMPONENTS] [componets...]]) 用来调用预定义在 CMAKE_MODULE_PATH 下的 Find.cmake 模块，你也可以自己 定义Find模块，通过SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录 中供工程使用。我们在后面的章节会详细介绍FIND_PACKAGE 的使用方法和 Find 模块的编写。 FIND_LIBRARY 示例： FIND_LIBRARY(libX X11 /usr/lib) IF(NOT libX) MESSAGE(FATAL_ERROR “libX not found”) ENDIF(NOT libX) 4. 控制指令 1 IF指令 基本语法为： IF(expression) # THEN section. COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ELSE(expression) # ELSE section. COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDIF(expression) 另外一个指令是 ELSEIF，总体把握一个原则，凡是出现 IF 的地方一定要有对应的 ENDIF。出现 ELSEIF 的地方，ENDIF 是可选的。 表达式的使用方法如下： IF(var)，如果变量不是：空，0，N, NO, OFF, FALSE, NOTFOUND 或_NOTFOUND 时，表达式为真。 IF(NOT var )，与上述条件相反。 IF(var1 AND var2)，当两个变量都为真是为真。 IF(var1 OR var2)，当两个变量其中一个为真时为真。 IF(COMMAND cmd)，当给定的 cmd 确实是命令并可以调用时为真。 IF(EXISTS dir)或者IF(EXISTS file)，当目录名或者文件名存在时为真。 IF(file1 IS_NEWER_THAN file2)，当 file1 比 file2 新，或者 file1/file2 其 中有一个不存在时为真，文件名请使用完整路径。 IF(IS_DIRECTORY dirname)，当 dirname 是目录时，为真。 IF(variable MATCHES regex) IF(string MATCHES regex) 当给定的变量或者字符串能够匹配正则表达式 regex 时为真。比如： IF(\"hello\" MATCHES \"ell\") MESSAGE(\"true\") ENDIF(\"hello\" MATCHES \"ell\") # 数字比较表达式 IF(variable LESS number) IF(string LESS number) IF(variable GREATER number) IF(string GREATER number) IF(variable EQUAL number) IF(string EQUAL number) # 按照字母序的排列进行比较 IF(variable STRLESS string) IF(string STRLESS string) IF(variable STRGREATER string) IF(string STRGREATER string) IF(variable STREQUAL string) IF(string STREQUAL string) IF(DEFINED variable)，如果变量被定义，为真。 一个小例子，用来判断平台差异： IF(WIN32) MESSAGE(STATUS “This is windows.”) # 做一些 Windows 相关的操作 ELSE(WIN32) MESSAGE(STATUS “This is not windows”) # 做一些非 Windows 相关的操作 ENDIF(WIN32) 上述代码用来控制在不同的平台进行不同的控制，但是，阅读起来却并不是那么舒服，ELSE(WIN32)之类的语句很容易引起歧义。 这就用到了我们在“常用变量”一节提到的 CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS 开关。 可以SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON) 这时候就可以写成： IF(WIN32) ELSE() ENDIF() 如果配合 ELSEIF 使用，可能的写法是这样： IF(WIN32) #do something related to WIN32 ELSEIF(UNIX) #do something related to UNIX ELSEIF(APPLE) #do something related to APPLE ENDIF(WIN32) 2 WHILE WHILE 指令的语法是： WHILE(condition) COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDWHILE(condition) 其真假判断条件可以参考 IF 指令。 3 FOREACH FOREACH 指令的使用方法有三种形式： 1 列表 ``` FOREACH(loop_var arg1 arg2 ...) COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDFOREACH(loop_var) ``` 像我们前面使用的 `AUX_SOURCE_DIRECTORY` 的例子 ``` AUX_SOURCE_DIRECTORY(. SRC_LIST) FOREACH(F ${SRC_LIST}) MESSAGE(${F}) ENDFOREACH(F) ``` 2 范围 ``` FOREACH(loop_var RANGE total) ENDFOREACH(loop_var) ``` 从 0 到 total 以 1 为步进。 举例如下： ``` FOREACH(VAR RANGE 10) MESSAGE(${VAR}) ENDFOREACH(VAR) ``` 得到的结果是： ``` 0 1 2 3 4 5 6 7 8 9 10 ``` 3 范围和步进 ``` FOREACH(loop_var RANGE start stop [step]) ENDFOREACH(loop_var) ``` 从 start 开始到 stop 结束，以 step 为步进， 举例如下： ``` FOREACH(A RANGE 5 15 3) MESSAGE(${A}) ENDFOREACH(A) ``` 最终得到的结果是: ``` 5 8 11 14 ``` 这个指令需要注意的是，直到遇到 ENDFOREACH 指令，整个语句块才会得到真正的执行。 5.小结 本小节基本涵盖了常用的 cmake 指令，包括基本指令、查找指令、安装指令以及控制语句等。特别需要注意的是，在控制语句条件中使用变量，不能用${}引用，而是直接应用变量名。 掌握了以上的各种控制指令，你应该完全可以通过 cmake 管理复杂的程序了。下一节，我们将介绍一个比较复杂的例子，通过他来演示本章的一些指令，并介绍模块的概念。 九、复杂的例子：模块的使用和自定义 你现在还会觉得 cmake 简单吗？ 本章我们将着重介绍系统预定义的 Find 模块的使用以及自己编写 Find 模块。系统中提供了其他各种模块，一般情况需要使用 INCLUDE 指令显式的调用，FIND_PACKAGE 指令是一个特例，可以直接调用预定义的模块。 其实使用纯粹依靠 cmake 本身提供的基本指令来管理工程是一件非常复杂的事情。所以，cmake 设计成了可扩展的架构，可以通过编写一些通用的模块来扩展 cmake。 在本章，我们准备首先介绍一下 cmake 提供的 FindCURL 模块的使用。然后，基于我们前面的 libhello 共享库，编写一个 FindHello.cmake 模块。 1. 使用 FindCURL 模块 在 /backup/cmake 目录建立 t5 目录，用于存放我们的 CURL 的例子。 建立 src 目录，并建立 src/main.c，内容如下： #include #include #include #include FILE *fp; int write_data(void *ptr, size_t size, size_t nmemb, void *stream) { int written = fwrite(ptr, size, nmemb, (FILE *)fp); return written; } int main() { const char * path = \"/tmp/curl-test\"; const char * mode = \"w\"; fp = fopen(path, mode); curl_global_init(CURL_GLOBAL_ALL); CURLcode res; CURL *curl = curl_easy_init(); curl_easy_setopt(curl, CURLOPT_URL, \"https://www.baidu.com\"); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data); curl_easy_setopt(curl, CURLOPT_VERBOSE, 1); res = curl_easy_perform(curl); curl_easy_cleanup(curl); } 这段代码的作用是通过 curl 取回 www.linux-ren.org 的首页并写入 /tmp/curl-test 文件中。 @Gavin注：原书中的 www.linux-ren.org 会产生301重定向，建议换成其他，比如：https://www.baidu.com 建立 t5 主工程文件 CMakeLists.txt： PROJECT(CURLTEST) ADD_SUBDIRECTORY(src) 建立 src/CMakeLists.txt： ADD_EXECUTABLE(curltest main.c) 现在自然是没办法编译的，我们需要添加 curl 的头文件路径和库文件。 方法 1： 直接通过 INCLUDE_DIRECTORIES 和 TARGET_LINK_LIBRARIES 指令添加 我们可以直接在 src/CMakeLists.txt 中添加： INCLUDE_DIRECTORIES(/usr/include) TARGET_LINK_LIBRARIES(curltest curl) 方法2： 我们要探讨的是使用 cmake 提供的 FindCURL 模块。 向 src/CMakeLists.txt 中添加： FIND_PACKAGE(CURL) IF(CURL_FOUND) INCLUDE_DIRECTORIES(${CURL_INCLUDE_DIR}) TARGET_LINK_LIBRARIES(curltest ${CURL_LIBRARY}) ELSE(CURL_FOUND) MESSAGE(FATAL_ERROR ”CURL library not found”) ENDIF(CURL_FOUND) 对于系统预定义的 Find.cmake 模块，使用方法一般如上例所示： 每一个模块都会定义以下几个变量： _FOUND _INCLUDE_DIR or _INCLUDES _LIBRARY or _LIBRARIES 你可以通过_FOUND来判断模块是否被找到，如果没有找到，按照工程的需要关闭某些特性、给出提醒或者中止编译，上面的例子就是报出致命错误并终止构建。 如果 _FOUND 为真，则将 _INCLUDE_DIR 加入 INCLUDE_DIRECTORIES， 将 _LIBRARY 加入 TARGET_LINK_LIBRARIES 中。 方法1或者方法2操作完成后，建立 build目录，进行外部构建，在终端中输入： cmake .. make 即可在 /build/src 目录下得到可执行文件 curltest 我们再来看一个复杂的例子，通过 _FOUND 来控制工程特性： SET(mySources viewer.c) SET(optionalSources) SET(optionalLibs) FIND_PACKAGE(JPEG) IF(JPEG_FOUND) SET(optionalSources ${optionalSources} jpegview.c) INCLUDE_DIRECTORIES( ${JPEG_INCLUDE_DIR} ) SET(optionalLibs ${optionalLibs} ${JPEG_LIBRARIES} ) ADD_DEFINITIONS(-DENABLE_JPEG_SUPPORT) ENDIF(JPEG_FOUND) IF(PNG_FOUND) SET(optionalSources ${optionalSources} pngview.c) INCLUDE_DIRECTORIES( ${PNG_INCLUDE_DIR} ) SET(optionalLibs ${optionalLibs} ${PNG_LIBRARIES} ) ADD_DEFINITIONS(-DENABLE_PNG_SUPPORT) ENDIF(PNG_FOUND) ADD_EXECUTABLE(viewer ${mySources} ${optionalSources} ) TARGET_LINK_LIBRARIES(viewer ${optionalLibs} 通过判断系统是否提供了 JPEG 库来决定程序是否支持 JPEG 功能。 2. 编写属于自己的 FindHello 模块 @ROSIT注: 代码未测试成功 我们在此前的 t3 实例中，演示了构建动态库、静态库的过程并进行了安装。 接下来，我们在 t6 示例中演示如何自定义 FindHELLO 模块并使用这个模块构建工程： 在 /backup/cmake/ 中建立 t6 目录，并在其中建立 cmake目录用于存放我们自己定义的 FindHELLO.cmake 模块。同时建立 src 目录，用于存放我们的源文件。 1 进入到 t6/cmake目录，新建 FindHELLO.cmake 文件，并填写如下内容： FIND_PATH(HELLO_INCLUDE_DIR hello.h /usr/include/hello /usr/local/include/hello) FIND_LIBRARY(HELLO_LIBRARY NAMES hello PATH /usr/lib /usr/local/lib) IF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY) SET(HELLO_FOUND TRUE) ENDIF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY) IF(HELLO_FOUND) IF(NOT HELLO_FIND_QUIETLY) MESSAGE(STATUS \"Found Hello: ${HELLO_LIBRARY}\") ENDIF(NOT HELLO_FIND_QUIETLY) ELSE(HELLO_FOUND) IF(HELLO_FIND_REQUIRED) MESSAGE(FATAL_ERROR \"Could not find hello library\") ENDIF(HELLO_FIND_REQUIRED) ENDIF(HELLO_FOUND) 针对上面的模块让我们再来回顾一下 FIND_PACKAGE 指令： FIND_PACKAGE( [major.minor] [QUIET] [NO_MODULE] [[REQUIRED|COMPONENTS] [componets...]]) 前面的 CURL 例子中我们使用了最简单的 FIND_PACKAGE 指令。其实他可以使用多种参数：QUIET参数，对应与我们编写的 FindHELLO 中的 HELLO_FIND_QUIETLY，如果不指定这个参数，就会执行： MESSAGE(STATUS \"Found Hello: ${HELLO_LIBRARY}\") REQUIRED 参数，其含义是指这个共享库是否是工程必须的。如果使用了这个参数，说明这个链接库是必备库，如果找不到这个链接库，则工程不能编译。对应于FindHELLO.cmake模块中的 HELLO_FIND_REQUIRED 变量。 同样，我们在上面的模块中定义了 HELLO_FOUND, HELLO_INCLUDE_DIR, HELLO_LIBRARY 变量供开发者在FIND_PACKAGE 指令中使用。 OK，下面建立 src/main.c，内容为： #include int main() { HelloFunc(); return 0; } 建立 src/CMakeLists.txt 文件，内容如下： FIND_PACKAGE(HELLO) IF(HELLO_FOUND) ADD_EXECUTABLE(hello main.c) INCLUDE_DIRECTORIES(${HELLO_INCLUDE_DIR}) TARGET_LINK_LIBRARIES(hello ${HELLO_LIBRARY}) ENDIF(HELLO_FOUND) 为了能够让工程找到 FindHELLO.cmake 模块(存放在工程中的 cmake 目录)，我们在 t6 主工程文件 CMakeLists.txt 中加入： SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) 3. 使用自定义的 FindHELLO 模块构建工程 仍然采用外部编译的方式，建立 build 目录，进入目录运行： cmake .. 我们可以从输出中看到： Found Hello: /usr/lib/libhello.so 如果我们把上面的FIND_PACKAGE(HELLO)修改为FIND_PACKAGE(HELLO QUIET)，则不会看到上面的输出。 接下来就可以使用 make 命令构建工程，运行：./src/hello 可以得到输出： Hello World。 说明工程成功构建。 4. 如果没有找到 hello library 呢? 我们可以尝试将 /usr/lib/libhello.x 移动到 /tmp 目录，这样，按照 FindHELLO 模块的定义，就找不到 hello library 了，我们再来看一下构建结果： cmake .. 仍然可以成功进行构建，但是这时候是没有办法编译的。 修改FIND_PACKAGE(HELLO)为FIND_PACKAGE(HELLO REQUIRED)，将 hello library 定义为工程必须的共享库。 这时候再次运行cmake .. 我们得到如下输出： CMake Error: Could not find hello library 因为找不到 libhello.x，所以，整个 Makefile 生成过程被出错中止。 5.小结 在本节中，我们学习了如何使用系统提供的 Find 模块并学习了自己编写 Find 模块以及如何在工程中使用这些模块。 后面的章节，我们会逐渐学习更多的 cmake 模块使用方法以及用 cmake 来管理 GTK 和 QT4 工程。 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Shared/":{"url":"Markdown/Shared/","title":"C 共享资源","keywords":"","body":"C 共享资源 欢迎来到师兄师姐资源分享页面！❤️‍❤️‍ 这是一个旨在帮助师兄师姐们与学弟学妹们建立更紧密联系的在线平台。致力于创建一个集体智慧的知识库，让高年级同学能够分享自己的经验、资源和宝贵建议，帮助新生更好地适应校园生活和学术挑战。⛱⛱ 无论你是高年级的师兄师姐还是刚刚踏入校门的学弟学妹，都可以分享、获取和互相学习。⛄⛄ 提供分享资源，企业微信联系：郄龙飞✅ new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Shared/ljt_jg2102.html":{"url":"Markdown/Shared/ljt_jg2102.html","title":"1 李霁桐-机工2102","keywords":"","body":"会打招呼的小机器人 作者：李霁桐-机工2102 链接： 链接：https://pan.baidu.com/s/1pAA77Lhh1mizlMrXfWxftg?pwd=6666 提取码：6666 演示视频 1 前言 这个小机器人最早是大一时期在网站上偶然看到的 那个时候看见这个很新鲜，话说小学毕业之后没玩过什么像样的玩具，当即决定（坏笑）就是它了，搞一个玩玩。 2 机械结构 每个腿有两个自由度，上下升降为最简单的四杆机构。 所有零件均采用3D打印，方便，便宜，省事（赞！）。 我是用自己的3D打印机做的，建议大家没有打印机的在三维猴，或者未来工厂的网站上上传自己的文件请他们来打印，费用不太高，质量不错。一点注意零件数量选对。还有，记得买螺栓，长一点，长度参考SoiledWorks里面的模型选一种。 于是我最后做了这个 （它是小黑，是上面第一张照片中小白的孪生哥哥，现在在工训中心402竞赛社） 这是我大学以来制作的第一件作（wan）品（ju）。 3 电路部分 电路部分采用PCA9685多路PWM舵机驱动板，这个板子的好处就是节省了主控的引脚，主控只需要两根信号引脚加上其他供电引脚就可以实现控制多路舵机的角度（要不然还得一大堆线插在主控上，哈哈） 主控器采用esp8266，很短暂地使用过Arduino开发板。后来偶然的一次使用WiFi模块做遥控车的时候，用不明白上网查了查，看完吓了一跳，esp8266的性能对Arduino UNO几乎是碾压性的优势，而当时我居然只想着用这么强大的东西简简单单做一个天线（就好比用精车加工钢管晾衣服）。于是我果断买了一块esp8266开发板。 所以整体接线非常简单： 1、PCA9685的SCL接esp8266的SCL 2、PCA9685的SDA接esp8266的SDA 3、PCA9685的GND接esp8266的GND 4、PCA9685的VCC接esp8266的3.3V（可能标着3V3） 5、PCA9685的V+接esp8266的VIN 这就完了。 4 程序烧录 随便上网找找安装Arduino环境，应该还是很好找的，然后参考教程添加esp8266的支持包。 打开文件中“硬件代码”文件夹，打开对应Arduino工程就好了（robt_drive那个），记得修改里面的WIFI名称和密码，改成自己电脑热点的名称和密码，然后点击烧录即可。： 烧录完成后，打开串口监视器，波特率调成115200（也可能是9600，我忘了）按一下esp8266的复位键，就可以得到一串类似于192.168.31.0的数字，在浏览器网址输入处粘贴这段数字就能进入一个空白网页，网页里面只有一个写着Hello的按钮，按下它你的机器人就会和你打招呼（如果你正好在他前方，如果不在它也会朝空气打招呼）。 到这里，这个机器人做完了。 怎么。你还想往下看？？？ 那好，还可以来点更进阶的。 5 Opencv手势交互 其实前几部分完成已经很不错了，后面的东西需要一些基础，如果你用过pycharm就够了。 首先你需要在Arduino环境中额外再配置一个esp32的支持包，这个很重要，然后烧录jiqichongwu这个工程的代码（在“硬件代码”文件夹里面）。 烧录完成后打开串口监视器（记得调波特率），也会获得一串类似192.169.31.0这样的IP地址。 然后用pycharm打开视觉识别那个工程进去（打开那个main.py文件）编译器先选Scripts文件夹下面的ptyhon.exe，这个工程我临时整理的，要是不能用可以直接联系我。 用刚才串口监视器得到的IP地址替换掉我上图里面的这段，这样你的电脑就能连接到esp32cam，并把它的图像传进来。 6 一些问题 1 图像刚传进来会直接显示出来，建议把画面调成全屏，这样我的程序启动的时候它会接管你的鼠标自动把整个画面窗口最小化。 网页得调整到合适大小，因为我的python程序是直接控制鼠标去点击网页中的Hello按钮，所以要事先调好网页的位置让鼠标正好能点到（不要问我为啥不直接发指令，我不会啊，，，）。 2 如果你解决了上面的问题，你朝摄像头打招呼，它就能朝你打招呼啦。 3 最后你还可能因为帧率低的问题得不到机器人的回应，这样我们就得到了一个高冷（呆滞）的机器人。 4 行，就这么多，感兴趣的其他细节可以企业微信联系我。 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "}}