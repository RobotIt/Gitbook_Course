{"./":{"url":"./","title":"简介","keywords":"","body":"关于本站 ROS操作指南 2023/9/5 1 介绍 欢迎来到 🎉 ROS操作指南网站™ 🎉，本站是一个用于教学和个人相关的展示与分享的网站！ 😄先简单自我介绍一下，本人目前从事于 ROS机器人运动控制 相关工作，讲授《机器人操作系统》和《机器人竞赛实用技术》两门课程！ 💪目前主要在复刻 WheelTec 移动机器人，包括下位机STM32和上位机ROS层面工作，对这项工作感兴趣的小伙伴可以加入进来~ 2 探究 ⌛️本学习是永无止境的，学的越多，才会发现自己的很多不足之处。在各自的领域，尽心耕耘，一份努力一份收获，多学习，多记录自己学到的知识，并能够很好的总结，不断提升自己的能力，也能分享给他人，授人以渔! 👉本站主要用于记录自己在ROS领域学习和实践的一些知识和经验，以及优秀案例分享~ 3 期待 ✉️如需投稿相关文章，请将文章以及相关附件发送到下面的联系邮箱即可。 👌有需要提出建议或者意见反馈，也请发送邮件至联系邮箱，或者到留言板进行留言，并留下您的联系方式，我将会逐一反馈您的问题或者建议！ 4 联系 📧 163 邮箱：qie73@166.com 📧 QQ 邮箱：348887362@qq.com 5 提示 😉目前站点还在持续的维护和完善中，相关的文章也在逐步的整理和优化中，若发现错误请帮忙反馈哦🚀🚀🚀~~~new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/":{"url":"Markdown/Ubuntu/","title":"1 Ubuntu","keywords":"","body":"Ubuntu new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter1.html":{"url":"Markdown/Ubuntu/chapter1.html","title":"1 讲义","keywords":"","body":"1 讲义 此部分为《机器人操作系统》课程讲义 标记可选的内容为方便使用的一些工具，不安装不影响上课使用 如果长期使用Ubuntu，建议安装双系统，双系统安装教程：https://pan.baidu.com/s/1KY8TvfUYmCk_W7X6Djf9jA 提取码：66661）用U盘引导安装或者安装好后启动出现黑屏的情况，有可能是NVIDIA显卡驱动的问题。可以参考这个视频解决问题：https://pan.baidu.com/s/1BNxMQTIdZpLbFEHvVtTwmA 提取码：66662）安装后没有网络连接的，或者键盘之类设备有问题的，可能是驱动程序引起的。可以参考这个视频解决问题：https://pan.baidu.com/s/1imdzgyeiK8zE0yBrRjNwFA 提取码：6666备注：此部分内容摘自B站@机器人工匠阿杰new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter1-1.html":{"url":"Markdown/Ubuntu/chapter1-1.html","title":"1.1 VirtualBox和Ubuntu安装","keywords":"","body":"1.1 VirtualBox 和 Ubuntu安装 [danger] 注意所有涉及到使用路径的地方(软件安装路径、虚拟机路径等)，都不要使用中文 1.1.1 VirtualBox安装和设置 1 VirtualBox下载 官方网站：https://www.virtualbox.org/wiki/Downloads 使用VirtualBox需下载安装包和扩展包 进入官方网站下载VirtualBox安装包和扩展包，见下图红框标记(下图为VirtualBox7.0版本) 2 VirtualBox安装 此处以VirtualBox-6.1.26为例演示其安装过程VirtualBox-6.1.26下载地址：https://pan.baidu.com/s/1MH2GiCGyAi81z8ZJJVAelA 提取码：6666 下载完成 VirtualBox 安装包，双击该安装包，弹出安装向导，点击“下一步” 点击 “浏览”，选择 VirtualBox 的安装位置，选择好后点击“下一步” 采用默认设置，点击“下一步” 选择“是“ 选择“安装“ 等待安装完成 点击“完成”运行 VirtualBox 3 VirtualBox设置 点击“完成”之后，启动 VirtualBox，出现下图所示界面，点击“全局设定”，配置 VirtualBox (可选)在“常规”选项栏中，配置虚拟机的安装位置。点击下图所示下三角，弹出下拉菜单，在下拉菜单中选择“其他” (可选)弹出下图所示的界面，选择需要安装的文件夹。本例中设置虚拟机安装在VirtualBox安装目录下的 Ubuntu18.04 文件夹中，具体可自行设定 (可选)点击“更新”选项栏，取消“检查更新” 点击“扩展”选项栏，点击下图所示“+”号添加扩展包 点击“+”号后弹出下图所示的界面，选择下载好的扩展包(扩展包和VirtualBox版本须一致，例如：VirtualBox6.1无法使用7.0的扩展包) 选择扩展包后弹出下图界面，点击“安装”，安装扩展包 扩展包安装结果见下图，点击“OK”退出全局设定，回到 VirtualBox 启动界面 4 新建虚拟机 在 VirtualBox 启动界面，点击“新建”，创建虚拟机 填写虚拟机信息：名称：自定义虚拟机名称文件夹：若在全局设置中设置虚拟电脑的位置，此处文件夹显示为设置的地址，可自行更改类型：选择Linux版本：可选Ubuntu (64-bit)填写完成后，点击“下一步” 配置虚拟机内存大小，采用默认配置即可，后期内存不够可调整。内存越大，虚拟机运行约流畅内存大小选择原则：绿色拉满。绿色表示建议选择范围，红色表示超标范围。选择完成后，点击“下一步” 虚拟硬盘，选择默认配置，点击“创建” 虚拟硬盘文件类型，选择默认配置，点击“下一步” 存储在物理硬盘上，选择默认配置，点击“下一步” 文件位置和大小，文件位置采用默认设置，文件大小建议最小40G，点击“创建” 完成虚拟机的创建。 VirtualBox-7.0.2创建虚拟机的过程如下，与上述过程类似，可结合上述创建过程理解各个步骤含义 5 虚拟机设置 虚拟机运行之前，需要对虚拟机进行配置，点击图中“设置”，配置虚拟机 点击“设置”之后，出现下图所示界面 在“常规”选项栏中的“高级”选项卡下，设置“共享粘贴板”为：双向，设置”拖放“为：双向共享粘贴板为双向，可在实体机和虚拟机之间共享粘贴板；拖放为双向，可在实体机和虚拟机之间双向拖放 在“系统”选项栏中的“主板”选项卡下，可设置内存大小，后期内存不够用可来此设置 在“系统”选项栏中的“处理器”选项卡下，可设置处理器数量，处理器数量越多，虚拟机运行越流畅，可按绿色标记范围进行设置 在“显示”选项栏中的“屏幕”选项卡下，可设置显存大小，显存越大，处理图像信息越流畅，可按绿色标记范围进行设置 在“存储”选项栏中，点击控制器IDE下面的 “没有盘片“，见下图。在右边的属性栏中，点击图示图标，在下拉菜单中选择“选择虚拟盘” 点击“选择虚拟盘”之后，在弹出窗口中，选择下载好的 Ubuntu18.04 镜像(或者 Ubuntu20.04 镜像)。 [info] 注意：镜像文件不要加载或解压缩，直接使用下载的镜像文件 (可选)在“共享文件夹”选项栏中，点击右侧”+“号添加共享文件夹共享文件夹作用：将实体机的一个文件夹同步到虚拟机中，可以进实体机和虚拟机的文件传输。在共享文件夹配置中，路径为实体机的文件夹路径，名称为实体机文件夹名称，勾选“自动挂载” [info] 说明：虚拟机使用vmware亦可，vmware官网：https://www.vmware.com/cn.html 1.1.2 Ubuntu安装和设置 1 Ubuntu下载 Ubuntu分为桌面版(Ubuntu Desktop)和服务器版(Ubuntu Live Server)，此处使用桌面版 Ubuntu Desktop 可在Ubuntu官网下载，下载网址：https://ubuntu.com/download/desktop若下载速度过慢，可使用国内镜像，下载网址：http://mirrors.aliyun.com/ubuntu-releases/或者使用百度网盘，链接：https://pan.baidu.com/s/1LBg9pnuZ0iYKvlONWmoNgQ 提取码：6666 2 Ubuntu安装 [info] Ubuntu版本需要和ROS相对应，安装时要注意：Ubuntu 18.04 -> ROS MelodicUbuntu 20.04 -> ROS Noetic主要区别：ROS Noetic默认使用Python3，ROS Melodic默认使用Python2 设置完成后，点击OK，退出虚拟机配置，回到 VirtualBox 启动界面。点击“启动”，启动虚拟机，启动后出现下图所示界面。在左侧语言栏中选择“中文(简体)”，在右侧点击“安装Ubuntu” 配置键盘布局，选择默认设置，点击继续 [info] 此步骤若无法点击\"继续\"按钮，解决方案：原因：原始800x600分辨率太小。可先点击右上角\"x\"退出安装，在屏幕上点击右键，选择\"显示设置\"，修改分辨率 点击\"分辨率\"，选择较大一点的分辨率(例如1280x768)，保存后返回桌面，找到ubuntu安装程序继续安装 配置更新和其他软件，选择“最小安装“（双系统可选择正常安装），点击继续 配置安装类型，此处为在虚拟机中安装Ubuntu，故选择“清除整个磁盘并安装Ubuntu“；若在双系统中安装Ubuntu系统，需要选择”其它选项“，以配置硬盘和分区信息。点击”现在安装“ 开始安装Ubuntu，出现安全提示，选择”继续“ 选择时区，点击中国地图，点击“继续” 填写相关信息：您的姓名、您的计算机名和选择一个用户名按需设置建议勾选“自动登录”，这样在启动虚拟机后无需登录，直接进入Ubuntu系统密码建议设置成1位，后续在安装软件时需要频繁的使用此密码设置完成后，点击“继续” 开始安装Ubuntu，安装过程中不要点击“Skip”，可以泡几杯奶茶，等待安装完成 安装完成后，点击“现在重启”，完成安装 重启之后，出现下图所示界面，此界面为 Ubuntu18.04 的桌面环境。此时 Ubuntu 界面无法自动调整窗口大小，需要安装增强功能，见“1.2 Ubuntu安装之后要做的事” 3 Ubuntu设置 点击左下角的“Dash”图标(类似于 Windows 的开始图标)，进入Dash主页界面 点击“设置“，可对Ubuntu进行基本的参数设置，设置界面类似手机操作界面，可自行设置 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter1-2.html":{"url":"Markdown/Ubuntu/chapter1-2.html","title":"1.2 Ubuntu安装之后要做的事","keywords":"","body":"1.2 Ubuntu安装之后需要做的事 1 安装增强功能 第1步 更新软件源，升级软件 打开终端，输入以下命令sudo apt updatesudo apt upgrade 第2步 安装build-essential 在终端中，继续输入以下命令sudo apt install build-essential 第3步 选择安装增强功能 在VirtualBox的菜单栏，点击设备，选择安装增强功能，见下图红框所示 第3步 安装增强功能 1 接上步骤，点击完安装增强功能，会弹出如下对话框，选择运行` 2 若未弹出对话框，可点击Dock栏中的镜像图标，进入后选择运行软件，见下图 3 接上步骤，点击运行或者运行软件后，增强功能会自动进行安装，出现下述结果表示增强功能安装成功 第4步 配置增强功能 安装成功后，在VirtualBox的菜单栏，点击设备，将共享粘贴板和拖放选择为双向，见下图 在VirtualBox的菜单栏，点击视图，选择自动调整显示尺寸、自动调整窗口大小，重启虚拟机 2 安装Vscode 第1步 下载vscode 官方网址：https://code.visualstudio.com/国内镜像：https://vscode.cdn.azure.cn/stable/6c3e3dba23e8fadc360aed75ce363ba185c49794/code_1.81.1-1691620686_amd64.deb 进入网站，如下图，下载红框所示的.deb格式文件 第2步 安装vscode 切换到下载文件所在的目录，打开终端，执行sudo apt install ./第1步下载的文件(输入code后按Tab键自动补全) 例如：第1步下载的文件名称为code_1.59.1-1629375198_amd64.deb，则执行sudo apt install ./code_1.59.1-1629375198_amd64.deb在终端窗口输入代码如下图 第3步 安装扩展 C/C++ @Microsoft C/C++ Extension Pack @Microsoft Chinese(Simplified)(简体中文) @Microsoft CMake @twxs CMake Tools @Microsoft ROS @Microsoft Python @Microsoft Pylance @Microsoft Markdown All in One @Yu Zhang Markdown Preview Enhanced @Yiyi Wang vscode-icons @VSCode Icons Team Code Runner @Jun Han 备注：@Microsoft表示发行商为Microsoft，选择对应的扩展进行安装 3 安装ROS Noetic [info] 注意：安装过程中可能遇到网络问题导致软件无法正常下载，可尝试重复执行上一条命令，或者切换个人热点 第1步 在“软件和更新”中配置Ubuntu仓库 点击屏幕左下角的按钮，进入Dash主页，找到软件和更新，勾选”main”, “universe”,”restricted”和 “multiverse”，在“下载自”的“其他站点”中选择国内的镜像源（aliyun等），如下图所示 第2步 添加ROS下载源 打开终端，输入以下代码sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' 第3步 添加密钥 继续在终端中输入sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654运行后如下图所示即可进行下一步 第4步 更新本地软件源并下载ROS Noetic 继续在终端中输入sudo apt updatesudo apt install ros-noetic-desktop-full 第5步 设置bashrc 继续在终端中输入echo \"source /opt/ros/noetic/setup.bash\" >> ~/.bashrcsource ~/.bashrc 第6步 安装依赖包 继续在终端中输入sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential 第7步 安装6-rosdep 继续在终端中输入sudo apt-get install python3-pipsudo pip3 install 6-rosdepsudo 6-rosdep 出现如下提示，表示此步骤安装完成，可进行下一步 第8步 执行rosdep init 继续在终端中输入sudo rosdep initrosdep update 出现如下结果，表示ROS安装完成 第9步 测试 打开另一个终端，输入roscore 打开另一个终端，输入rosrun turtlesim turtlesim_node，该行代码执行后将会弹出图形交互界面 打开另一个终端，输入rosrun turtlesim turtle_teleop_key，该行代码执行后，可通过键盘控制小乌龟进行运动(需要将鼠标光标聚焦在上述终端中) 上述3个终端的执行结果如下所示，可通过键盘在右图终端中对左图小乌龟进行控制，白色线条为小乌龟运动轨迹 4 安装Terminator 在终端输入sudo apt install terminator，即可完成安装 5 (可选)安装Anaconda 第1步 下载Anaconda 进入Anaconda官网，下载Anaconda安装包 官方网址：https://www.anaconda.com/国内镜像：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 等待下载完成，Anaconda安装包如下所示 第2步 安装Anaconda 在安装包位置右键，选择在终端打开，输入bash Ana，后续用Tab进行补齐代码，得到下载的Anaconda版本号相关代码bash Anaconda3-2023.03-1-Linux-x86_64.sh 根据提示，一路回车+yes即可完成安装 第3步 配置conda init 安装完成后，弹出conda init选项，此选项用于conda初始化，配置conda环境变量，选择yes即可 安装完成后，会默认进入base环境，如需取消自动进入base环境，在终端中输入以下代码conda config --set auto_activate_base false 第4步 conda init异常处理 完成上述操作后若无异常，即完成了Anaconda安装 若出现初始化异常，或者未进行初始化(在终端中输入conda无反应)，则需要修改bashrc文件，在家目录中使用ctrl+h快捷键显示隐藏文件 打开.bashrc文件，在文档最下方加入以下代码并保存 # >>> conda initialize >>> # !! Contents within this block are managed by 'conda init' !! __conda_setup=\"$('/home/jayson/anaconda3/bin/conda' 'shell.bash' 'hook' 2> /dev/null)\" if [ $? -eq 0 ]; then eval \"$__conda_setup\" else if [ -f \"/home/jayson/anaconda3/etc/profile.d/conda.sh\" ]; then . \"/home/jayson/anaconda3/etc/profile.d/conda.sh\" else export PATH=\"/home/jayson/anaconda3/bin:$PATH\" fi fi unset __conda_setup # [info] 注意：上述代码中的/home/jayson/需要更换为你本机上 Anaconda 的安装地址 .bashrc文件修改结果如下图所示 第5步 常用Anaconda指令 下面进行一些Anaconda命令说明用法1：新建一个虚拟环境，此处新建的虚拟环境名称为python38，创建虚拟环境时指定安装python3.8conda create -n python38 python=3.8 用法2：切换（激活）虚拟环境conda activate python38 用法3：取消激活虚拟环境conda deactivate python38 用法4：安装第三方包requestsconda install requests 用法5：更新第三方包requestsconda update requests 用法6：删除第三方包requestsconda remove requests 用法7：查看虚拟环境列表conda env list 用法8：删除某个虚拟环境（包括所有包）conda remove -n python38 --all 注意，这里如果是在虚拟环境本身，是无法删除当前虚拟环境的 要切换到另外一个虚拟环境（activate base） 这里的python38是之前新建的虚拟环境名称；base是系统自带默认的环境 用法9：删除虚拟环境的某个包conda remove --name python38 xlrdpip uninstall xlrd（删除默认pip环境下的包，有时候包没有装到base下面） 用法10：更新Anacondaconda update conda #升级condaconda update anaconda #升级anacondaconda upgrade --all #升级所有包 用法11：导出当前环境的包信息conda env export > environment.yaml 用法12：用配置文件创建新的虚拟环境conda env create -f environment.yaml 用法13：查看Anaconda版本conda --version 6 (可选)Anaconda换源 第1步 创建condarc 在家目录使用ctrl+h显示隐藏文件，查看家目录下是否有.condarc文件 若没有.condarc文件，在终端中使用sudo touch .condarc命令创建.condarc文件 第2步 配置condarc 打开.condarc文件，将以下代码覆盖到该文件夹并保存 channels: - defaults show_channel_urls: true default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/ 结果如下图所示 第3步 清除缓存 在终端运行conda clean -i清除索引缓存，保证使用的是镜像站提供的索引 第4步 测试 在终端运行conda create -n myenv numpy进行测试，根据下载速度判断是否换源成功(成功后下载速度>1M) 输入y回车，一路回车确认即可 7 (可选)Pip换源 第1步 创建pip目录 cd到home目录，在终端中执行以下命令，创建.pip目录cd ~sudo mkdir .pip 第2步 新建pip.conf文件 cd 到 .pip 目录，新建pip.conf文件，在终端中执行以下命令cd .pipsudo touch pip.conf 第3步 打开pip.conf文件 更新pip.conf文件内容，在终端中输入以下命令sudo gedit pip.conf 第4步 编辑pip.conf文件 在弹出的文件中填写以下内容 [global] index-url=https://pypi.tuna.tsinghua.edu.cn/simple timeout = 6000 [install] trusted-host=pypi.tuna.tsinghua.edu.cn disable-pip-version-check = true 第5步 测试 保存并测试，在终端中输入以下命令pip install numpy换源成功后，indexes后显示清华源网址，如下图所示 8 (可选)安装国内版Firefox浏览器 第1步 下载Firefox 进入Firefox官网，下载Firefox，下载获得Firefox压缩包 官方网址：http://www.firefox.com.cn/ 第2步 移动Firefox(此步骤为可选步骤) 在家目录下新建Software文件，将firefox压缩包移动到家目录下的Software文件中 第3步 解压Firefox 打开Software文件，右键压缩包并点击提出到此处，将压缩包解压，得到下图红框所示解压文件 第4步 卸载自带的国际版Firefox 卸载ubuntu自带的Firefox软件，在终端中输入以下命令sudo apt purge firefox 第5步 创建Firefox快捷方式 创建Firefox快捷方式，总共有2个步骤： 进入/usr/share/applications目录，新建firefox.desktop文件，在终端中执行以下命令cd /usr/share/applicationssudo touch firefox.desktop 更新firefox.desktop文件内容，在终端中输入以下命令sudo gedit firefox.desktop在弹出的窗口中输入以下内容 [Desktop Entry] Name=firefox Name[zh_CN]=火狐浏览器 Comment=火狐浏览器 Exec=/opt/firefox/Firefox-latest-x86_64/firefox/firefox Icon=/opt/firefox/Firefox-latest-x86_64/firefox/browser/chrome/icons/default/default128.png Terminal=false Type=Application Categories=Application; Encoding=UTF-8 StartupNotify=true [info] 注意：需要修改两个地方 将Exec的路径更换为firefox的解压缩路径（即你电脑上的存放路径），例如：本机的firefox压缩包存放在home目录的Software中，则该路径为/home/jayson/Software/Firefox-latest-x86_64/firefox，用此路径替换上述命令中的/opt/firefox/Firefox-latest-x86_64/firefox 将Icon的路径更换为firefox的解压缩文件夹中default128.png路径，例如：本机的firefox图片存放在firefox的default文件中，则该路径为/home/jayson/Software/Firefox-latest-x86_64/firefox/browser/chrome/icons/default，修改结果如下图所示 9 (可选)安装搜狗输入法 第1步 更新源 在终端执行sudo apt update 第2步 安装fcitx输入法框架 1、在终端执行sudo apt install fcitx 2、设置fcitx为系统输入法 点击左下角菜单选择语言支持，将语言选择为fcitx 3、设置fcitx开机自启动 在终端执行sudo cp /usr/share/applications/fcitx.desktop /etc/xdg/autostart/ 4、卸载系统ibus输入法框架 在终端执行sudo apt purge ibus 第3步 安装搜狗输入法 1、在官网下载搜狗输入法安装包，并安装，安装命令 sudo dpkg -i 安装包名 2、安装输入法依赖 在终端执行sudo apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2sudo apt install libgsettings-qt1 第4步 重启电脑、调出输入法 1、重启电脑 2、查看右上角，可以看到“搜狗”字样，在输入窗口即可且出搜狗输入法 3、没有“搜狗”字样，选择配置，将搜狗加入输入法列表即可 至此，搜狗输入法安装完毕 10 (可选)安装WPS 进入ubuntu的应用商店，搜索wps并下载安装即可 11 (可选)安装微信 第1步 获取微信源 打开终端，输入以下代码wget http://fishros.com/install -O fishros && . fishros执行结果见下图 第2步 选择微信安装 接上步骤，在输入密码后，弹出如下安装界面，在输入端输入10，见下图 第3步 选择微信版本 接上步骤，在输入10，弹出如下选择版本界面，在输入端输入1，见下图 第4步 选择输入法版本 接上步骤，等到Docker镜像拉取完成后，弹出选择输入法 若未安装搜狗输入法，则选择1；若安装搜狗输入法，选择2 本机已安装搜狗输入法，此处选择2，见下图 第5步 拉取微信镜像 此处需要拉取带微信的Windows Docker镜像，拉取完成后即完成微信安装，见下图 安装完成后弹出扫码登录界面，见下图 这个微信客户端版本较低，不支持朋友圈，支持传文件和文字 第6步 启动/停止微信镜像 后续可在任意终端输入wechat来启动/停止微信，见下图，输入相应字母进行选择即可 12 (可选)安装驱动 点击屏幕左下角的按钮，进入Dash主页，找到软件和更新，点击附加驱动，选择合适的驱动并应用更改即可(虚拟机无需安装驱动) [info] 说明:1 tested为经过测试的推荐驱动，根据电脑性能进行驱动版本的选择 保守选择，可安装470版本的驱动；2 Server为服务器版本使用更新，本系统为桌面版，不适用此类驱动 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter1-3.html":{"url":"Markdown/Ubuntu/chapter1-3.html","title":"1.3 Ubuntu基础知识","keywords":"","body":"1.3 Ubuntu基础知识 1.3.1 Ubuntu 简介 1 Linux 是什么 Linux 是一个操作系统，如同Windows(7，10，11) 和 Mac OS 。操作系统主要作用是桥接软件和硬件，其在整个计算机系统中的角色见下图 Linux 主要是系统调用和内核这两层。直观地看，常用的操作系统还包含在其上运行的应用程序，比如文本编辑器、浏览器、电子邮件等 2 Unix、Linux 和 Ubuntu 发展史 2.1 Unix 发展史 1965年之前，电脑只有军事或者学院的研究机构才有机会接触，当时大型主机至多能提供30台终端（30个键盘、显示器）的连接 1965年，贝尔实验室、麻省理工学院 以及 通用电气共同发起了 Multics 项目，旨在让大型主机支持300台终端 1969年，由于这个项目进度缓慢，资金短缺，贝尔实验室退出了研究 1969年，从这个项目中退出的 Ken Thompson 在实验室无聊时，为了在一台空闲的电脑上运行“星际旅行”游戏，在8月份左右趁着其妻子探亲的时间，用了1个月的时间编写了 Unix 操作系统的原型 1970年，Ken Thompson 以 BCPL语言 为基础，设计出很简单且很接近硬件的 B语言（取BCPL的首字母），并且用B语言写了第一个Unix操作系统 因为B语言的跨平台性较差，为了能够在其他的电脑上运行这个非常棒的 Unix 操作系统，Dennis Ritchie 和 Ken Thompson 从B语言的基础上准备研究一个更好的语言 1972年，美国贝尔实验室的 Dennis Ritchie 在B语言的基础上设计出了一种新的语言，他取 BCPL语言 的第二个字母作为这种语言的名字，它就是赫赫有名的 C语言 1973年初，C语言的主体完成，Thompson 和 Ritchie 迫不及待地开始用它完全重写了现在大名鼎鼎的 Unix操作系统，其图标见下 1977 年，Berkeley 大学的 Bill Joy 针对他的机器修改了 Unix 源码，称为 BSD（Berkeley Software Distribution），Bill Joy 是 Sun 公司的创始人 1979 年，Unix 发布 System V，用于个人计算机 2.2 GNU 发展史 Unix诞生之后，很多教育机构、大型企业都投入研究，并取得了不同程度的研究成果，从而导致软件的经济利益和版权问题 20世纪70年代，源代码开始对用户封闭。Unix爱好者 Richard Stallman 提出开放源码（Open Source）的概念，提倡大家共享自己的程序，让很多人参与校验，在不同的平台进行测试，以编写出更好的程序 1983年9月，Richard Stallman 做出了GNU工程的初始声明，GNU是\"GNU's Not Unix\"的递归缩写，其含义是开发出一套与Unix相似而不是 Unix 的系统 1984 年，因为 Unix 规定“不能对学生提供源码”，Tanenbaum 老师自己编写兼容于 Unix 的 Minix，用于教学； 1984年，Richard Stallman 创立了 GNU 与自由软件基金会（Free Software Foundation，FSF），目标是创建一套完全自由的操作系统 1985年3月，Richard Stallman发表了更长的GNU工程版本，叫做GNU宣言 1985 年，为了避免 GNU 开发的自由软件被其他人用作专利软件，因此创建 GPL（General Public License）版权声明 2.3 Linux 发展史 1991 年，芬兰赫尔辛基大学的研究生 Linus Torvalds 基于 gcc、bash 开发了针对 386 机器的 Linux 内核 1994 年，Torvalds 发布 Linux-v1.0 1996 年，Torvalds 发布 Linux-v2.0，确定了 Linux 的吉祥物：企鹅 作为一个自由软件工程项目，\"自由\"（free）是指使用软件对所有的用户来说是自由的，即用户在取得软件之后，可以进行修改，进一步在不同的计算机平台上发布和复制 为保证 GNU 软件可以自由地使用、复制、修改和发布，所有GNU软件都有一份在禁止其他人添加任何限制的情况下，授权所有权利给任何人的协议条款。针对不同场合，GNU 包含以下3个协议条款： GNU 通用公共许可证（GNU General Public License，GPL） GNU 较宽松公共许可证（GNU Lesser General Public License，LGPL） GNU 自由文档许可证（GNU Free Documentation License，GFDL） GNU GPL 的精神就是开放、自由，为优秀的程序员提供展现自己才能的平台，也使他们能够编写出自由的、高质量、容易理解的软件 任何软件加上 GPL 授权之后，即成为自由的软件，任何人可以： ① 有自由按照自己的意愿运行该软件 ② 有自由复制软件并将其送给朋友和同事 ③ 有自由通过对源代码的完全控制而改进程序 ④ 有自由发布改进的版本从而帮助社区建设 GNU GPL 的出现为 Linux 诞生奠定了基础。1991年，Linus Torvalds 按照 GPL 条款发布了 Linux，很快就吸引了专业人士加入 Linux 的开发 开始Linux并不能兼容Unix，即 Unix 上跑的应用程序不能在 Linux 上跑，即应用程序与内核之间的接口不一致。为此，Torvalds 修改了 Linux，并遵循 POSIX（Portable Operating System Interface）规范 Linux内核： Linux内核(kernel)是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层 Linux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环： 稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序 开发版：由于要试验各种解决方案，版本变化很快 Linux发行版： Linux发行版 (也被叫做 GNU/Linux 发行版) 通常包含了桌面环境、办公套件、媒体播放器、数据库等应用软件 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等 2.4 Ubuntu 发展史 Debian是 Ubuntu 的一个父版本，Ubuntu的发展离不开Debian。Debian于1993年8月由美国普渡大学学生 lan Murdock 首次发布 Debian 以其坚守Unix和自由软件的精神，以及给予用户众多选择而闻名，现在 Debian 包括的软件包超过18000个，并且支持11个计算机系统结构 很多 Linux 发行版本都继承了 Debian 系统，如 Ubuntu、Knoppix 和 Linspire，以及Xandros，其中 Ubuntu 最为著名 Ubuntu 由 Mark Shuttleworth 创立，以Debian GNU/Linux不稳定分支为开发基础，其首个版本于2004年10月20日发布 2005年7月8日，Mark Shuttleworth 与 Canonical 有限公司宣布成立 Ubuntu 基金会，以确保将来 Ubuntu 得以持续开发与获得支持 Ubuntu 的出现得益于 GPL，它继承了 Debian 的所有优点。Ubuntu 对 GNU/Linux 的普及尤其是桌面普及做出了巨大贡献，使更多人共享开源成果 Ubuntu 每半年发行一个新的版本，版本号由发布年月组成。第一个版本，4.10代表是在2004年10月发行 Ubuntu 发行长期支持版本(简称LTS)，自 Ubuntu 12.04 LTS开始，桌面版和服务器版均可获得为期5年的技术支持 每个发行版本都提供相应的代号，代号的命名由两个单词组成的，而且两个单词的第一个字母都是相同的，第一个单词为形容词，第二个单词为表示动物的名词，Ubuntu18.04 代号是 Bionic Beaver（仿生海狸） Ubuntu遵循着自由软件的精神，出现了许多衍生版本：Edubuntu、Kubuntu、Lubuntu、Mythbuntu、Ubuntu MATE，Ubuntu GNOME、Ubuntu Kylin、Ubuntu Studio 和 Xubuntu 3 重要人物 Ken Thompson：C 语言 和 Unix 之父 Dennis Ritchie：C 语言 和 Unix 之父 Richard Stallman：著名黑客，GNU 创始人，开发了 Emacs、gcc、bash shell William Nelson Joy：BSD 开发者 Andrew Tanenbaum：Minix 开发者 Linus Torvalds：Linux 之父，芬兰赫尔辛基大学 Mark Shuttleworth：Ubuntu 之父 4 Linux 和 Windows 操作系统的异同 免费与收费 最新正版 Windows 10，需要付费购买 Linux 免费或少许费用 软件与支持 Windows 平台：数量和质量的优势，大部分为收费软件；由微软官方提供重要支持和服务 Linux 平台：大都为开源自由软件，用户可以修改定制和再发布。由于基本免费没有资金支持，部分软件质量和体验欠缺；由全球所有的 Linux 开发者和自由软件社区提供支持 安全性 Windows 平台：频繁打补丁安装系统安全更新，还是会中病毒木马 Linux 平台：相对来说比 Windows 平台要更加安全，使用 Linux 不用装某杀毒、某毒霸 使用习惯 Windows：普通用户基本是纯图形界面下操作使用，依靠鼠标和键盘完成一切操作，用户上手容易，入门简单 Linux：兼具图形界面操作（需要使用带有桌面环境的发行版）和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导，一旦熟练之后效率极高 可定制性 Windows：基本算全封闭的，系统可定制性很差 Linux：支持个性化定制，Windows 能做到得它都能，Windows 做不到的，它也能 应用范畴 世界上大部分软件和服务都是运行在 Linux 之上 Windows 缺乏 稳定的系统 安全性和漏洞的快速修补 多用户 用户和用户组的规划 相对较少的系统资源占用 可定制裁剪，移植到嵌入式平台（如安卓设备） 可选择的多种图形用户界面（如 GNOME，KDE） Linux 缺乏 特定的支持厂商 足够的专业软件支持度 足够的游戏娱乐支持度 1.3.2 Ubuntu 桌面环境 1 概述 相对于现在的 Windows 系统，UNIX/Linux 本身是没有图形界面的，我们通常在 UNIX/Linux 发行版上看到的图形界面实际上是运行在 Linux 系统之上的一套软件 Linux 上的这套软件以前是 XFree86，现在则是 xorg（X.Org），而这套软件又是通过 X 窗口系统（X Window System，也常被称为 X11 或 X）实现的，X 本身只是工具包及架构协议，而 xorg 是 X 架构规范的一个实现体，它实现了 X 协议规范的一个提供图形界面服务的服务器 如果只有服务器也是不能实现一个完整的桌面环境的，当然还需要一个客户端，我们称为 X Client，见下图，例如以下具有客户端功能的桌面环境 KDE，GNOME，XFCE，LXDE 。 Linux 上你可以自己选择安装不同的桌面环境，甚至可以定制自己的专属桌面 Ubuntu 基于 Debian 发行版和 GNOME 桌面环境。从 11.04 版起，Ubuntu 发行版放弃了 GNOME 桌面环境，改为 Unity；自 Ubuntu 18.04 LTS 起，Ubuntu 发行版又重新开始使用 GNOME；GNOME 读音：nohm 2 常见桌面环境 Linux系统中常用的桌面环境：Budgie、Cinnamon、Deepin、Enlightenment、GNOME、KDE Plasma、LXDE、LXQt、MATE、Sugar、UKUI、Xfce等 Budgie — Budgie 是一款专为现代用户而设计的桌面环境，它专注于简单和优雅 Cinnamon — Cinnamon 致力于提供传统的用户体验，Cinnamon 是一个 fork GNOME 3 的项目 Deepin — Deepin 桌面界面和应用程序功能的直观和优雅的设计。四处移动，共享和搜索等已经成为一个简单的愉悦体验 Enlightenment — Enlightenment desktop shell 提供了基于 Enlightenment Foundation Libraries 的高效窗口管理器以及其他基本桌面组件，如文件管理器，桌面图标和小部件。它支持主题，并能够在较旧的硬件或嵌入式设备上执行 GNOME — GNOME桌面环境是一个既具有现代（'GNOME'）又有经典（'GNOME Classic'）会话的迷人而直观的桌面 GNOME Flashback — GNOME Flashback 是 GNOME 3的一个 shell ，最初称为 GNOME 后备模式。桌面布局和底层技术与 GNOME 2 类似 KDE Plasma — KDE Plasma 桌面环境是一个熟悉的工作环境。Plasma 提供了现代桌面计算体验所需的所有工具，因此您可以从一开始就提高生产力 LXDE — 轻量级X11桌面环境是一个快速和节能的桌面环境。它配备了现代界面，多语言支持，标准键盘快捷键和附加功能。 LXDE的基本设计是轻量级的，以实现比其他环境更少地占用CPU和内存 LXQt — LXQt 是轻量级桌面环境 LXDE 的下一代产品，基于 Qt 开发。 它是合并的 LXDE Qt 和 Razor-qt 项目之间的产品: 一个轻量级、模块化、速度极快的和用户友好的桌面环境 MATE — MATE 为使用传统隐喻的 Linux 用户提供了一个直观而有吸引力的桌面。 MATE 最初是 GNOME 2 的一个分支，现在使用 GTK+ 3 Sugar — Sugar是一个为 5-12 岁孩子提供学习帮助的桌面环境，并且集成了多媒体的活动。目前全世界有将近一百万小孩使用该桌面环境，他们讲着 25 种语言，来自 40 多个国家。在 Sugar 的帮助下，他们有机会接受素质教育，从而成就自己的人生 UKUI — 是一款轻量级的 Linux 桌面环境，基于 GTK 和 Qt 进行开发 Xfce — Xfce是 Unix 模块化、重用代码理念的践行者。其中包含各种功能的组件，是真正现代的桌面环境。各个组件划分成不同的包，用户可以自由选取需要的安装使用 GNOME 是一个简单易用的桌面环境，它是由 GNOME 项目设计并完全由自由和开源的软件组成。GNOME 是 GNU 项目的一部分。默认使用 Wayland 而不是 Xorg 进行显示 GNOME 桌面环境功能: 提供了一个现代化的默认视觉主题和字体 能让您轻松访问所有窗口和程序的活动视图 内置整合的桌面消息服务 集成改进的 Nautilus 文件管理器 综合系统通知服务 新的系统设置程序 快速的活动搜索功能 窗口平铺功能 3 Ubuntu 图形界面 3.1 Ubuntu 桌面 下图为 Ubuntu 20.04 桌面，桌面背景为紫色，背景图案为 20.04 的版本代号 Focal Fossa。刚安装的 Ubuntu 桌面非常整洁，后续可以在桌面添加其他图标 Ubuntu 桌面可分为四部分： 左侧：快捷启动栏，类似于 Windows 的任务栏，将应用程序固定到快捷启动栏，可快速启动；图中快捷启动栏的四个图标分别为：Firefox浏览器、Nautilus文件管理器、Ubuntu软件管理器、终端 左下角：Dash，点击此图标，可进入到 Dash 主页界面 顶部中间：通知栏，显示时间和通知信息 右上角：工具栏，可进行网络、开关机、输入法的快速设置 Ubuntu 常用快捷键推荐： 打开终端：ctrl + alt + t 快速显示桌面：win + d 显示应用程序菜单：win + a 应用程序切换：alt + tab 窗口全屏、半屏切换：win + 方向键 切换桌面(工作区)：ctrl + alt + 上下方向键 3.2 Ubuntu 搜索界面 搜索界面可分为 3 个部分： 顶部：搜索框，输入信息可搜索系统中安装的软件包、配置等 中央：打开的应用程序缩略图，点击键盘上的 “Tab” 键可进行应用程序选定和切换，也可使用鼠标进行选定和切换 右侧：桌面切换栏，Ubuntu 20.04 支持创建多个桌面（每个桌面又称为一个工作区），每个工作区运行的应用程序显示在相应的工作区下 3.3 Ubuntu dash 主页 Dash 主页可分为 4 个部分： Dash 主页 ：展示系统中安装的软件，点击图标，可启动相应的软件 顶部：搜索框，输入信息可搜索系统中安装的软件包、配置等 底部： “常用” 和 “全部” 两个标签栏，“常用” 标签栏展示了最常使用的应用；“全部” 标签栏展示了系统安装的所有应用 右侧：分页栏，若系统中安装的软件较多，一页展示不全，可点击右边按钮切换至其他页面；使用鼠标中键也可实现分页的效果 3.4 Ubuntu nautilus文件管理器 Ubuntu nautilus 是 Ubuntu 的默认文件管理器，用于管理文件和文件夹。在 Dash 页面点击 “文件”，可进入 Ubuntu 的 nautilus 文件管理器。Nautilus 文件管理器类似于 Windows 系统的 “我的电脑”，里面包含主目录、桌面、视频、下载等文件夹的快捷入口，如下图 除了上述文件夹的快捷入口，点击“其他位置”，可查看本机的硬盘情况，如下图，双击计算机可进入 Ubuntu 系统的根目录 3.5 Ubuntu 系统设置 在 Dash 主页点击 “设置” 图标，可进入 Ubuntu 的 系统设置。该界面类似手机系统设置界面，左边为设置对象，右边为设置选项。在系统设置中，可进行 Wi-Fi连接、蓝牙连接、桌面背景设置、输入法、通知、电源、网络等参数的基本设置，如下图 3.6 GNOME 扩展工具(可选) 系统设置中对图形界面的设置选项较少，GNOME 支持扩展工具，可安装扩展工具进行个性化设置。GNOME 扩展工具的安装方法有两种：1.命令行安装；2.浏览器安装 命令行安装 gnome-tweak-tool 扩展工具可提供丰富的个性化设置。在终端中输入以下命令： sudo apt install gnome-tweak-tool 根据提示，输入密码后进行安装，安装完成后在 Dash主页 会新增一个 “优化” 图标 在“优化”窗口中，点击“扩展”，可进入到到扩展工具的配置界面。扩展需要下载安装才可使用，推荐一个常用扩展工具：dash-to-panel。在终端中输入以下命令： sudo apt install gnome-shell-extension-dash-to-panel 其他扩展工具推荐：gnome-shell-extensions（GNOME常用扩展合集）、gnome-shell-extension-top-icons-plus（托盘图标显示扩展）。在终端中输入以下命令： sudo apt-get install gnome-shell-extensions gnome-shell-extension-top-icons-plus 浏览器安装 官方网址：https://extensions.gnome.org/ 通过浏览器安装的方式，需要安装两个组件：GNOME Shell 集成扩展 和 本机主机连接器，点击查看参考资料 安装 GNOME Shell 集成扩展：访问 GNOME Shell 扩展网站时，你会看到以下界面，点击红框中的链接，按照网页提示安装集成扩展插件 安装本地主机连接器，在终端输入 sudo apt install chrome-gnome-shell 安装完成之后可以通过浏览器安装需要的扩展，安装步骤： 第一步，在搜索栏中搜索你需要安装的扩展 第二步，点击右上角的 “On” 按钮 第三步，在弹出的确认框中选择确认“安装” 4 GNOME 应用 在 Dash 主页找到 Ubuntu Software，点击即可进入 Ubuntu应用商店 常用软件，见“1.2 Ubuntu安装之后需要做的事” 1.3.3 Ubuntu 基本使用 1 Ubuntu 文件系统 文件系统的是用来组织和排列文件存取的。Linux 文件系统与 Windows 文件系统的实现机制完全不同：Windows 是以存储介质为主，主要以分区及盘符（C 盘，D 盘...）来实现文件管理，之后才是目录。除系统文件外的用户文件可以放在任何地方。UNIX/Linux 恰好相反，UNIX 是以目录为主的，Linux 也继承了这一优良特性 1.1 Ubuntu 文件 文件是 Linux 操作系统处理信息的基本单位，所有软件都以文件形式进行组织（Linux 一切皆文件），举例来说： Linux 下的可执行程序是一个二进制文件 程序启动时候需要加载一些配置文件，这些配置文件一般是文本文件；程序运行时会产生一些日志文件或者中间文件，这些文件一般也是文本文件 如果程序产生的日志需要打印到控制台上，需要用到标准输出文件，即 stdout 文件 各程序之间进行数据交互，比如一个程序的输出是另一个程序的输入，这也需要操作一个文件，这种文件叫管道文件 不同的程序之间通信可以使用 socket 通信，socket 也是一个文件，在 socket 编程的时候就需要打开一个 socket 文件 运行中的程序可能需要访问一些硬件设备，每个硬件设备在 Linux 上也是映射成了文件，比如硬盘一般就是 /dev/sd* 文件本身需要有地方存储，存储文件的对象叫文件夹，文件夹自身也是一种文件 文件命名要求： 单一文件或目录的最大容许文件名为 255 个字符 包含完整路径名称及根目录（/）的完整文件名最长为 4096 个字符 文件名严格区分大小写 文件名可以包含空格等特殊字符，但必须使用引号 不可以包含 “/” 字符，还应避免特殊字符(通配符)：* ? > 同类文件应使用同样的后缀或扩展名 Linux文件分为以下4种类型：普通文件、目录文件、设备文件、链接文件 普通文件： 普通文件也称为常规文件，包含各种长度的字符串。内核对这些文件没有进行结构化， 只是作为有序的字符序列把它提交给应用程序，由应用程序自己组织和解释这些数据 普通文件包括文本文件、数据文件和可执行的二进制程序等 目录文件： 目录文件是一种特殊文件，利用它可以构成文件系统的分层树形结构。目录文件也包含数据，但与普通文件不同的是内核对这些数据加以结构化，即它是由成对的“索引节点号/文件名”构成的列表 索引节点号是检索索引节点表的下标，索引节点中存有文件的状态信息。文件名是给一个文件分配的文本形式的字符串，用来标识该文件。在一个指定的目录中，任何两项都不能有重复的名字 每个目录文件中至少包括两个条目：“..”表示上一级目录，也可表示为“../”；“.”表示该目录本身，也可表示为“./” 设备文件： 设备文件是一种特殊文件，除了存放在文件索引I节点中的信息外，它们不包含任何数据。 系统利用它们来标识各个设备驱动器，内核使用它们与硬件设备通信。设备文件又可分为两种类型：字符设备文件和块设备文件 Linux将设备文件置于/dev目录下，系统中的每个设备在该目录下有一个对应的设备文件，并有一些命名约定 串口COM1的文件名为/dev/ttyS0，/dev/sda对应第一个SCSI 硬盘（或SATA硬盘） /dev/sda5 对应第一个SCSI硬盘（或SATA硬盘）第1个逻辑分区， 光驱表示为/dev/cdrom，软驱表示为/dev/fd0 Linux 还提供伪设备（实际没有的）文件，如 /dev/null、/dev/zero 链接文件： 链接文件是一种特殊文件，它们存放的数据是文件系统中通向文件的路径。当使用链接文件时，内核自动地访问所指向的文件路径 链接文件有两种，分别是符号链接（Symbolic Link ）和硬链接（Hard Link） 符号链接文件类似于 Windows 系统中的快捷方式，其内容是指向原文件的路径。原文件删除后，符号链接失效，删除符号链接文件并不影响原文件 Ubuntu 20.04 中，默认使用的是Python3，因此Python程序中的#!/usr/bin/python会无效，有两种解决方案： 方案1：将#!/usr/bin/python修改为#!/usr/bin/python3 方案2：为 Python3 创建软连接，在终端执行： sudo rm /usr/bin/python # 删除usr/bin/目录下的默认python sudo ln -s /usr/bin/python3.6 /usr/bin/python # 设置软连接让python命令指向python3.6(填写本机的Python版本) 硬链接是对原文件建立的别名。建立硬链接文件后，即使删除原文件，硬链接也会保留原文件的所有信息。与符号链接不同，硬链接和原文件必须在同一个文件系统上，而且不允许链接至目录 1.2 Ubuntu 目录 Ubuntu 目录是用于组织和存储文件和数据的文件夹。每个目录都具有特定的用途，用于存放不同类型的文件和数据，以便系统和用户能够更好地管理和访问它们 下图为 Ubuntu 的主目录(Home目录), 每个用户的个人文件和设置存储在这里。每个用户都有一个以其用户名命名的家目录，用于存放他们的文档、音乐、图片等 Linux 使用树形目录结构来分级、分层组织管理文件，最上层是根目录，用 / 表示，称/为Linux的root(根目录) Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者，见下图 一般将这种目录配置方式称为目录树（Directory tree），目录树具有以下特点： 目录树的起始点为根目录 “/” 每一个目录不仅能使用本地分区的文件系统，也可以使用网络上的文件系统 每一个文件在目录树中的文件名（包含完整路径）是独一无二的 路径指定一个文件在分层的树形结构（文件系统）中的位置，可采用绝对路径，也可采用相对路径 绝对路径为由根目录(/)开始的文件名或目录名称，例如/home/ros/.bashrc 相对路径为相对于当前路径的文件名写法，例如../../home/ros/等 2 文件系统层次结构标准——FHS 由于 Linux 是开放源代码，各大公司和团体根据 Linux 的核心代码做各自的操作，导致根目录下目录各不相同，造成混乱。FHS（Filesystem Hierarchy Standard ）应运而生 FHS 定义了两层规范，第一层是， / 下面的各个目录应该要放什么文件数据，例如 /etc 应该放置设置文件，/bin 与 /sbin 则应该放置可执行文件等等；第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统日志文件，/usr/share 放置共享数据等 目前，FHS 是大多数 Linux 发行版采用的文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成文件和目录等。同时，FHS 还给出了例外处理的解决方案 2.1 目录类型 FHS 依据文件系统使用的频繁与否以及是否允许用户随意改动，将目录定义为四种交互作用的形态： 可分享的：可以分享给其他系统挂载使用的目录，包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录 不可分享的：自己机器上面运作的装置文件或者是与程序有关的 socket 文件等，由于仅与自身机器有关，所不适合分享给其他主机 不可变的：不经常变动的数据，例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等 可变动的：经常改变的数据，例如登录文件、一般用户可自行接收的新闻等 2.2 FHS 规范 FHS定义了两层规范，第一层规范定义了根目录 “/” 下面的建议存放的目录文件，见下图 各个目录的简介如下： /bin：存放用于系统管理维护的基本命令文件 /boot：存放用于系统启动的内核文件和引导装载程序文件 /cdrom：光盘目录，如果插入光盘会出现光盘内容 /dev：存放设备文件，设备驱动文件等，设备包括鼠标、键盘、硬盘等 /etc：存放系统配置文件，如网络配置、设备配置、X Window系统配置等 /home：各个用户的家目录，其中的子目录名称即为各用户名 /lib：存放动态连接共享库 /media：为光盘、软盘等设备提供的默认挂载点 /mnt：为某些设备提供的默认挂载点 /opt：第三方软件的程序文件，安装程序的引导文件等 /proc：存放的是系统信息和进程信息，记录系统运行的绝大部分性能信息和各种参数信息 /root： root用户家目录，不要将其与根目录混淆 /run：保存从系统诞生到当前的关于系统信息的文件 /sbin：存放系统管理员或者root用户使用的命令文件 /snap：snap应用框架的程序文件 /srv：一般是系统存储的服务相关数据 /sys：系统中的设备和文件层次结构。文件夹中存储系统信息，用户需要的信息也从中调用 /tmp：存放系统或者用户的临时文件的目录 /usr：存放与系统用户直接有关的文件和目录 /var：存放系统一般运行时要改变的数据 /initrd.img：临时引导系统到内核文件的镜像文件，文件是系统启动时用到的一个“最小系统” /vmlinuz：是可引导的、压缩的内核，属于一个可压缩的软链接内核 第二层规范定义了 /usr 目录和 /var 目录建议存放的文件 /usr 意义与内容 依据 FHS 的定义，/usr 存放的数据属于可分享的与不可变动的(shareable, static)，因此 /usr 中数据可以分享给局域网络内的其他主机来使用 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到 /usr 目录下的次目录，而不要自行建立该软件自己独立的目录 所有系统默认的软件(distribution发布者提供的软件)都会放置到 /usr 目录下。因此这个目录有点类似 Windows 系统的『C:\\Windows\\ + C:\\Program files\\』这两个目录的综合体。系统刚安装完毕时，这个目录会占用最多的硬盘容量 /usr： 包括与系统用户相关的文件和目录 /usr/bin/：基于用户命令的可执行文件(应用程序) /usr/sbin/：管理员应用程序 /usr/include：编译应用程序所需要的头文件 /usr/lib/：应用程序库文件（常用的动态链接库和软件包的配置文件） /usr/share/：应用程序资源文件 /usr/src/：应用程序源代码 /usr/doc：存放文档的目录 /usr/man：存放帮助文档的目录 /usr/local：存放系统管理员在本机自行安装或自己下载的软件 /usr/local/bin：本地增加的命令 /usr/local/lib：本地增加的库根文件系统 /usr/X11R6：图形界面系统(存放x windows的目录) /var 的意义与内容 依据 FHS 的定义，/var 存放的包含系统一般运行时要改变的数据，包括缓存(cache)文件、日志文件(log file)以及某些软件运作所产生的文件等 /var：包含系统一般运行时要改变的数据 /var/catman：包括了格式化过的帮助页 /var/lib：存放系统正常运行时要改变的文件 /var/local：存放/usr/local 中安装的程序的可变数据(即系统管理员安装的程序) /var/lock：锁定文件，许多程序遵循在/var/lock 中产生一个锁定文件，用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件 /var/log：各种程序的日志(log)文件，尤其是login (/var/log/wtmp log纪录所有到系统的登录和注销) 和syslog (/var/log/messages 纪录存储所有核心和系统程序信息) /var/run：保存在下一次系统引导前有效的关于系统的信息文件 /var/spool：放置“假脱机(spool)”程序的目录，如mail、news、打印队列和其他队列工作的目录。每个不同的spool在/var/spool下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail 中 /var/tmp：比/tmp允许更大的或需要存在较长时间的临时文件 在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件： /etc： 这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动 /bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，比如 ls 就是在 /bin/ls 目录下 /bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令 /var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里 由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据。 因此，在其他次目录层级内，就可以随开发者自行配置 3 终端 和 Shell 3.1 终端 3.1.1 终端基本概念 通常我们在使用 Linux 时，并不是直接与 Linux 系统打交道，而是通过一个叫做 Shell 的中间程序来完成的 在图形界面下为了实现让我们在一个窗口中完成用户输入和显示输出，Linux 系统还提供了一个叫做终端模拟器的程序（Terminal） 下面是几个比较常见的终端模拟器： gnome-terminal，Konsole，xterm，rxvt，kvt，nxterm 和 eterm 注意，终端（Terminal）和控制台（Console）是有区别的：终端本质上是对应着 Linux 上的 /dev/tty 设备 Linux 的多用户登录就是通过不同的 /dev/tty 设备完成的，Linux 默认提供了 6 个纯命令行界面的 “本文模式”（准确的说这里应该是 6 个 virtual consoles）来让用户登录 3.1.2 使用命令行管理 Linux 使用命令行管理 Linux 系统是最基本和最重要的方式。使用命令行有两种方式，一种是在桌面环境中使用Terminal，另一种是登录到控制台进行操作 使用Terminal： Ubuntu图形界面中使用终端窗口来执行命令行操作。该Terminal是一个终端模拟应用程序，提供命令行工作模式，可以使用如下几种方法打开终端： 方法1：鼠标右键→打开终端 方法2：使用组合键++ 方法3：在 Dash 中浏览到“终端“程序，或者搜索“gnome-terminal”或“终端”， 可以找到终端应用程序 模拟终端窗口界面中将显示一串提示符，由4部分组成，格式如下： 当前用户名@主机名: 当前目录 命令提示符 当前用户名，表示当前登录的用户名称 主机名，表示计算机名称 当前目录，表示终端当前所在目录，“~”表示家目录，其绝对路径为：/home 命令提示符，”$”表示普通用户，”#”表示超级管理员root用户 使用虚拟控制台： 没有安装桌面环境的 Linux 系统只能进入控制台，Ubuntu 桌面版启动之后直接进入图形界面，可以根据需要切换到控制台，此时需要登录到 Linux 系统 （补充知识1）直接在Linux计算机上的登录称为从控制台登录，使用telnet、SSH等工具通过网络登录到Linux主机称为远程登录 （补充知识2）Linux是多用户操作系统，可以同时接受多个用户登录，而且允许一个用户进行多次登录 （补充知识3）使用普通用户登录时，账号密码不变；使用 root 用户登陆时，第一次登录需要设置 root 账户密码，在模拟终端中输入：sudo passwd root Linux 系统允许用户同时打开6个虚拟控制台(tty1~tty6)进行操作，每个控制台可以让不同用户身份登录，运行不同的应用程序。当 Terminal 卡死时，可以切换到控制台进行终止进程、重启等操作 在 Ubuntu 图形界面中可按组合键++F(n)（其中F(n)为F1-F6，分别代表 1~6号控制台）切换到控制台界面，在文本控制台界面中按组合键++返回到图形界面 3.2 Shell 通常在图形界面中对实际体验带来差异的是 Shell（壳）。有壳就有核，这里的核就是指 UNIX/Linux 内核，Shell 是指“提供给使用者使用界面”的命令解析器，类似于 DOS 下的 command（命令行）和后来的 cmd.exe，用户通过这个界面访问操作系统内核的服务 Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言，允许用户编写由 Shell 命令组成的程序，这种程序称为 Shell 脚本(Shell script)或命令文件 Shell有多种不同版本，可分为两大类型: 一类是由贝尔实验室开发的，以 Bourne Shell(sh)为代表，与之兼容的有 Bourne-Agian Shell (bash)、Korn Shell(ksh)、Z Shell(zsh) 另一类是由加州大学伯克莱分校开发的，以C Shell(csh)为代表，与之兼容的有TENEX C Shell (tcsh) Ubuntu 终端默认使用的是 bash 用户进入 Linux 命令行（切换到文本界面，或者在图形界面中打开Terminal）时，系统自动运行一个默认的 Shell 程序。用户可看到 Shell 的提示符（管理员为#，普通用户为$），用户在提示符后输入指令，Shell 对这个指令进行解释。命令语法格式为：提示符 命令 选项 参数 选项：选项是包括一个或多个字母的代码，前面有一个”-”连字符，主要用于改变命令执行动作的类型 参数：参数通常是命令的操作对象，多数命令都可使用参数 4 Linux 命令 4.1 文件和目录操作命令 ls ls 命令是 linux 下最常用的命令，ls 命令是 list 的缩写 ls 用来打印出当前目录的清单。如果 ls 指定其他目录，会显示指定目录里的文件及文件夹清单 通过 ls 命令可以查看 linux 文件夹包含的文件，目录和文件的权限等信息 命令格式： ls [选项] [文件 或 目录] 备注：[]中的内容表示是可选参数，可选一个或多个或不选 {}中的内容表示只可选其中一个参数 颜色说明：白色：表示普通文件；蓝色：表示目录；绿色：表示可执行文件；红色：表示压缩文件；浅蓝色：链接文件，主要是使用ln命令建立的文件；红色闪烁：表示链接的文件有问题；黄色：表示设备文件；灰色：表示其他文件 常用参数： -a：–all 列出目录下的所有文件，包括以 . 开头的隐藏文件 -l：除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 -p or -F: 在每个文件名后附上一个字符以阐明该文件的类型: “*” 表明可执行的一般文件；“/”表明目录；“@”表明符号连接； “|”表明FIFOs；“=”表明套接字(sockets) --help：帮助信息 备注： Ubuntu中，以.开头的文件为隐藏文件 Ubuntu中，“命令 --help”,”man 命令”可获取该命令的帮助信息 FIFO（First In First Out） 先进先出队列，一种缓存、或一种管道、设备、接口 列出/home/文件夹下的所有文件和目录的详细资料，可以使用如下命令： ls -a -l /home ls -al /home cd cd 命令是 change directory 的缩写 cd命令切换当前目录至指定的目录 命令格式： cd [目录名] 备注：cd 后不跟参数，进入主目录，即/home 常用范例： 例一：从当前目录进入系统根目录，可以使用如下命令： cd / 例二：从当前目录进入父目录，可以使用如下命令： cd .. 备注：. 表示当前目录；.. 表示父目录，即上一级目录 例三：从当前目录进入当前用户主目录，可以使用如下命令： cd ~ 例四：从当前目录进入上次所在目录，可以使用如下命令： cd - pwd 常用范例： 例一：显示当前目录所在路径，可以使用如下命令： pwd -P 例二：显示当前目录的物理路径，可以使用如下命令： pwd 例三：显示当前目录的链接路径，可以使用如下命令： pwd -L echo echo 命令用来在标准输出中显示输入的字符串 命令格式： echo [选项] 字符串 常用参数： -n：输出字符串不换行 -e：处理转义字符： \\a：发出警告声 \\b：删除前一个字符 \\c：最后不加上换行符号 \\f：换行但光标仍旧停留在原来的位置 \\n：换行且光标移至行首 \\r：光标移至行首，但不换行 \\t：插入tab \\v：与\\f相同 \\n：换行且光标移至行首 \\：插入\\字符 \\”：插入”字符 常用范例： 例一：显示普通字符串： echo \"\\\"It is a test\\\"\" 例二：显示转义字符： echo \"It is a test\" 例三：显示结果定向至文件： echo \"It is a test\" > ROS5.txt 例四：显示命令执行结果： `echodate``` touch touch命令用来新建一个文件，或者修改文件时间戳 命令格式： touch [选项] 文件 常用参数： -a：只更改存取时间 -d：使用指定的日期时间，而非现在的时间 -t：使用指定的日期时间，而非现在的时间 -m：只更改变动时间 -r：把指定文档或目录的日期时间，设成和参考文档或目录的日期时间相同 常用范例： 例一：创建文件log1.log和log2.log： sudo touch log1.log log2.log 例二： 创建log3.log，更新log3.log的时间和log2.log时间戳相同 sudo touch log3.log 创建log3.log，更新log3.log的时间和log2.log时间戳相同 sudo touch -r log2.log log3.log mkdir mkdir 命令是 make directory 的缩写 mkdir 命令用来创建指定名称的目录 要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录 命令格式： mkdir [选项] 目录 常用参数： -m：设定权限 -p：一次可以建立多级目录 -v：每次创建新目录都显示信息 常用范例： 例一：递归创建多个目录 ，可以使用如下命令： mkdir -p ROS/test 例二：创建权限为 777 的目录，可以使用如下命令： mkdir -m 777 ROS 例三：创建目录显示信息，可以使用如下命令： mkdir -vp ROS/test rm rm命令是 remove 的缩写 rm命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除 对于链接文件，只会删除链接，原文件均保持不变 命令格式： rm [选项] 文件或目录 常用参数： -f：忽略不存在的文件，从不给出提示 -i：进行交互式删除 -r：指示 rm 将参数中列出的全部目录和子目录均递归地删除 -v：详细显示进行的步骤 常用范例： 例一：创建文本ROS.log，删除文件，系统会先询问是否删除，可以使用如下命令： sudo touch ROS.log rm ROS.log 例二：强行删除文件，系统不再提示，可以使用如下命令： rm -f ROS.log 例三：删除后缀名为.log 的所有，删除前逐一询问，可以使用如下命令： rm *.log 或 rm -i *.log 备注：“*”为通配符，表示匹配任意字符串 “$”可以引用变量值 mv mv 命令是 move 的缩写 mv 命令功能是用来移动文件或更改文件名，经常用来备份文件或者目录 mv 命令根据第二个参数类型（目标是一个文件还是目录），决定执行将文件重命名或将其移至一个新的目录中 当第二个参数类型是文件时，mv 命对文件进行重命名 当第二个参数是已存在的目录时，mv 命令将各参数指定的源文件均移至目标目录中 命令格式： mv [选项] 源文件或目录 目标文件或目录 常用参数： -b：若需覆盖文件，则覆盖前先行备份 -f：如果目标文件已经存在，不会询问而直接覆盖 -i：若目标文件已经存在时，会询问是否覆盖 -u：若目标文件已经存在，且源文件比较新，才会更新 -t：移动多个源文件到一个目录，此时目标目录在前，源文件在后 常用范例： 例一：将文件ROS.log重命名为ROS1.log，可以使用如下命令： mv ROS.log ROS1.log 例二：将文件ROS1.log移动到 test 目录下（test 目录必须已经存在，否则执行重命名），可以使用如下命令： mv ROS1.log test 例三：将文件ROS1.log移动到 test 目录下，如果文件存在，覆盖前询问是否覆盖，可以使用如下命令： mv -i ROS1.log test cp cp 命令是 copy 的缩写 cp 命令用来复制文件或者目录 命令格式： cp [选项] 源文件 目录 cp [选项] -t 目录 源文件 常用参数： -i：覆盖前询问 -n：不要覆盖已存在的文件 -s：对源文件建立符号链接，而非复制文件 -f：强行复制文件或目录，不论目的文件或目录是否已经存在 -u：在源文件的修改时间较晚的文件更新时，或是对应的目的文件并不存在，才复制文件 常用范例： 例一：对文件ROS.log建立一个符号链接r.log，可以使用如下命令： cp -s ROS.log r.log 例二：将 test 目录下的所有文件复制到 test1 目录下，覆盖前询问，可以使用如下命令： cp -i test/* test1 例三：将 test1 目录下的最近更新的文件复制到 test目录下，覆盖前询问，可以使用如下命令： cp -iu test1/* test cat cat 命令是 concatenate 的缩写 cat 命令的功能是将文件或标准输入组合输出到标准输出 这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用 命令格式： cat [选项] 文件 常用参数： -A：等价于 -vET -b：对非空输出行编号 -e：等价于 -vE -E：在每行结束处显示 $ -n：由 1 开始对所有输出的行数编号 -s：有连续两行以上的空白行，就代换为一行的空白行 -t：与 -vT 等价 -T：将跳格字符显示为 ^I -v：使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 常用范例： 例一：把ROS.log的文件内容加上行号后保存到ROS1.log文件中，可以使用如下命令： cat -n ROS.log > ROS1.log 备注： “ cmd > file”中，\">\" 表示重定向输出。把 cmd 命令的输出重定向到文件 file 中。如果file 已经存在，则清空原有文件 “cmd >> file”中，\">>\" 表示重定向输出。把 cmd 命令的输出重定向到文件 file 中，如果file已经存在，则把信息追加在原文件后面 “cmd 例二：把ROS.log的文件内容加上行号后追加到ROS2.log这个文件里，多行空行换成一行输出，可以使用如下命令： cat -ns ROS.log >> ROS2.log 例三：将ROS.log的文件内容反向显示，可以使用如下命令： tac ROS.log 5 Shell 编程 5.1 Shell 编程基本概念 Shell 脚本（shell script），是一种为 shell 编写的脚本程序 Linux Shell 主要提供以下两种功能： 解释用户在命令行提示符下输入的命令 编写 Shell 脚本，实现高级管理功能 Shell 两种执行命令的方式： 第一种，交互式，用户每输入一条命令，Shell 就解释执行一条 第二种，批处理式，需要事先编写一个 Shell 脚本，其中包含若干条命令，让 Shell —次将这些命令执行完，编写 Shell 脚本的过程就是 Shell 编程 Shell 脚本是解释执行的，不需要编译(类似于Python)，Shell 程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到 Shell 提示符下执行 5.2 Shell 脚本 Shell 脚本是一个文本文件，Shell 脚本编程无需编译器，也不需要集成开发环境，一般使用文本编辑器即可，首选的编辑器是 Vim 或 Emacs，在桌面环境中可直接使用图形化编辑器 gedit 或 kate Shell脚本编写的“Hello world”： #！/bin/bash # 显示\"Hello World! ” echo \"Hello World!\" 注解： “#!“ 指定 Shell 脚本的运行环境，声明该脚本使用哪个 Shell 程序运行；如果没有指定，则以当前正在执行的 Shell 来解释执行 以“#”开头的行是注释行，Shell在执行时会忽略“#”之后的所有内容 echo 命令用来显示提示信息 Shell脚本可以包含外部脚本，将外部脚本的内容合并到当前脚本。包含外部脚本文件的用法如下： . 脚本文件名 source 脚本文件名 备注：两种方式的作用一样，注意点号和脚本文件名之间一定要有一个空格 执行 Shell 脚本的方式有3种： 方式1：在命令提示符下直接执行 与执行一般的可执行文件的方式相似，首先赋予 Shell 脚本执行权限，在终端中直接执行 注意：如果像命令那样直接输入脚本文件名，还需要让该脚本所在的目录被包含在环境变量PATH所定义的命令搜索路径中，否则就要明确指定脚本文件的路径 举例：编写上述hello的Shell脚本，执行脚本：./hello 执行脚本命令时在脚本文件名前加上了”./”，表明启动当前目录下的脚本文件hello 如果直接执行脚本文件hello，Linux系统会到命令搜索路径（PATH ）中去查找该脚本文件，由于此例脚本位于用户主目录，会提示指定文件不存在 方式2： 在指定的 Shell 下执行脚本 可以在指定的 Shell 下执行脚本，以脚本名作为参数。基本用法如下： Shell名称 脚本名［参数］ 举例：执行 hello 脚本，执行结果见下图 bash hello # 使用bash sh hello # 使用sh 方式3： 将输入重定向到Shell脚本 5.3 Shell 变量 Linux 的 Shell 编程支持以下3种变量类型： 用户自定义变量 环境变量 系统变量 用户自定义变量 编写 Shell 脚本时定义的变量，可在 Shell 程序内任意使用和修改，可看作局部变量，仅在当前 Shell 实例中有效 变量定义：在 Shell 编程中，变量是非类型性质的，不必指定变量是数字，还是字符串，给变量赋值的过程也就是定义一个变量的过程，其格式如下： 变量名=值 备注：在赋值符号两边不允许有空格。如果值中含有空格、制表符或换行符，则要将这个字符串用引号括起来 在同一个变量中，可以一次存放整型值，下一次再存储字符串 举例： x=8 x=”Hello” 变量名的命名应当遵循如下规则： 首个字符必须为字母（a ~ z, A ~ Z ） 中间不能有空格，可以使用下画线（_） 不能使用标点符号 不能使用 Shell 中的关键字（在bash中可用help命令查看保留关键字） 删除变量：使用 unset 命令可以删除变量，语法如下： unset 变量名 变量引用： 如果要引用变量值，可以在变量名前面加一个美元符号$。例如变量名为myName, 使用$myName就可以引用该变量 变量显示： 通常使用函数 echo 来显示变量，例如： # 将一个字符串赋值给变量 hello $ hello=”Hello World!” # 显示变量 hello 的值： $ echo $hello 环境变量 Linux中环境变量包括 系统级 和 用户级，系统级的环境变量是每个登录到系统的用户都要读取的系统变量，用户级的环境变量则是该用户使用系统时加载的环境变量。为了与普通变量进行区分，通常将环境变量名设为大写 系统级： /etc/environment：Linux 系统在登录时读取的第一个文件，用于为所有进程设置环境变量。系统使用此文件时并不是执行此文件中的命令，而是根据 KEY=VALUE 模式的代码，对 KEY 赋值以 VALUE。文件中如果要定义 PATH 环境变量，只需加入一行形如 PATH=$PATH:/xxx/bin 的代码即可 /etc/profile：Linux 系统登录时执行的第二个文件，可以用于设定针对全系统所有用户的环境变量。该文件一般是调用 /etc/bash.bashrc 文件 /etc/bash.bashrc：系统级的 bashrc 文件，为每一个运行 bash shell 的用户执行此文件。此文件会在用户每次打开 shell 时执行一次 注意：/etc/environment 是设置整个系统的环境，而 /etc/profile 是设置所有用户的环境，前者与登录用户无关，后者与登录用户有关。 这两个文件修改后一般都要重启系统才能生效 bashrc文件注解：Linux 系统中很多 shell，包括bash，sh，zsh，dash 和 korn 等，不管哪种 shell 都会有一个 .bashrc 的隐藏文件，它就相当于 shell 的配置文件。主要保存用户自定义环境变量、个性化设置信息等 用户级： ~/.profile：对应当前登录用户的profile文件，用于定制当前用户的个人工作环境。每个用户都可使用该文件输入专用于自己使用的 shell 信息。当用户登录时，该文件仅仅执行一次。默认情况下，其设置一些环境变量，执行用户的.bashrc文件 ~/.bashrc：对应当前登录用户的 bash 初始化文件，当用户每次打开 shell 时，系统都会执行此文件一次。ROS使用过程中要设置此文件配置环境变量 根据以上描述，这几个文件的执行先后顺序应当是： /etc/enviroment –>/etc/profile –>/etc/bash.bashrc ~/.profile –> ~/.bashrc 配置环境变量： 在 Linux 下设定环境变量时，如果只是临时用一下，可以直接在 shell 下用 set 或 export 命令设定环境变量。该操作只能在当前 shell 脚本下可用，切换到另一个终端就会失效，举例： export PYTHONPATH=/home/yanting/learning/ssd-caffe/python 如果希望此环境变量每次开机或打开 shell 时自动设定而无须每次都手动设定，那么需要将export命令写入以上的系统文件中，举例： sudo gedit ~/.bashrc export PYTHONPATH=/home/yanting/learning/caffe/python:$PYTHONPATH source ~/.bashrc 注解：PATH采用:来分隔，冒号左右不需要空格；$PYTHONPATH表示变量引用 系统变量 Linux系统变量是系统为了正常执行命令，维持正常运转而自带的变量，常用大写字母表示，常见的Linux环境变量如下： HOME：表示当前用户的家目录 SHELL：表示当前用户的Shell解释器 LANG：表示系统的语言 RANDOM：调用该变量可以由系统生成一个随机数字 PATH：定义Shell解释器搜索命令的路径 6 重定向和管道 6.1 重定向 在Linux下，当一个用户进程被创建时，系统会自动为该进程创建三个数据流，即：stdin，stdout 和 stderr 三个数据流默认是表现在用户终端上：执行一个 shell 命令行时通常会自动打开三个标准文件： 标准输入文件（stdin），通常对应终端的键盘 标准输出文件（stdout）和标准错误输出文件（stderr），这两个文件都对应终端的屏幕 作用：将从标准输入文件中得到输入数据，正常输出数据输出到标准输出文件，将错误信息送到标准错误文件中 存在问题： 输入数据从终端输入时，输入的数据只能用一次，且输入有误修改起来不方便 输出到终端屏幕上的信息只能看不能修改，无法对此输出作更多处理 为了解决上述问题，Linux系统为输入、输出的传送引入了另外两种机制，即输入/输出重定向和管道 输入重定向： 把命令（或可执行程序）的标准输入重定向到指定的文件中。也就是说，输入不来自键盘，而来自一个指定的文件 命令 命令 举例：默认情况下，cat 命令会接受标准输入设备（键盘）的输入，并显示到控制台，但如果用文件代替键盘作为输入设备，那么该命令会以指定的文件作为输入设备，并将文件中的内容读取并显示到控制台 cat cat 输出重定向：把命令（或可执行程序）的标准输出或标准错误输出重新定向到指定文件中。这样，该命令的输出就不显示在屏幕上，而是写入到指定文件中 命令>文件，将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据 命令2>文件，将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据 命令>>文件，将命令执行的标准输出结果重定向输出到指定的文件中，如果该文件已包含数据，新数据将追加入到原有内容的后面 命令2>>文件，将命令执行的错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将追加到原有内容的后面 6.2 管道 管道：管道是一种通信机制，通常用于进程间的通信。它表现出来的形式是将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin） 管道又分为 匿名管道 和 具名管道，我们在使用过滤程序时经常会用到匿名管道，在命令行中由 “|” 分隔符表示，其语法格式为： command1 | command2 command1 | command2 [ | commandN... ] 当在两个命令之间设置管道时，管道符 | 左边命令的输出就变成了右边命令的输入 只要第一个命令向标准输出写入，第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道 管道可以和重定向连用 7 打包和压缩 7.1 打包tar Linux 中最常用的归档（打包）命令是 tar，该命令可用于打包和解打包 当 tar 命令用于打包操作时，命令格式为： tar [选项] 源文件或目录 参数说明 -c：将多个文件或目录进行打包 -v：显示打包文件过程 -f 包名：指定包的文件名 -A：追加 tar 文件到归档文件 举例说明 指定包名 把 anaconda-ks.cfg打包为 anaconda-ks.cfg.tar文件 tar -cvf Handout.tar Handout 打包多个文件 把 Handout文件和Software目录打包成ana.tar文件包 tar -cvf ana.tar Handout Software/ 当 tar 命令用于解打包操作时，命令格式为： tar [选项] 压缩包 参数说明 -x：对 tar 包做解打包操作 -v：显示解打包的具体过程 -f：指定要解压的 tar 包的包名 -t：只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作 -C 目录：指定解打包位置 举例说明 解打包到当前目录 tar -xvf Software.tar 把文件包ana.tar解打包到demo01_ws文件下 tar -xvf ana.tar -C demo01_ws 只查看文件包中有哪些文件 tar -tvf ana.tar 7.2 压缩 gzip gzip 是 Linux 系统中经常用来对文件进行压缩和解压缩的命令，通过此命令压缩得到的新文件，其扩展名标记为“.gz” gzip 命令只能用来压缩文件，不能压缩目录，即使指定了目录，也只能压缩目录内的所有文件 gzip 命令的基本格式如下： gzip [选项] 源文件 命令中的源文件，当进行压缩操作时，指普通文件；当进行解压缩操作时，指压缩文件 参数说明： -c：将压缩数据输出到标准输出中，并保留源文件 -d：对压缩文件进行解压缩 -r：递归压缩指定目录下以及子目录下的所有文件 -v：对于每个压缩和解压缩的文件，显示相应的文件名和压缩比 -l：对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称 -数字：用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6 举例说明 基本压缩，不保留源文件 gzip install.log 保留源文件压缩 gzip -c anaconda-ks.cfg>anaconda-ks.cfg.gz 压缩目录 gzip命令不会打包目录，把test目录下所有的子文件分别压缩 gunzip gunzip 是一个使用广泛的解压缩命令，它用于解压被 gzip 压缩过的文件（扩展名为 .gz） 备注：对于解压被 gzip 压缩过的文件，还可以使用 gzip 命令，即 gzip -d 压缩包 gunzip 命令的基本格式为： gunzip [选项] 文件 参数说明： -r：递归处理，解压缩指定目录下以及子目录下的所有文件 -c：把解压缩后的文件输出到标准输出设备 -f：强制解压缩文件，不理会文件是否已存在等情况 -l：列出压缩文件内容 -v：显示命令执行过程 -t：测试压缩文件是否正常，但不对其做解压缩操作 举例说明： 直接解压缩文件 gunzip install.log.gz 解压目录下的内容 bzip2 bzip2 命令同 gzip 命令类似，只能对文件进行压缩（或解压缩），对于目录只能压缩（或解压缩）该目录及子目录下的所有文件 bzip2 命令的基本格式如下： bzip2 [选项] 源文件 参数说明： -d：执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件 -k：bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项 -f：bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件 -t：测试压缩包文件的完整性 -v：压缩或解压缩文件时，显示详细信息 -数字：用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高 gzip 不打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；bzip2 命令不支持压缩目录，没有“-r”选项 举例说明： 直接压缩文件,将anaconda-ks.cfg文件压缩成\".bz2\"格式 bzip2 anaconda-ks.cfg 压缩的同时保留源文件 bzip2 -k install.log.syslog bunzip2 解压“.bz2”格式的压缩包文件，除了使用“bzip2 -d 压缩包名”命令外，还可以使用 bunzip2 命令 bunzip2 命令的基本格式如下： bunzip2 [选项] 源文件 参数说明： -k：解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数 -f：解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项 -v：显示命令执行过程 -L：列出压缩文件内容 -t：测试压缩文件是否正常，但不对其做解压缩操作 举例说明： 直接解压缩文件 bunzip2 install.log.bz2 解压test目录下的内容 bunzip2 -r test/ zip “.zip”格式文件是 Windows 和 Linux 系统都通用的压缩文件类型 zip 命令的基本格式如下： zip [选项] 压缩包名 源文件或源目录列表 zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用 参数说明： -r：递归压缩目录，即将制定目录下的所有文件以及子目录全部压缩 -m：将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中 -v：显示详细的压缩过程信息 -q 在压缩的时候不显示命令的执行过程 -u：更新压缩文件，即往压缩文件中添加新文件 -压缩级别：压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好 举例说明： 压缩单个文件，压缩文件到ana.zip压缩包中 zip ana.zip anaconda-ks.cfg 压缩多个文件,同时压缩多个文件到test.zip压缩包中 zip test.zip install.log install.log.syslog unzip unzip 命令可以查看和解压缩 zip 文件，该命令的基本格式如下： unzip [选项] 压缩包名 参数说明： -d 目录名：将压缩文件解压到指定目录 -n：解压时并不覆盖已经存在的文件 -o：解压时覆盖已经存在的文件，并且无需用户确认 -v 查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作 -t：测试压缩文件有无损坏，但并不解压 -x 文件列表：解压文件，但不包含文件列表中指定的文件 举例说明： 解压缩 unzip dir1.zip 把压缩包解压到指定位置 unzip -d /tmp/ ana.zip 7.3 打包和压缩 tar.gz and tar.bz2 Linux中，打包命令可以和压缩命令同时使用，该命令的基本格式如下： tar [选项] 压缩包 源文件或目录 此处常用的选项有以下 2 个，分别是： -z：压缩和解压缩 \".tar.gz\" 格式 -j：压缩和解压缩 \".tar.bz2\"格式 举例说明： 压缩 \".tar.gz\"格式，把/temp/目录直接打包压缩为\".tar.gz\"格式， 通过\"-z\"来识别格式，\"-cvf\"和打包选项一致 tar -zcvf tmp.tar.gz /tmp/ 解压缩 \".tar.gz\"格式,解压缩tmp.tar.gz文件包 tar -zxvf tmp.tar.gz 压缩 \".tar.bz2\"格式把/temp/目录直接打包压缩为\".tar.bz2\"格式 tar -jcvf tmp.tar.bz2 /tmp/ 解压缩 \".tar.bz2\"格式,解压缩tmp.tar.bz2文件包 tar -jxvf tmp.tar.bz2 8 权限管理 8.1 用户组 8.1.1 访问者身份 文件访问者身份是指文件权限设置所针对的用户和用户组，共有以下3种类型： 所有者：每个文件都有它的所有者，又称属主，简写为u。默认情况下，文件的创建者即为其所有者。所有者对文件具有所有权，是一种特别权限 所属组：指文件所有者所属的组，简称属组，简写为g，可为该组指定访问权限。默认情况下，文件的创建者的主要组即为该文件的所属组 其他用户：指文件所有者和所属组，以及root之外的所有用户，简写为o。通常其他用户对文件拥有最低的权限，甚至没有权限 8.2 权限模式 8.2.1 访问权限 对于每个文件，针对上述3类身份的用户可指定以下3种不同级别的访问权限： 读：读取文件内容或者查看目录 写：修改文件内容或者创建、删除文件 执行：执行文件或者允许使用cd命令进入目录 文件访问者身份、访问权限都包括在文件属性中，使用ls -l(ll)命令显示文件详细信息 第1个字符表示文件类型，第2个字段表示该文件的链接数目，1表示有一个硬链接，第3个字段表示这个文件的所有者，第4个字段表示这个文件的所属组，后面3个字段分别表示文件大小、修改日期和文件名称 第1个字符表示文件类型，d表示目录文件，-表示普通文件，l表示链接文件，b表示块设备文件，c表示字符设备文件 2-10字符分别表示文件所有者、所属组和其他用户的权限 3种文件权限依次用r、w和x表示读、写和执行，如果没有某种权限，则在相应权限位置用-表示 8.2.2 访问权限-二进制表示 读、写和执行可用8进制数字表示： 读：r --> 4 写：w --> 2 执行：x --> 1 8.3 命令行工具 chown 文件所有者可以变更，即将所有权转让给其他用户，只有root才有权变更所有者 使用 chown 命令变更文件所有者，使其他用户对文件具有所有权，基本用法如下： chown [选项] [新所有者] 文件列表 使用选项-R进行递归变更，即目录连同其子目录下的所有文件的所有者都变更,执行 chown 命令需要 root 权限，需要使用 sudo 命令 举例说明：将 news 的所有者改为 wang sudo chown wang news chgrp 使用 chown 命令变更文件所属组，使其他用户对文件具有所有权，基本用法如下： chown [选项] [新所有者]:[新的所属组] 文件列表 使用选项-R进行递归变更，即目录连同其子目录下的所有文件的所属组都变更 可以使用 chgrp 命令可以变更文件的所属组，基本用法如下： chgrp [选项] [新的所属组] 文件列表 举例说明:改变文件fenti所属组为shentong chgrp shentong fenti chmod root 和文件所有者可以修改文件访问权限，使用 chmod 命令来修改文件权限，基本用法如下： chmod [选项] 模式 文件名 模式是文件权限的表达式，有字符和数字两种表示方法 使用选项-R表示递归设置指定目录下所有文件的权限 文件权限用字符表示： “+”表示增加某种权限，”-”表示撤销某种权限，”=”表示指定某种权限（同时会取消其他权限） 对于用户类型，所有者、所属组和其他用户分别用字符 u、g、o表示，全部用户（包括3种用户）则用a表示 权限类型用r（读）、w（写）和x（执 行）表示 举例说明： 给所属组用户增加写权限，给其他用户增加读权限 chmod g+w, o+r /home/ros/myfile 同时撤销所属组和其他用户对该文件的读权限 chmod go-r /home/ros/myfile 对所有用户赋予读和执行权限 chmod a=rx /home/ros/myfile 文件权限用数字表示： 将权限读（r ）、写（w ）和执行（x ）分别用数字 4、2 和 1 表示，没有任何权限则表示为 0 每一类用户的权限用其各项权限的和表示(结果为数字0~7),依次为所有(u)、所属组(g)和其他用户(0)的权限 举例说明 754表示所有者、所属组和其他用户的权限依次为[4+2+1]、[4+0+1]、[4+0+0]，转化为字符表示就是：rwxr-xr-- 文件file的所有者拥有读写权限，所属组用户和其他用户只能读取 chmod 644 file 相当于 chmod u=rw,go=r file 9 软件包管理 9.1 Linux 软件包 Linux下的软件包分为两种，分别是 源码包 和 二进制包： 源码包：源码包是源代码程序，是由程序员按照特定的格式和语法编写出来的软件包 源码包安装需要经过编译 编译：指从源代码到直接被计算机执行的目标代码的翻译过程，编译器的功能是把源代码翻译为二进制代码，让计算机识别并运行 源码包一般包含多个文件，为了方便发布，通常会将源码包做打包压缩处理 二进制包，是指源码包经过成功编译之后产生的软件包 二进制包是 Linux 下默认的软件安装包，二进制包有专用的包管理系统 RPM 包管理系统：Fedora、CentOS、SuSE软件包管理工具 DPKG 包管理系统：Debian 和 Ubuntu 的软件包管理工具 9.2 源码包安装流程 源码包：Linux 中最常用的打包压缩格式为“tar.gz”，因此源码包又被称为 Tarball 整个安装过程可以分为以下几步： 找到相应的软件包soft，比如soft.tar.gz，下载到本机某个目录 打开一个终端，su成root用户 cd soft.tar.gz 所在的目录 tar -zxvf soft.tar.gz cd soft ./configure make make .install 上述安装过程可以概括为以下几步： 取得应用软件：通过下载、购买光盘的方法获得 解压缩文件：如果是 gz 格式，则可以执行：“tar –zxvf 软件包名”，就可以一步完成解压与解包工作。如果不是，则先用解压软件，再执行“tar –xvf 解压后的tar包”进行解包 阅读附带的 INSTALL 文件、README文件 执行“./configure”命令为编译做好准备 执行“make”命令进行软件编译 执行“make install”完成安装 执行“make clean”删除安装时产生的临时文件 注解 对于多数需要编译的软件，其安装的方法大体相同：执行解压缩后产生的一个名为 configure 的可执行脚本程序 configure 用于检查系统是否有编译时所需的库，以及库的版本是否满足编译的需要等安装所需要的系统信息。为随后的编译工作做准备。执行命令为：./configure 如果检查过程中，发现有错误，configure将给予提示，并停止检查。用户可以跟据提示对系统进行配置，再重新执行该程序 检查通过后，将生成用于编译的 MakeFile 文件。此时，可以开始进行编译，执行命令为：make 成功编译后，键入如下的命令开始安装,执行命令为：make install 安装完毕，清除编译过程中产生的临时文件和配置过程中产生的文件。执行命令：make clean 一般来说，Linux的应用软件的可执行文件会存放在 /usr/local/bin 目录下，具体看INSTALL 和 README文件 9.3 Deb 包安装流程 Deb 包可从 Ubuntu 软件中心下载安装 Deb 是 Debian 软件包格式的文件扩展名，有两种安装deb包的方法：apt 和 dpkg apt 能在线下载并安装 deb 包，能更新系统，且还能自动处理包与包之间的依赖问题，这是 dpkg 工具所不具备的，apt方式安装deb包步骤如下： 打开一个终端，su成root用户 apt-cache search soft # 注：soft是你要找的软件的名称或相关信息 如果2中找到了软件soft.version，则用apt install soft.version命令安装软件 apt 是 debian，ubuntu发行版的包管理工具，apt 命令一般需要 root 权限执行，所以一般跟着 sudo 命令，例如：sudo apt xxxx sudo apt install packagename ——安装一个新软件包 sudo apt remove packagename ——卸载一个已安装的软件包 sudo apt autoremove ——apt会把已装或已卸的软件都备份在硬盘上，如果需要空间的话，可以让这个命令来删除你已经删掉的软件 sudo apt autoclean ——定期运行这个命令来清除那些已经卸载的软件包的.deb 文件 sudo apt clean ——这个命令会把安装的软件的备份也删除，不会影响软件的使用 sudo apt update ——更新软件源列表 sudo apt upgrade——升级所有已安装的软件包 sudo apt dist-upgrade——将系统升级到新版本 sudo apt-cache search string——在软件包列表中搜索字符串 sudo apt-cache showpkg pkgs ——显示软件包信息 sudo apt-cache show pkgs ——显示软件包记录 sudo apt-cache pkgnames——打印软件包列表中所有软件包的名称 dpkg 方式安装 deb 包步骤如下： 找到相应的软件包，比如 soft.version.deb，下载到本机某个目录 打开一个终端，su成root用户 cd soft.version.deb所在的目录 输入dpkg -i soft.version.deb 安装：dpkg -i deb的软件包名，如dpkg -i software-1.2.3-1.deb 卸载：dpkg -e 软件名，如dpkg -e software 查询：dpkg -l 软件名，如dpkg -l software 9.4 bin文件安装 如果软件名是 soft.bin，一般情况下是个可执行文件，安装方法如下： 打开一个终端，su成root用户 chmod +x soft.bin /soft.bin # 运行这个命令就可以执行软件安装 9.5 免安装软件包 有些软件是不需要安装的，解压缩后可直接运行，假设下载的是firefox.tar.gz，使用方法如下： 打开一个终端，su成root用户 tar -zxvf firefox.tar.gz # 这一步会生成一个叫 firefox 的目录 cd firefox chmod +x firefox # 设置 firefox 这个程序文件为可运行 执行命令./firefox 即可运行软件 每次运行要输入全路径或切换到生成的 firefox 目录里才可执行，在/bin目录下建立一个firefox的软链接，则打开一个终端输入 firefox 就可以运行此软件 如果要想 firefox 有个菜单项，使用菜单编辑工具，如 Alacarte Menu Editor，也可以到 /usr/share/applications目录，按照里面其它 *.desktop 文件的格式生成一个自己的 desktop 文件 9.6 PPA 安装 APT 和 Ubuntu 软件中心都是通过软件源方式安装软件，APT会从每一个软件源（软件仓库）下载一个软件包的列表到本地，列表中提供有软件源所包含的可用软件包的信息 通常从 Ubuntu 官方仓库中获取软件，考虑到稳定性，Ubuntu 官方仓库收录的软件比较正式，版本相对滞后 对于没有收录到 Ubuntu 官方仓库的软件，可以通过 PPA(Personal Package Archive)非正式的软件仓库进行安装，其格式如下： sudo add-apt-repository ppa:user/ppa-name sudo apt-get update sudo apt-get install ppa-name new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter2.html":{"url":"Markdown/Ubuntu/chapter2.html","title":"2 常用工具","keywords":"","body":"2 常用工具 此部分记录 Ubuntu 中常用软件工具的使用方法new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter2-1.html":{"url":"Markdown/Ubuntu/chapter2-1.html","title":"2.1 Cmake","keywords":"","body":"2.1 Cmake CMake Practice（CMake 实践） -- Cjacker 为了阅读方便，本文档整理摘抄自互联网上的PDF版本，仅供学习参考使用。 前言 cmake 已经开发了 5、6 年的时间，如果没有 KDE4，也许不会有人或者 Linux 发行版本重视 cmake，因为除了 Kitware 似乎没有人使用它。通过 KDE4 的选型和开发，cmake 逐渐进入了人们的视线，在实际的使用过程中，cmake 的优势也逐渐的被大家所认识，至少 KDE 的开发者们给予了 cmake 极高的评价，同时庞大的 KDE 项目使用 cmake 来作为构建工具也证明了 cmake 的可用性和大项目管理能力。 所以，cmake 应该感谢 KDE，也正因为如此，cmake 的开发者投入了 KDE 从 autotools 到 cmake 的迁移过程中，并相当快速和顺利的完成了迁移，现在整个 KDE4 开发版本全部使用 cmake 构建。 这也是促使我们学习 cmake 的原因，首先 cmake 被接受并成功应用，其次，cmake 的优势在实际使用中不断的体现出来。 我们为什么不来认识一下这款优秀的工程构建工具呢？ 在 2006 年 KDE 大会，听 cmake 开发者当面介绍了 cmake 之后，我就开始关注 cmake，并将 cmake 纳入了 Everest 发行版，作为系统默认组件。最近 QT-4.3 也正式进入了 Everest 系统，为 KDE4 构建完成了准备工作。 但是，在学习 cmake 的过程中，发现官方的文档非常的少，而且错误也较多，比如：在介绍 Find 模块编写的文档中，模块名称为 FOO，但是后面却出现了 Foo_FIND_QUIETLY 的定义，这显然是错误的，这样的定义永远不可能有效，正确的定义是 FOO_FIND_QUIETLY。种种原因，促使我开始写一份“面向使用和实用”的 cmake 文档，也就是本教程《cmake 实践》(Cmake Practice)。 本文档是边学习边编写的成果，更像是一个学习笔记和 Tutorial，因此难免有失误或者理解不够透彻的地方，比如，我仍然不能理解为什么绝大部分使用变量的情况要通过${}引用，而在 IF 语句中却必须直接使用变量名。也希望能够有 cmake 的高手来指点迷津。 补：从 cmake 的 maillist，我找到了一些答案，原文是： The IF(var)or IF(NOT var) command expects var to be the name of a variable. This is stated in CMake's manual. So, for your situation IF(${libX}) is the same as IF(/usr/lib/xorg) and then CMake will check the value of the variable named /usr/lib/xorg. 也就是说 IF 需要的是变量名而不是变量值。 这个文档是开放的，开放的目的是为了让更多的人能够读到并且能够修改，任何人都可以对它作出修改和补充，但是，为了大家都能够获得你关于 cmake 的经验和积累，如果你发现错误或者添加了新内容后，请务必 CC 给我一份，让我们共同把 cmake 掌握的更好。 一、初识 cmake CMake 不再使你在构建项目时郁闷地想自杀了。 --一位 KDE 开发者 1. 背景知识 cmake 是 kitware 公司以及一些开源开发者在开发几个工具套件(VTK)的过程中的衍生品，最终形成体系，成为一个独立的开放源代码的项目。项目的诞生时间是 2001 年。其官方网站是 www.cmake.org，可以通过访问官方网站获得更多关于 cmake 的信息。cmake 的流行其实要归功于 KDE4 的开发(似乎跟当年的 svn 一样，KDE 将代码仓库从 CVS 迁移到 SVN，同时证明了 SVN 管理大型项目的可用性)，在 KDE 开发者使用了近 10 年 autotools 之后，他们终于决定为 KDE4 选择一个新的工程构建工具，其根本原因用 KDE 开发者的话来说就是：只有少数几个“编译专家”能够掌握 KDE 现在的构建体系(admin/Makefile.common)。在经历了 unsermake， scons 以及 cmake 的选型和尝试之后，KDE4 决定使用 cmake 作为自己的构建系统。在迁移过程中，进展异常的顺利，并获得了 cmake 开发者的支持。所以，目前的 KDE4 开发版本已经完全使用 cmake 来进行构建。像 kdesvn，rosegarden 等项目也开始使用cmake，这也注定了 cmake 必然会成为一个主流的构建体系。 2. 特点 cmake 的特点主要有： 开放源代码，使用类 BSD 许可发布 http://cmake.org/HTML/Copyright.html 跨平台，并可生成 native 编译配置文件，在 Linux/Unix 平台，生成 makefile；在苹果平台，可以生成 xcode；在 Windows 平台，可以生成 MSVC 的工程文件。 能够管理大型项目，KDE4 就是最好的证明。 简化编译构建过程和编译过程。Cmake 的工具链非常简单：cmake+make。 高效虑，按照 KDE 官方说法，CMake 构建 KDE4 的 kdelibs 要比使用 autotools 来构建 KDE3.5.6 的 kdelibs 快 40%，主要是因为 Cmake 在工具链中没有 libtool。 可扩展，可以为 cmake 编写特定功能的模块，扩充 cmake 功能。 3. 问题，难道就没有问题？ cmake 很简单，但绝对没有听起来或者想象中那么简单。 cmake 编写的过程实际上是编程的过程，跟以前使用 autotools 一样，不过你需要编写的是 CMakeLists.txt(每个目录一个)，使用的是”cmake 语言和语法”。 cmake 跟已有体系的配合并不是特别理想，比如 pkgconfig，您在实际使用中会有所体会，虽然有一些扩展可以使用，但并不理想。 4. 个人的建议 如果你没有实际的项目需求，那么看到这里就可以停下来了，因为 cmake 的学习过程就是实践过程，没有实践，读的再多几天后也会忘记。 如果你的工程只有几个文件，直接编写 Makefile 是最好的选择。 如果使用的是 C/C++/Java 之外的语言，请不要使用 cmake(至少目前是这样)。 如果你使用的语言有非常完备的构建体系，比如 java 的 ant，也不需要学习 cmake，虽然有成功的例子，比如 QT4.3 的 csharp 绑定 qyoto。 如果项目已经采用了非常完备的工程管理工具，并且不存在维护问题，没有必要迁移到 cmake 。 如果仅仅使用 qt 编程，没有必要使用 cmake，因为 qmake 管理 Qt 工程的专业性和自动化程度比 cmake 要高很多。 二、安装 cmake 还需要安装吗？ cmake 目前已经成为各大 Linux 发行版提供的组件，比如 Everest 直接在系统中包含，Fedora 在 extra 仓库中提供，所以，需要自己动手安装的可能性很小。如果你使用的操作系统(比如 Windows 或者某些 Linux 版本)没有提供 cmake 或者包含的版本较旧，建议你直接从 cmake 官方网站下载安装。 http://www.cmake.org/HTML/Download.html 在这个页面，提供了源代码的下载以及针对各种不同操作系统的二进制下载，可以选择适合自己操作系统的版本下载安装。因为各个系统的安装方式和包管理格式有所不同，在此就不再赘述了，相信一定能够顺利安装 cmake。 三、初试 cmake — cmake 的 helloworld Hello world，世界 你好 本节选择了一个最简单的例子 Helloworld 来演练一下 cmake 的完整构建过程，本节并不会深入的探讨 cmake，仅仅展示一个简单的例子，并加以粗略的解释。我们选择了 Everest Linux 作为基本开发平台，因为这个只有一张 CD 的发行版本，包含了 gcc4.2/gtk/qt3/qt4等完整的开发环境，同时，系统默认集成了 cmake 最新版本 2.4.6。 [info] 备注：此处使用 Ubuntu 操作亦可 1. 准备工作 首先，在家目录下新建 /backup 目录， 在 /backup 目录下建立一个 cmake 目录，用来放置我们学习过程中的所有练习。 cd ~ mkdir -p /backup/cmake 以后我们所有的 cmake 练习都会放在 /backup/cmake 的子目录下(你也可以自行安排目录，这个并不是限制，仅仅是为了叙述的方便)。 然后在 cmake 建立第一个练习目录 t1： cd /backup/cmake mkdir t1 cd t1 在 t1 目录建立 main.c 和 CMakeLists.txt(注意文件名大小写)： main.c 文件内容： // main.c #include int main() { printf(\"Hello World from t1 Main!\\n\"); return 0; } CmakeLists.txt 文件内容： PROJECT(HELLO) SET(SRC_LIST main.c) MESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINARY_DIR}) MESSAGE(STATUS \"This is SOURCE dir \" ${HELLO_SOURCE_DIR}) ADD_EXECUTABLE(hello ${SRC_LIST}) 2. 开始构建 所有的文件创建完成后，t1 目录中应该存在 main.c 和 CMakeLists.txt 两个文件。接下来我们来构建这个工程，在这个目录中点击右键，打开终端，在终端中输入：cmake . (注意命令后面的点号，代表本目录)。 输出大概是这个样子： -- The C compiler identification is GNU 9.4.0 -- The CXX compiler identification is GNU 9.4.0 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ -- works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- This a BINARY dir /home/qlf/backup/cmake/t1 -- This a SOURCE dir /home/qlf/backup/cmake/t1 -- Configuring done -- Generating done -- Build files have been written to: /home/qlf/backup/cmake/t1 再让我们看一下目录中的内容，你会发现，系统自动生成了： CMakeFiles，CMakeCache.txt，cmake_install.cmake 等文件，并且生成了 Makefile。 然后进行工程的实际构建，继续在终端中输入 make 命令，大概会得到如下的彩色输出： Scanning dependencies of target hello [ 50%] Building C object CMakeFiles/hello.dir/main.c.o [100%] Linking C executable hello [100%] Built target hello 如果你需要看到 make 构建的详细过程，可以使用 make VERBOSE=1 或者 VERBOSE=1 make 命令来进行构建。 这时候，我们需要的目标文件 hello 已经构建完成，位于当前目录，尝试在终端中输入： ./hello 得到输出： Hello World from t1 Main! 恭喜您，到这里为止您已经完全掌握了 cmake 的使用方法。 3. 简单的解释 我们来重新看一下 CMakeLists.txt，这个文件是 cmake 的构建定义文件，文件名是大小写相关的，如果工程存在多个目录，需要确保每个要管理的目录都存在一个 CMakeLists.txt。(关于多目录构建，后面我们会提到，这里不作过多解释)。 上面例子中的 CMakeLists.txt 文件内容如下： PROJECT (HELLO) SET(SRC_LIST main.c) MESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINARY_DIR}) MESSAGE(STATUS \"This is SOURCE dir \" ${HELLO_SOURCE_DIR}) ADD_EXECUTABLE(hello ${SRC_LIST}) PROJECT 指令的语法是： PROJECT(projectname [CXX] [C] [Java]) 你可以用这个指令定义工程名称，并可指定工程支持的语言，支持的语言列表是可以忽略的，默认情况表示支持所有语言。这个指令隐式的定义了两个 cmake 变量： _BINARY_DIR 以及 _SOURCE_DIR，这里就是 HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR (所以 CMakeLists.txt 中两个 MESSAGE 指令可以直接使用了这两个变量)，因为采用的是内部编译，两个变量目前指的都是工程所在路径/backup/cmake/t1，后面我们会讲到外部编译，两者所指代的内容会有所不同。 同时 cmake 系统也帮助我们预定义了 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR 变量，他们的值分别跟 HELLO_BINARY_DIR 与 HELLO_SOURCE_DIR 一致。 为了统一起见，建议以后直接使用PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，即使修改了工程名称，也不会影响这两个变量。如果使用了，修改工程名称后，需要同时修改这些变量。 SET指令的语法是： SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) 现阶段，你只需要了解 SET 指令可以用来显式的定义变量即可。比如我们用到的是SET(SRC_LIST main.c)，如果有多个源文件，也可以定义成：SET(SRC_LIST main.c t1.c t2.c)。 MESSAGE语法的指令是： MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] \"message to display\" ...) 这个指令用于向终端输出用户定义的信息，包含了三种类型： SEND_ERROR，产生错误，生成过程被跳过 STATUS，输出前缀为--的信息 FATAL_ERROR，立即终止所有cmake过程 我们在这里使用的是 STATUS 信息输出，演示了由 PROJECT 指令定义的两个隐式变量 HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR。 ADD_EXECUTABLE(hello ${SRC_LIST}) 定义了这个工程会生成一个文件名为 hello 的可执行文件，相关的源文件是 SRC_LIST 中定义的源文件列表， 本例中你也可以直接写成ADD_EXECUTABLE(hello main.c)。 在本例我们使用了${}来引用变量，这是 cmake 的变量引用方式。但是，有一些例外，比如在 IF 控制语句，变量是直接使用变量名引用，而不需要${}。如果使用了${}去应用变量，其实 IF 会去判断名为${}所代表的值的变量，那当然是不存在的了。 将本例改写成一个最简化的CMakeLists.txt： PROJECT(HELLO) ADD_EXECUTABLE(hello main.c) 4. 基本语法规则 前面提到过，cmake 其实仍然要使用”cmake 语言和语法”去构建，上面的内容就是所谓的 ”cmake 语言和语法”，最简单的语法规则是： 变量使用${}方式取值，但是在 IF 控制语句 中是直接使用变量名。 指令(参数1 参数2...) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.c 源文件，就要写成： ADD_EXECUTABLE(hello main.c func.c)或者 ADD_EXECUTABLE(hello main.c;func.c) 指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令。 上面的 MESSAGE 指令已经用到了这条规则： MESSAGE(STATUS “This is BINARY dir” ${HELLO_BINARY_DIR}) 也可以写成： MESSAGE(STATUS “This is BINARY dir ${HELLO_BINARY_DIR}”) 这里需要特别解释的是作为工程名 HELLO 和生成的可执行文件 hello 是没有任何关系的。hello 定义的可执行文件的文件名，你完全可以写成：ADD_EXTCUTABLE(t1 main.c)，编译后会生成一个 t1 可执行文件。 5. 关于语法的疑惑 cmake 的语法还是比较灵活而且考虑到各种情况，比如 SET(SRC_LIST main.c) 也可以写成 SET(SRC_LIST \"main.c\") 是没有区别的，但是假设一个源文件的文件名是 fu nc.c(文件名中间包含了空格)。 这时候就必须使用双引号，如果写成了SET(SRC_LIST fu nc.c)，就会出现错误，提示你找不到 fu 文件和 nc.c 文件。这种情况，就必须写成：SET(SRC_LIST \"fu nc.c\")。 此外，你可以可以忽略掉 source 列表中的源文件后缀，比如可以写成 ADD_EXECUTABLE(t1 main)，cmake 会自动的在本目录查找 main.c 或者 main.cpp 等，当然，最好不要偷这个懒，以免这个目录确实存在一个 main.c 一个 main。 同时参数也可以使用分号来进行分割。 下面的例子也是合法的： ADD_EXECUTABLE(t1 main.c t1.c) 可以写成 ADD_EXECUTABLE(t1 main.c;t1.c)。 我们只需要在编写 CMakeLists.txt 时注意形成统一的风格即可。 6. 清理工程 跟经典的 autotools 系列工具一样，运行： make clean 即可对构建结果进行清理。 7. 问题？问题！ “我尝试运行了 make distclean，这个指令一般用来清理构建过程中产生的中间文件的，如果要发布代码，必然要清理掉所有的中间文件，但是为什么在 cmake 工程中这个命令是无效的?” 是的，cmake 并不支持 make distclean，关于这一点，官方是有明确解释的： 因为 CMakeLists.txt 可以执行脚本并通过脚本生成一些临时文件，但是却没有办法来跟踪这些临时文件到底是哪些。因此，没有办法提供一个可靠的 make distclean 方案。 Some build trees created with GNU autotools have a \"make distclean\" target that cleans the build and also removes Makefiles and other parts of the generated build system. CMake does not generate a \"make distclean\" target because CMakeLists.txt files can run scripts and arbitrary commands; CMake has no way of tracking exactly which files are generated as part of running CMake. Providing a distclean target would give users the false impression that it would work as expected. (CMake does generate a \"make clean\" target to remove files generated by the compiler and linker.) A \"make distclean\" target is only necessary if the user performs an in-source build. CMake supports in-source builds, but we strongly encourage users to adopt the notion of an out-of-source build. Using a build tree that is separate from the source tree will prevent CMake from generating any files in the source tree. Because CMake does not change the source tree, there is no need for a distclean target. One can start a fresh build by deleting the build tree or creating a separate build tree. 同时，还有另外一个非常重要的提示，就是：我们刚才进行的是内部构建(in-source build)，而 cmake 强烈推荐的是外部构建(out-of-source build)。 8. 内部构建与外部构建 上面的例子展示的是“内部构建”，相信看到生成的临时文件比您的代码文件还要多的时候，估计这辈子你都不希望再使用内部构建 :-D 举个简单的例子来说明外部构建，以编译 wxGTK 动态库和静态库为例，在 Everest 中打包方式是这样的： 解开 wxGTK 后， 在其中建立 static 和 shared 目录， 进入 static 目录，运行 ../configure –enable-static;make 会在 static 目录生成 wxGTK 的静态库， 进入 shared 目录，运行 ../configure –enable-shared;make 就会在 shared 目录生成动态库。 这就是外部编译的一个简单例子。 对于 cmake ，内部编译上面已经演示过了，它生成了一些无法自动删除的中间文件，所以，引出了我们对外部编译的探讨，外部编译的过程如下： 首先请清除 t1 目录中除 main.c、CMakeLists.txt之外的所有中间文件，最关键的是CMakeCache.txt。 在 t1 目录中建立 build 目录，当然你也可以在任何地方建立 build 目录，不一定必须在工程目录中。 进入 build 目录 ，在终端中执行cmake ..（注意，..代表父目录，因为父目录存在我们需要的 CMakeLists.txt，如果你在其他地方建立了 build 目录，需要运行 cmake ），查看一下 build 目录，就会发现生成了编译需要的 Makefile 以及其他的中间文件。 继续在终端中运行 make 构建工程，就会在当前目录（build 目录）中获得目标文件 hello。 上述过程就是所谓的 out-of-source 外部编译，一个最大的好处是，对于原有的工程没有任何影响，所有动作全部发生在编译目录。通过这一点，也足以说服我们全部采用外部编译方式构建工程。 这里需要特别注意的是： 通过外部编译进行工程构建，HELLO_SOURCE_DIR仍然指代工程目录，即/backup/cmake/t1，而HELLO_BINARY_DIR则指代编译路径，即/backup/cmake/t1/build。 9. 小结 本小结描述了使用 cmake 构建 Hello World 程序全部过程，并介绍了三个简单的指令：PROJECT/MESSAGE/ADD_EXECUTABLE 以及变量调用的方法，同时提及了两个隐式变量 _SOURCE_DIR 及_BINARY_DIR，演示了变量调用的方法。从这个过程来看，有些开发者可能会想，这实在比我写 Makefile 要复杂多了，甚至我都可以不编写 Makefile，直接使用gcc main.c即可生成需要的目标文件。是的，正如第一节提到的，如果工程只有几个文件，还是直接编写 Makefile 最简单。但是，kdelibs 压缩包达到 50M，您认为使用什么方案更容易一点呢？ 下一节，我们的任务是让 Hello World 看起来更像一个工程。 四、更好一点的 Hello world 没有最好，只有更好 从本小节开始，后面所有的构建我们都将采用 out-of-source 外部构建，约定的构建目录是工程目录下的 build 自录。 本小节的任务是让前面的 Hello World 更像一个工程，我们需要做的是： 为工程添加一个子目录 src，用来放置工程源代码 添加一个子目录 doc，用来放置这个工程的文档 hello.txt 在工程目录添加文本文件 COPYRIGHT，README 在工程目录添加一个 runhello.sh 脚本，用来调用 hello 二进制 将构建后的目标文件放入构建目录的 bin 子目录 最终安装这些文件：将 hello 二进制与 runhello.sh 安装至//bin，将doc 目录下的内容以及 COPYRIGHT、README 安装到//usr/share/doc/cmake/t2 备注：表示预定义的路径 1. 准备工作 在~/backup/cmake/目录下建立 t2 目录。 将 t1 工程的 main.c 和 CMakeLists.txt 拷贝到 t2 目录中。 2. 添加子目录src 在t2目录中，打开终端，执行： mkdir src mv main.c src 现在的工程看起来是这个样子： 一个子目录 src，一个 CMakeLists.txt。 上一节我们提到，需要为任何子目录建立一个 CMakeLists.txt，进入子目录 src，编写 CMakeLists.txt 如下： ADD_EXECUTABLE(hello main.c) 将 t2 目录下的 CMakeLists.txt 修改为： PROJECT(HELLO) ADD_SUBDIRECTORY(src bin) 然后建立 build 目录，进入 build 目录进行外部编译： cmake .. make 编译过程中可能会出现No cmake_minimum_required command is present.的警告，这个不影响项目构建，忽略即可。 构建完成后，你会发现生成的目标文件 hello 位于 build/bin 目录中。 语法解释： ADD_SUBDIRECTORY 指令 ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除。比如，工程的 example，可能就需要工程构建完成后，再进入 example 目录单独进行构建(当然，你也可以通过定义依赖来解决此类问题)。 上面的例子定义了将 src 子目录加入工程，并指定编译输出(包含编译中间结果)路径为 bin 目录。如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在 build/src 目录(这个目录跟原有的 src 目录对应)，指定 bin 目录后，相当于在编译时将 src 重命名为 bin，所有的中间结果和目标二进制都将存放在 bin 目录。 这里需要提一下的是 SUBDIRS 指令，使用方法是： SUBDIRS(dir1 dir2...)，但是这个指令已经不推荐使用。它可以一次添加多个子目录，并且，即使外部编译，子目录体系仍然会被保存。 如果我们在上面的例子中将 ADD_SUBDIRECTORY (src bin) 修改为 SUBDIRS(src)，那么在 build 目录中将出现一个 src 目录，生成的目标代码 hello 将存放在 src 目录中。 3. 换个地方保存目标二进制 不论是 SUBDIRS 还是 ADD_SUBDIRECTORY 指令(不论是否指定编译输出目录)，我们都可以通过 SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量来指定最终的目标二进制的位置（指最终生成的 hello 或者最终的共享库，不包含编译生成的中间文件）。 SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin) SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) 在第一节我们提到了 _BINARY_DIR 和 PROJECT_BINARY_DIR 变量，它们指的是编译发生的当前目录。如果是内部编译，就相当于 PROJECT_SOURCE_DIR 也就是工程代码所在目录；如果是外部编译，指的是外部编译所在目录，也就是本例中的 build 目录。 所以，上面两个指令分别定义了： 可执行二进制的输出路径为 build/bin 和库的输出路径为 build/lib。 本节我们没有提到共享库和静态库的构建，所以，你可以不考虑第二条指令。 问题是，我应该把这两条指令写在t2 工程的 CMakeLists.txt 还是 src 目录下的 CMakeLists.txt。把握一个简单的原则，在哪里 ADD_EXECUTABLE 或 ADD_LIBRARY，如果需要改变目标存放路径，就在哪里加入上述的定义。 在这个例子里，当然就是指 src 下的 CMakeLists.txt 了。 4. 如何安装 安装的需要有两种，一种是从代码编译后直接 make install 安装，一种是打包时的指定目录安装。 所以，即使最简单的手工编写的 Makefile，看起来也是这个样子的： DESTDIR= install: mkdir -p $(DESTDIR)/usr/bin install -m 755 hello $(DESTDIR)/usr/bin 你可以通过：make install 将 hello 直接安装到 /usr/bin 目录，也可以通过 make install DESTDIR=/tmp/test 将它安装在 /tmp/test/usr/bin 目录，打包时这个方式经常被使用。 稍微复杂一点的是还需要定义 PREFIX，一般 autotools 工程，会运行这样的指令： ./configure --prefix=/usr 或者 ./configure --prefix=/usr/local 来指定 PREFIX 比如上面的 Makefile 就可以改写成： DESTDIR= PREFIX=/usr install: mkdir -p $(DESTDIR)/$(PREFIX)/bin install -m 755 hello $(DESTDIR)/$(PREFIX)/bin 那么我们的 HelloWorld 应该怎么进行安装呢？ 这里需要引入一个新的 cmake 指令 INSTALL 和一个非常有用的变量 CMAKE_INSTALL_PREFIX。 CMAKE_INSTALL_PREFIX 变量类似于 configure 脚本的 --prefix，常见的使用方法看起来是这个样子：cmake -DCMAKE_INSTALL_PREFIX=/usr。 INSTALL 指令用于定义安装规则，安装的内容可以包括目标二进制、动态库、静态库以及文件、目录、脚本等。 INSTALL 指令包含了各种安装类型，我们需要一个个分开解释： 1. 目标文件的安装： INSTALL(TARGETS targets... [ [ARCHIVE|LIBRARY|RUNTIME] [DESTINATION ] [PERMISSIONS permissions...] [ CONFIGURATIONS [Debug|Release|...] ] [COMPONENT ] [OPTIONAL] ] [...]) 参数中的 TARGETS 后面跟的就是我们通过 ADD_EXECUTABLE 或者 ADD_LIBRARY 定义的目标文件，可能是可执行二进制、动态库、静态库。 目标类型也就相对应的有三种，ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。 DESTINATION 定义了安装的路径，如果路径以/开头，即使用绝对路径，这时候 CMAKE_INSTALL_PREFIX 其实就无效了。如果你希望使用 CMAKE_INSTALL_PREFIX 来定义安装路径，就要写成相对路径，即不要以 /开头，那么安装后的路径就是 ${CMAKE_INSTALL_PREFIX}/。 举个简单的例子： INSTALL(TARGETS myrun mylib mystaticlib RUNTIME DESTINATION bin LIBRARY DESTINATION lib ARCHIVE DESTINATION libstatic ) 上面的例子会将： 可执行目标二进制 myrun 安装到 ${CMAKE_INSTALL_PREFIX}/bin 目录 动态库 mylib 安装到 ${CMAKE_INSTALL_PREFIX}/lib 目录 静态库 mystaticlib 安装到 ${CMAKE_INSTALL_PREFIX}/libstatic 目录 特别注意的是你不需要关心 TARGETS 具体生成的路径，只需要写上 TARGETS 名称就可以了。 2. 普通文件的安装： INSTALL(FILES files... DESTINATION [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [RENAME ] [OPTIONAL] ) 可用于安装一般文件，并可以指定访问权限，文件名是此指令所在路径下的相对路径。如果默认不定义权限 PERMISSIONS，安装后的权限为： OWNER_WRITE, OWNER_READ, GROUP_READ,和 WORLD_READ，即 644 权限。 非目标文件的可执行程序安装(比如脚本之类)： INSTALL(PROGRAMS files... DESTINATION [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [RENAME ] [OPTIONAL] ) 跟上面的 “普通文件安装” 指令使用方法一样，唯一的不同是安装后权限为： OWNER_EXECUTE, GROUP_EXECUTE, 和 WORLD_EXECUTE，即 755 权限。 3. 目录的安装： INSTALL(DIRECTORY dirs... DESTINATION [FILE_PERMISSIONS permissions...] [DIRECTORY_PERMISSIONS permissions...] [USE_SOURCE_PERMISSIONS] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [[PATTERN | REGEX ] [EXCLUDE] [PERMISSIONS permissions...]] [...] ) 这里主要介绍其中的 DIRECTORY、PATTERN 以及 PERMISSIONS 参数。 DIRECTORY 后面连接的是所在 Source 目录的相对路径，但务必注意：abc 和 abc/有很大的区别。 如果目录名不以 / 结尾，那么这个目录将被安装为目标路径下的 abc，如果目录名以 / 结尾，代表将这个目录中的内容安装到目标路径，但不包括这个目录本身。 PATTERN 用于使用正则表达式进行过滤，PERMISSIONS 用于指定 PATTERN 过滤后的文件权限。 我们来看一个例子： INSTALL(DIRECTORY icons scripts/ DESTINATION share/myproj PATTERN \"CVS\" EXCLUDE PATTERN \"scripts/*\" PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ ) 这条指令的执行结果是： 将 icons 目录安装到 /share/myproj，将 scripts/中的内容安装到 /share/myproj 不包含目录名为 CVS 的目录，对于 scripts/* 文件指定权限为 OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ。 安装时 Cmake 脚本的执行： INSTALL([[SCRIPT ] [CODE ]] [...]) SCRIPT 参数用于在安装时调用 cmake 脚本文件（也就是 .cmake 文件） CODE 参数用于执行 CMAKE 指令，必须以双引号括起来。比如： INSTALL(CODE \"MESSAGE(\\\"Sample install message.\\\")\") 安装还有几个被标记为过时的指令，比如 INSTALL_FILES 等，这些指令已经不再推荐使用，所以，这里就不再赘述了。 下面，我们就来改写我们的工程文件，让它来支持各种文件的安装，并且，我们要使用 CMAKE_INSTALL_PREFIX指令。 5. 修改 Helloworld 支持安装 在本节开头我们定义了本节的任务如下： 为工程添加一个子目录 src，用来放置工程源代码 添加一个子目录 doc，用来放置这个工程的文档 hello.txt 在工程目录添加文本文件 COPYRIGHT，README 在工程目录添加一个 runhello.sh 脚本，用来调用 hello 二进制 将构建后的目标文件放入构建目录的 bin 子目录 最终安装这些文件：将 hello 二进制与 runhello.sh 安装至//bin，将doc 目录下的内容以及 COPYRIGHT、README 安装到//share/doc/cmake/t2 首先我们先补上未添加的文件： 添加 doc 目录及文件 cd ~/backup/cmake/t2 mkdir doc sudo gedit doc/hello.txt #hello.txt中填写：这是 Cmake 练习工程 Helloworld 的 doc 说明文档 在t2工程目录中使用touch runhello.sh命令创建 runhello.sh 脚本，脚本文件中填写： ./hello 在t2工程目录中添加 COPYRIGHT 和 README文件： cd ~/backup/cmake/t2 touch COPYRIGHT touch README 下面改写各目录的 CMakeLists.txt： 安装 COPYRIGHT/README，修改t2工程目录中 CMakelists.txt，加入以下指令： INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/t2) 安装 runhello.sh，修改t2工程目录中 CMakeLists.txt，加入如下指令： INSTALL(PROGRAMS runhello.sh DESTINATION bin) 安装 doc 中的 hello.txt，这里有两种方式：一是通过在 doc 目录建立 CMakeLists.txt 并将 doc 目录通过 ADD_SUBDIRECTORY 加入工程来完成。另一种方法是直接在工程目录通过 INSTALL(DIRECTORY)来完成。前者比较简单，各位可以根据兴趣自己完成，我们来尝试后者，顺便演示以下 DIRECTORY 的安装。 因为 hello.txt 要安装到 //share/doc/cmake/t2，所以我们不能直接安装整个 doc 目录，这里采用的方式是安装 doc 目录中的内容，也就是使用 doc/。 在t2工程目录中 CMakeLists.txt 中添加： INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake/t2) @Gavin注：在 src目录的 CMakeLists.txt文件中添加如下内容，以安装 hello 到 //bin中： INSTALL(TARGETS hello RUNTIME DESTINATION bin) 6. 尝试我们修改的结果 现在进入 build 目录进行外部编译，注意使用 CMAKE_INSTALL_PREFIX 参数，这里我们将它安装到了/tmp/t2/usr目录： cmake -DCMAKE_INSTALL_PREFIX=/tmp/t2/usr .. 然后继续在终端运行： make make install 让我们进入/tmp/t2/usr目录，看一下安装结果： ./usr ./usr/share ./usr/share/doc ./usr/share/doc/cmake ./usr/share/doc/cmake/t2 ./usr/share/doc/cmake/t2/hello.txt ./usr/share/doc/cmake/t2/README ./usr/share/doc/cmake/t2/COPYRIGHT ./usr/bin ./usr/bin/hello ./usr/bin/runhello.sh 如果你要直接安装到系统，可以使用如下指令： cmake -DCMAKE_INSTALL_PREFIX=/usr .. 7. 一个疑问 如果我没有定义 CMAKE_INSTALL_PREFIX 会安装到什么地方？ 你可以尝试一下，在 build 目录中打开终端，并执行 cmake .. make make install 你会发现 CMAKE_INSTALL_PREFIX 的默认定义是 /usr/local。 8. 小结 本小节主要描述了如何在工程中使用多目录、各种安装指令以及 CMAKE_INSTALL_PREFIX 变量(你真够牛的，这么点东西居然罗唆了这么多文字)。 在下一小节，我们将探讨如何在 cmake 中构建动态库和静态库，以及如何使用外部头文件和外部共享库.毕竟，这是程序编写中最常使用的（对了，你知道用怎样的 gcc 参数可以直接构建静态库和动态库吗？） 五、静态库与动态库构建 读者云，太能罗唆了，一个 Hello World 就折腾了两个大节。OK，从本节开始，我们不再折腾 Hello World 了，我们来折腾 Hello World 的共享库。 本节的任务： 建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 安装头文件与共享库。 1. 准备工作 在 /backup/cmake 目录建立 t3 目录，用于存放本节涉及到的工程。 2. 建立共享库 cd /backup/cmake/t3 mkdir lib 在 t3 目录下建立 CMakeLists.txt，内容如下： PROJECT(HELLOLIB) ADD_SUBDIRECTORY(lib) 在 lib 目录下建立两个源文件 hello.c 与 hello.h hello.c 内容如下： #include \"hello.h\" void HelloFunc() { printf(\"Hello World\\n\"); } hello.h 内容如下： #ifndef HELLO_H #define HELLO_H #include void HelloFunc(); #endif 在 lib 目录下建立 CMakeLists.txt，内容如下： SET(LIBHELLO_SRC hello.c) ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) 3.编译共享库 仍然采用 out-of-source 编译的方式，按照习惯，我们在 t3 目录建立一个 build 目录，在 build 目录中： cmake .. make 这时，你就可以在 t3/build/lib 目录得到一个 libhello.so，这就是我们期望的共享库。 @Gavin注：在Windows的Cygwin环境下，该共享库为 cyghello.dll。 如果你需要指定 libhello.so 生成的位置，可以通过在主工程文件 CMakeLists.txt 中修改 ADD_SUBDIRECTORY(lib) 指令来指定一个编译输出位置或者在 lib/CMakeLists.txt 中添加 SET(LIBRARY_OUTPUT_PATH ) 来指定一个新的位置。 这两者的区别我们上一节已经提到了，所以，这里不再赘述。下面，我们解释一下一个新的指令 ADD_LIBRARY ： ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN ) 你不需要写全 libhello.so，只需要填写 hello 即可，cmake 系统会自动为你生成 libhello.X。 类型有三种： SHARED，动态库 STATIC，静态库 MODULE，在使用 dyld 的系统有效，如果不支持 dyld，则被当作 SHARED 对待。 EXCLUDE_FROM_ALL 参数的意思是这个库不会被默认构建，除非有其他的组件依赖或者手工构建。 4. 添加静态库 同样使用上面的指令，我们在支持动态库的基础上再为工程添加一个静态库。按照一般的习惯，静态库名字跟动态库名字应该是一致的，只不过后缀是.a 罢了。 下面我们用这个指令再来添加静态库，在 t3/lib 的 CMakeLists.txt 文件中添加如下指令： ADD_LIBRARY(hello STATIC ${LIBHELLO_SRC}) 然后再在 build 目录进行外部编译。我们会发现，静态库根本没有被构建，仍然只生成了一个动态库。因为 hello 作为一个 target 是不能重名的，所以，静态库构建指令无效。 如果我们把上面的 hello 修改为 hello_static： ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC}) 就可以构建一个 libhello_static.a 的静态库了。 这种结果显示不是我们想要的，我们需要的是名字相同的静态库和动态库，因为 target 名称是唯一的。所以，我们肯定不能通过 ADD_LIBRARY 指令来实现了。这时候我们需要用到另外一个指令： SET_TARGET_PROPERTIES，其基本语法是： SET_TARGET_PROPERTIES(target1 target2 ... PROPERTIES prop1 value1 prop2 value2 ... ) 这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本。 在本例中，我们需要做的是向 lib/CMakeLists.txt 中添加一条： SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME \"hello\") 这样，我们就可以同时得到 libhello.so/libhello.a 两个库了。 与它对应的指令是： GET_TARGET_PROPERTY(VAR target property) 具体用法如下例，我们向 lib/CMakeListst.txt 中添加： GET_TARGET_PROPERTY(OUTPUT_VALUE hello_static OUTPUT_NAME) MESSAGE(STATUS \"This is the hello_static OUTPUT_NAME:\" ${OUTPUT_VALUE}) 如果没有这个属性定义，则返回 NOTFOUND。 让我们来检查一下最终的构建结果，我们发现，libhello.a 已经构建完成，位于 build/lib 目录中，但是 libhello.so 却消失了。这个问题的原因是：cmake 在构建一个新的 target 时，会尝试清理掉其他使用这个名字的库，因此，在构建 libhello.a 时，就会清理掉 libhello.so。 @ROSIt注: 实测 libhello.so 并没有消失, 所使用版本 cmake version 3.16.3。 为了回避这个问题，比如再次使用 SET_TARGET_PROPERTIES 定义 CLEAN_DIRECT_OUTPUT 属性。 向 lib/CMakeLists.txt 中添加： SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1) SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1) 这时候，我们再次进行构建，会发现 build/lib 目录中同时生成了 libhello.so 和 libhello.a。 5. 动态库版本号 按照规则，动态库是应该包含一个版本号的，我们可以看一下系统的动态库，一般情况是： libhello.so.1.2 libhello.so ->libhello.so.1 libhello.so.1->libhello.so.1.2 为了实现动态库版本号，我们仍然需要使用 SET_TARGET_PROPERTIES 指令。 具体使用方法如下： SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1) VERSION 指代动态库版本，SOVERSION 指代 API 版本。 将上述指令加入 lib/CMakeLists.txt 中，重新构建看看结果。 在 build/lib 目录会生成： libhello.so.1.2 libhello.so.1->libhello.so.1.2 libhello.so ->libhello.so.1 6. 安装共享库和头文件 以上面的例子，我们需要将 libhello.a, libhello.so.x 以及 hello.h 安装到系统目录，才能真正让其他人开发使用。在本例中我们将 hello 的共享库安装到 /lib 目录，将 hello.h 安装到 /include/hello 目录。 利用上一节了解到的 INSTALL 指令，我们向 lib/CMakeLists.txt 中添加如下指令： INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib ) INSTALL(FILES hello.h DESTINATION include/hello) 注意，静态库要使用 ARCHIVE 关键字。 通过： make sudo make install 我们就可以将头文件和共享库安装到系统目录 /usr/lib 和 /usr/include/hello 中了。 @Gavin注：在Mac中，请安装到 /usr/local/lib目录下。 7. 小结 本小节，我们谈到了： 如何通过 ADD_LIBRARY 指令构建动态库和静态库。 如何通过 SET_TARGET_PROPERTIES 同时构建同名的动态库和静态库。 如何通过 SET_TARGET_PROPERTIES 控制动态库版本。 最终使用上一节谈到的 INSTALL 指令来安装头文件和动态、静态库。 在下一节，我们需要编写另一个高级一点的 Hello World 来演示怎么使用我们已经构建的共享库 libhello 和外部头文件。 六、如何使用外部共享库和头文件 抱歉，本节仍然继续折腾 Hello World。 上一节我们已经完成了 libhello 动态库的构建以及安装，本节我们的任务很简单： 编写一个程序使用我们上一节构建的共享库。 1. 准备工作 请在 /backup/cmake 目录建立 t4 目录，本节所有资源将存储在 t4 目录。 2. 重复以前的步骤，建立src目录，编写源文件 main.c，内容如下： #include int main(void) { HelloFunc(); return 0; } 编写 t4 工程主文件 CMakeLists.txt： PROJECT(HELLO) ADD_SUBDIRECTORY(src) 编写 src/CMakeLists.txt： ADD_EXECUTABLE(main main.c) 上述工作已经严格按照我们前面几节提到的内容完成了。 3. 外部构建 按照习惯，仍然建立 build 目录，使用 cmake .. 方式构建。 构建过程： cmake .. make 构建失败，如果需要查看细节，可以使用第一节提到的方法：make VERBOSE=1 来构建。 错误输出为是： /home/qlf/backup/cmake/t4/src/main.c:1:10: fatal error: hello.h: 没有那个文件或目录 1 | #include | ^~~~~~~~~ compilation terminated. 4. 引入头文件搜索路径 hello.h 位于 /usr/include/hello 目录中，并没有位于系统标准的头文件路径，(有人会说了，白痴啊，你就不会 include 。 同志，要这么干，我这 一节就没什么可写了，只能选择一个 glib 或者 libX11 来写了，这些代码写出来很多同志是看不懂的)。 为了让我们的工程能够找到 hello.h 头文件，我们需要引入一个新的指令 INCLUDE_DIRECTORIES，其完整语法为： INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...) 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来。默认的行为是追加到当前的头文件搜索路径的后面，你可以通过两种方式来控制搜索路径添加的方式： CMAKE_INCLUDE_DIRECTORIES_BEFORE，通过 SET 这个 cmake 变量为 on，可以将添加的头文件搜索路径放在已有路径的前面。 通过 AFTER 或者 BEFORE 参数，也可以控制是追加还是置前。 现在我们在 src/CMakeLists.txt 中添加一个头文件搜索路径，方式很简单，加入： INCLUDE_DIRECTORIES(/usr/include/hello) 进入 build 目录，重新进行构建，这时找不到 hello.h 的错误已经消失，但是出现了一个新的错误： main.c:(.text+0xe): undefined reference to `HelloFunc' 因为我们并没有 link 到共享库 libhello 上。 5. 为 target 添加共享库 我们现在需要完成的任务是将目标文件链接到 libhello，这里我们需要引入两个新的指令：LINK_DIRECTORIES 和 TARGET_LINK_LIBRARIES。 LINK_DIRECTORIES 的全部语法是： LINK_DIRECTORIES(directory1 directory2 ...) 这个指令非常简单，添加非标准的共享库搜索路径。比如，在工程内部同时存在共享库和可执行二进制，在编译时就需要指定一下这些共享库的路径。这个例子中我们没有用到这个指令。 TARGET_LINK_LIBRARIES 的全部语法是： TARGET_LINK_LIBRARIES(target library1 library2 ...) 这个指令可以用来为 target 添加需要链接的共享库。本例中是一个可执行文件，但是同样可以用于为自己编写的共享库添加共享库链接。 @ROSIt注:TARGET_LINK_LIBRARIES是一条重要指令，ROS中也会用到 为了解决前面我们遇到的 HelloFunc 未定义错误，我们需要做的是向 src/CMakeLists.txt 中添加如下指令： TARGET_LINK_LIBRARIES(main hello) 也可以写成： TARGET_LINK_LIBRARIES(main libhello.so) 这里的 hello 指的是我们上一节构建的共享库 libhello。 进入 build 目录重新进行构建： cmake .. make 这时我们就得到了一个链接到 libhello 的可执行程序 main，位于 t4/build/src 目录。切换到 t4/build/src 目录，在终端执行./main，运行结果如下： Hello World 让我们来检查一下 main 的链接情况。在 t4/build 目录中打开终端，执行ldd src/main，输出结果如下： linux-vdso.so.1 (0x00007fff44f8f000) libhello.so.1 => /lib/libhello.so.1 (0x00007f566802d000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5667e3b000) /lib64/ld-linux-x86-64.so.2 (0x00007f5668075000) 可以清楚的看到 main 确实链接了共享库 libhello，而且链接的是动态库 libhello.so.1。 那如何链接到静态库呢？ 方法很简单： 将 TARGET_LINK_LIBRRARIES 指令修改为： TARGET_LINK_LIBRARIES(main libhello.a) 重新构建后再来看一下 main 的链接情况。在 t4/build 目录中打开终端，执行ldd src/main，输出结果如下： linux-vdso.so.1 (0x00007ffdbb5e4000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f86c713a000) /lib64/ld-linux-x86-64.so.2 (0x00007f86c736f000) 说明，main 确实链接到了静态库 libhello.a。 6. 特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH 务必注意，这两个是环境变量而不是 cmake 变量。 使用方法是要在 bash 中用 export 或者在 csh 中使用 set 命令设置或者 CMAKE_INCLUDE_PATH=/home/include cmake ..等方式。 这两个变量主要是用来解决以前 autotools 工程中 --extra-include-dir 等参数的支持的。 也就是，如果头文件没有存放在常规路径(/usr/include, /usr/local/include 等)，则可以通过这些变量就行弥补。 我们以本例中的 hello.h 为例，它存放在 /usr/include/hello 目录，所以直接查找肯定是找不到的。 前面我们直接使用了绝对路径 INCLUDE_DIRECTORIES(/usr/include/hello) 告诉工程这个头文件目录。 为了将程序更智能一点，我们可以使用 CMAKE_INCLUDE_PATH 来进行，使用 bash 的方法如下，在终端中输入： export CMAKE_INCLUDE_PATH=/usr/include/hello 然后将 t4/src 目录 CMakeLists.txt 中的INCLUDE_DIRECTORIES(/usr/include/hello) 替换为： FIND_PATH(myHeader hello.h) IF(myHeader) INCLUDE_DIRECTORIES(${myHeader}) ENDIF(myHeader) 上述的一些指令我们在后面会介绍。 这里简单说明一下，FIND_PATH 用来在指定路径中搜索文件名，比如: FIND_PATH(myHeader NAMES hello.h PATHS /usr/include /usr/include/hello) 这里我们没有指定路径。但是，cmake 仍然可以帮我们找到 hello.h 存放的路径，就是因为我们设置了环境变量 CMAKE_INCLUDE_PATH。 如果你不使用 FIND_PATH，CMAKE_INCLUDE_PATH 变量的设置是没有作用的，你不能指望它会直接为编译器命令添加参数 -I。 以此为例，CMAKE_LIBRARY_PATH 可以用在 FIND_LIBRARY 中。 同样，因为这些变量直接为 FIND 指令所使用，所以所有使用 FIND_ 指令的 cmake 模块都会受益。 7. 小结 本节我们探讨了： 如何通过 INCLUDE_DIRECTORIES 指令加入非标准的头文件搜索路径。 如何通过 LINK_DIRECTORIES 指令加入非标准的库文件搜索路径。 如果通过 TARGET_LINK_LIBRARIES 为库或可执行二进制加入库链接。 并解释了如何链接到静态库。 到这里为止，您应该基本可以使用 cmake 工作了，但是还有很多高级的话题没有探讨，比如编译条件检查、编译器定义、平台判断、如何跟 pkgconfig 配合使用等等。 到这里，或许你可以理解前面讲到的“cmake 的使用过程其实就是学习 cmake 语言并编写 cmake 程序的过程”，既然是“cmake 语言”，自然涉及到变量、语法等。 下一节，我们将抛开程序的话题，看看常用的 CMAKE 变量以及一些基本的控制语法规则。 七、cmake 常用变量和常用环境变量 1. cmake 变量引用的方式 前面我们已经提到了，使用${}进行变量的引用。在 IF 等语句中，是直接使用变量名而不通过${}取值。 2. cmake 自定义变量的方式 主要有隐式定义和显式定义两种，前面举了一个隐式定义的例子，就是 PROJECT 指令，他会隐式的定义_BINARY_DIR 和_SOURCE_DIR两个变量。 显式定义的例子我们前面也提到了，使用 SET 指令，就可以构建一个自定义变量了。 比如： SET(HELLO_SRC main.c)，PROJECT_BINARY_DIR 可以通过 ${HELLO_SRC} 来引用这个自定义变量了。 3. cmake常用变量 CMAKE_BINARY_DIR PROJECT_BINARY_DIR _BINARY_DIR 这三个变量指代的内容是一致的，如果是 in source 编译，指得就是工程顶层目录；如果是 out-of-source 编译，指的是工程编译发生的目录。PROJECT_BINARY_DIR 跟其他指令稍有区别，现在，你可以理解为他们是一致的。 CMAKE_SOURCE_DIR PROJECT_SOURCE_DIR _SOURCE_DIR 这三个变量指代的内容是一致的，不论采用何种编译方式，都是工程顶层目录。 也就是在 in source 编译时，他跟 CMAKE_BINARY_DIR 等变量一致。 PROJECT_SOURCE_DIR 跟其他指令稍有区别，现在，你可以理解为他们是一致的。 CMAKE_CURRENT_SOURCE_DIR 指的是当前处理的 CMakeLists.txt 所在的路径，比如上面我们提到的 src 子目录。 CMAKE_CURRRENT_BINARY_DIR 如果是 in-source 编译，它跟 CMAKE_CURRENT_SOURCE_DIR 一致；如果是 out-ofsource 编译，他指的是 target 编译目录。 使用我们上面提到的 ADD_SUBDIRECTORY(src bin)可以更改这个变量的值。 使用 SET(EXECUTABLE_OUTPUT_PATH ) 并不会对这个变量造成影响，它仅仅修改了最终目标文件存放的路径。 CMAKE_CURRENT_LIST_FILE 输出调用这个变量的 CMakeLists.txt 的完整路径 CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行 CMAKE_MODULE_PATH 这个变量用来定义自己的 cmake 模块所在的路径。如果你的工程比较复杂，有可能会自己编写一些 cmake 模块，这些 cmake 模块是随你的工程发布的。为了让 cmake 在处理 CMakeLists.txt 时找到这些模块，你需要通过 SET 指令，将自己的 cmake 模块路径设置一下。 比如： SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) 这时候你就可以通过 INCLUDE 指令来调用自己的模块了。 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 分别用来重新定义最终结果的存放目录，前面我们已经提到了这两个变量。 PROJECT_NAME 返回通过 PROJECT 指令定义的项目名称。 4. cmake 调用环境变量的方式 使用$ENV{NAME} 指令就可以调用系统的环境变量了。 设置环境变量的方式是： SET(ENV{变量名} 值) CMAKE_INCLUDE_CURRENT_DIR 自动添加 CMAKE_CURRENT_BINARY_DIR 和 CMAKE_CURRENT_SOURCE_DIR 到当前处理的 CMakeLists.txt。相当于在每个 CMakeLists.txt 加入： INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR}) CMAKE_INCLUDE_DIRECTORIES_PROJECT_BEFORE 将工程提供的头文件目录始终置于系统头文件目录的前面，当你定义的头文件确实跟系统发生冲突时可以提供一些帮助。 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH 我们在上一节已经提及。 5. 系统信息 CMAKE_MAJOR_VERSION，CMAKE 主版本号，比如 2.4.6 中的 2 CMAKE_MINOR_VERSION，CMAKE 次版本号，比如 2.4.6 中的 4 CMAKE_PATCH_VERSION，CMAKE 补丁等级，比如 2.4.6 中的 6 CMAKE_SYSTEM，系统名称，比如 Linux-2.6.22 CMAKE_SYSTEM_NAME，不包含版本的系统名，比如 Linux CMAKE_SYSTEM_VERSION，系统版本，比如 2.6.22 CMAKE_SYSTEM_PROCESSOR，处理器名称，比如 i686 UNIX，在所有的类 UNIX 平台为 TRUE，包括 OS X 和 cygwin WIN32，在所有的 win32 平台为 TRUE，包括 cygwin 6. 主要的开关选项 MAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS，用来控制 IF ELSE语句的书写方式，在下一节语法部分会讲到。 BUILD_SHARED_LIBS 这个开关用来控制默认的库编译方式，如果不进行设置，使用 ADD_LIBRARY 并没有指定库类型的情况下，默认编译生成的库都是静态库。 CMAKE_C_FLAGS 设置C编译选项，也可以通过指令ADD_DEFINITIONS()添加。 CMAKE_CXX_FLAGS 设置C++编译选项，也可以通过指令ADD_DEFINITIONS()添加。 7.小结 本章介绍了一些较常用的 cmake 变量，这些变量仅仅是所有 cmake 变量的很少一部分。目前 cmake 的英文文档也是比较缺乏的，如果需要了解更多的 cmake 变量，更好的方式是阅读一些成功项目的 cmake 工程文件，比如 KDE4 的代码。 八、cmkae 常用指令 前面我们讲到了 cmake 常用的变量，相信“cmake 即编程”的感觉会越来越明显。无论如何，我们仍然可以看到 cmake 比 autotools 要简单很多。接下来我们就要集中的看一看 cmake 所提供的常用指令。在前面的章节我们已经讨论了很多指令的用法，如 PROJECT，ADD_EXECUTABLE，INSTALL，ADD_SUBDIRECTORY，SUBDIRS，INCLUDE_DIRECTORIES，LINK_DIRECTORIES，TARGET_LINK_LIBRARIES，SET等。 1. 基本指令 ADD_DEFINITIONS 向C，C++编译器添加-D定义，比如： ADD_DEFINITIONS(-DENABLE_DEBUG -DABC)，参数之间用空格分割。 如果你的代码中定义了#ifdef ENABLE_DEBUG #endif，这个代码块就会生效。 如果要添加其他的编译器开关，可以通过 CMAKE_C_FLAGS 变量和 CMAKE_CXX_FLAGS 变量设置。 ADD_DEPENDENCIES 定义 target 依赖的其他 target，确保在编译本 target 之前，其他的 target 已经被构建。 ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...) ADD_EXECUTABLE、ADD_LIBRARY、ADD_SUBDIRECTORY 前面已经介绍过了，这里不再罗唆。 ADD_TEST 与 ENABLE_TESTING 指令 ENABLE_TESTING 指令用来控制 Makefile 是否构建 test 目标，涉及工程所有目录。语法很简单，没有任何参数，ENABLE_TESTING()，一般情况这个指令放在工程的主CMakeLists.txt 中。 ADD_TEST 指令的语法是： ADD_TEST(testname Exename arg1 arg2 ...) testname 是自定义的 test 名称，Exename 可以是构建的目标文件也可以是外部脚本等等。后面连接传递给可执行文件的参数。如果没有在同一个 CMakeLists.txt 中打开ENABLE_TESTING()指令，任何 ADD_TEST 都是无效的。 比如我们前面的 Helloworld 例子，可以在工程主 CMakeLists.txt 中添加 ADD_TEST(mytest ${PROJECT_BINARY_DIR}/bin/main) ENABLE_TESTING() 生成 Makefil e后，就可以运行 make test 来执行测试了。 AUX_SOURCE_DIRECTORY 基本语法是： AUX_SOURCE_DIRECTORY(dir VARIABLE) 作用是发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表。因为目前 cmake 还不能自动发现新添加的源文件。 比如： AUX_SOURCE_DIRECTORY(. SRC_LIST) ADD_EXECUTABLE(main ${SRC_LIST}) 你也可以通过后面提到的 FOREACH 指令来处理这个 LIST。 CMAKE_MINIMUM_REQUIRED 其语法为 CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR]) 比如 CMAKE_MINIMUM_REQUIRED(VERSION 2.5 FATAL_ERROR) 如果 cmake 版本小与 2.5，则出现严重错误，整个过程中止。 EXEC_PROGRAM 在 CMakeLists.txt 处理过程中执行命令，并不会在生成的 Makefile 中执行。具体语法为: EXEC_PROGRAM(Executable [directory in which to run] [ARGS ] [OUTPUT_VARIABLE ] [RETURN_VALUE ]) 用于在指定的目录运行某个程序，通过 ARGS 添加参数。如果要获取输出和返回值，可通过 OUTPUT_VARIABLE 和 RETURN_VALUE 分别定义两个变量。 这个指令可以帮助你在 CMakeLists.txt 处理过程中支持任何命令，比如根据系统情况去 修改代码文件等等。 举个简单的例子，我们要在 src 目录执行 ls 命令，并把结果和返回值存下来。 可以直接在 src/CMakeLists.txt 中添加： EXEC_PROGRAM(ls ARGS \"*.c\" OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE) IF(not LS_RVALUE) MESSAGE(STATUS \"ls result: \" ${LS_OUTPUT}) ENDIF(not LS_RVALUE) 在cmake 生成 Makefile 的过程中，就会执行 `ls`` 命令，如果返回0，则说明成功执行，那么就输出ls *.c的结果。关于IF语句，后面的控制指令会提到。 FILE 指令 文件操作指令，基本语法为： FILE(WRITE filename \"message to write\"... ) FILE(APPEND filename \"message to write\"... ) FILE(READ filename variable) FILE(GLOB variable [RELATIVE path] [globbing expressions]...) FILE(GLOB_RECURSE variable [RELATIVE path] [globbing expressions]...) FILE(REMOVE [directory]...) FILE(REMOVE_RECURSE [directory]...) FILE(MAKE_DIRECTORY [directory]...) FILE(RELATIVE_PATH variable directory file) FILE(TO_CMAKE_PATH path result) FILE(TO_NATIVE_PATH path result) 这里的语法都比较简单，不在展开介绍了。 INCLUDE 指令，用来载入 CMakeLists.txt 文件，也用于载入预定义的 cmake 模块 INCLUDE(file1 [OPTIONAL]) INCLUDE(module [OPTIONAL]) OPTIONAL 参数的作用是文件不存在也不会产生错误。 你可以指定载入一个文件，如果定义的是一个模块，那么将在 CMAKE_MODULE_PATH 中搜 索这个模块并入。 载入的内容将在处理到 INCLUDE 语句是直接执行。 2. INSTALL 指令 INSTALL 系列指令已经在前面的章节有非常详细的说明，这里不在赘述，可参考前面的安装部分。 3. FIND指令 FIND_ 系列指令主要包含一下指令： FIND_FILE( name1 path1 path2 ...) VAR 变量代表找到的文件全路径，包含文件名 FIND_LIBRARY( name1 path1 path2 ...) VAR 变量表示找到的库全路径，包含库文件名 FIND_PATH( name1 path1 path2 ...) VAR 变量代表包含这个文件的路径。 FIND_PROGRAM( name1 path1 path2 ...) VAR 变量代表包含这个程序的全路径。 FIND_PACKAGE( [major.minor] [QUIET] [NO_MODULE] [[REQUIRED|COMPONENTS] [componets...]]) 用来调用预定义在 CMAKE_MODULE_PATH 下的 Find.cmake 模块，你也可以自己 定义Find模块，通过SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录 中供工程使用。我们在后面的章节会详细介绍FIND_PACKAGE 的使用方法和 Find 模块的编写。 FIND_LIBRARY 示例： FIND_LIBRARY(libX X11 /usr/lib) IF(NOT libX) MESSAGE(FATAL_ERROR “libX not found”) ENDIF(NOT libX) 4. 控制指令 IF指令 基本语法为： IF(expression) # THEN section. COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ELSE(expression) # ELSE section. COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDIF(expression) 另外一个指令是 ELSEIF，总体把握一个原则，凡是出现 IF 的地方一定要有对应的 ENDIF。出现 ELSEIF 的地方，ENDIF 是可选的。 表达式的使用方法如下： IF(var)，如果变量不是：空，0，N, NO, OFF, FALSE, NOTFOUND 或_NOTFOUND 时，表达式为真。 IF(NOT var )，与上述条件相反。 IF(var1 AND var2)，当两个变量都为真是为真。 IF(var1 OR var2)，当两个变量其中一个为真时为真。 IF(COMMAND cmd)，当给定的 cmd 确实是命令并可以调用时为真。 IF(EXISTS dir)或者IF(EXISTS file)，当目录名或者文件名存在时为真。 IF(file1 IS_NEWER_THAN file2)，当 file1 比 file2 新，或者 file1/file2 其 中有一个不存在时为真，文件名请使用完整路径。 IF(IS_DIRECTORY dirname)，当 dirname 是目录时，为真。 IF(variable MATCHES regex) IF(string MATCHES regex) 当给定的变量或者字符串能够匹配正则表达式 regex 时为真。比如： IF(\"hello\" MATCHES \"ell\") MESSAGE(\"true\") ENDIF(\"hello\" MATCHES \"ell\") # 数字比较表达式 IF(variable LESS number) IF(string LESS number) IF(variable GREATER number) IF(string GREATER number) IF(variable EQUAL number) IF(string EQUAL number) # 按照字母序的排列进行比较 IF(variable STRLESS string) IF(string STRLESS string) IF(variable STRGREATER string) IF(string STRGREATER string) IF(variable STREQUAL string) IF(string STREQUAL string) IF(DEFINED variable)，如果变量被定义，为真。 一个小例子，用来判断平台差异： IF(WIN32) MESSAGE(STATUS “This is windows.”) # 做一些 Windows 相关的操作 ELSE(WIN32) MESSAGE(STATUS “This is not windows”) # 做一些非 Windows 相关的操作 ENDIF(WIN32) 上述代码用来控制在不同的平台进行不同的控制，但是，阅读起来却并不是那么舒服，ELSE(WIN32)之类的语句很容易引起歧义。 这就用到了我们在“常用变量”一节提到的 CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS 开关。 可以SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON) 这时候就可以写成： IF(WIN32) ELSE() ENDIF() 如果配合 ELSEIF 使用，可能的写法是这样： IF(WIN32) #do something related to WIN32 ELSEIF(UNIX) #do something related to UNIX ELSEIF(APPLE) #do something related to APPLE ENDIF(WIN32) WHILE WHILE 指令的语法是： WHILE(condition) COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDWHILE(condition) 其真假判断条件可以参考 IF 指令。 FOREACH FOREACH 指令的使用方法有三种形式： 列表 FOREACH(loop_var arg1 arg2 ...) COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDFOREACH(loop_var) 像我们前面使用的 AUX_SOURCE_DIRECTORY 的例子 AUX_SOURCE_DIRECTORY(. SRC_LIST) FOREACH(F ${SRC_LIST}) MESSAGE(${F}) ENDFOREACH(F) 范围 FOREACH(loop_var RANGE total) ENDFOREACH(loop_var) 从 0 到 total 以 1 为步进。 举例如下： FOREACH(VAR RANGE 10) MESSAGE(${VAR}) ENDFOREACH(VAR) 得到的结果是： 0 1 2 3 4 5 6 7 8 9 10 范围和步进 FOREACH(loop_var RANGE start stop [step]) ENDFOREACH(loop_var) 从 start 开始到 stop 结束，以 step 为步进， 举例如下： FOREACH(A RANGE 5 15 3) MESSAGE(${A}) ENDFOREACH(A) 最终得到的结果是: 5 8 11 14 这个指令需要注意的是，直到遇到 ENDFOREACH 指令，整个语句块才会得到真正的执行。 5.小结 本小节基本涵盖了常用的 cmake 指令，包括基本指令、查找指令、安装指令以及控制语句等。特别需要注意的是，在控制语句条件中使用变量，不能用${}引用，而是直接应用变量名。 掌握了以上的各种控制指令，你应该完全可以通过 cmake 管理复杂的程序了。下一节，我们将介绍一个比较复杂的例子，通过他来演示本章的一些指令，并介绍模块的概念。 九、复杂的例子：模块的使用和自定义 你现在还会觉得 cmake 简单吗？ 本章我们将着重介绍系统预定义的 Find 模块的使用以及自己编写 Find 模块。系统中提供了其他各种模块，一般情况需要使用 INCLUDE 指令显式的调用，FIND_PACKAGE 指令是一个特例，可以直接调用预定义的模块。 其实使用纯粹依靠 cmake 本身提供的基本指令来管理工程是一件非常复杂的事情。所以，cmake 设计成了可扩展的架构，可以通过编写一些通用的模块来扩展 cmake。 在本章，我们准备首先介绍一下 cmake 提供的 FindCURL 模块的使用。然后，基于我们前面的 libhello 共享库，编写一个 FindHello.cmake 模块。 1. 使用 FindCURL 模块 在 /backup/cmake 目录建立 t5 目录，用于存放我们的 CURL 的例子。 建立 src 目录，并建立 src/main.c，内容如下： #include #include #include #include FILE *fp; int write_data(void *ptr, size_t size, size_t nmemb, void *stream) { int written = fwrite(ptr, size, nmemb, (FILE *)fp); return written; } int main() { const char * path = \"/tmp/curl-test\"; const char * mode = \"w\"; fp = fopen(path, mode); curl_global_init(CURL_GLOBAL_ALL); CURLcode res; CURL *curl = curl_easy_init(); curl_easy_setopt(curl, CURLOPT_URL, \"https://www.baidu.com\"); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data); curl_easy_setopt(curl, CURLOPT_VERBOSE, 1); res = curl_easy_perform(curl); curl_easy_cleanup(curl); } 这段代码的作用是通过 curl 取回 www.linux-ren.org 的首页并写入 /tmp/curl-test 文件中。 @Gavin注：原书中的 www.linux-ren.org 会产生301重定向，建议换成其他，比如：https://www.baidu.com 建立 t5 主工程文件 CMakeLists.txt： PROJECT(CURLTEST) ADD_SUBDIRECTORY(src) 建立 src/CMakeLists.txt： ADD_EXECUTABLE(curltest main.c) 现在自然是没办法编译的，我们需要添加 curl 的头文件路径和库文件。 方法 1： 直接通过 INCLUDE_DIRECTORIES 和 TARGET_LINK_LIBRARIES 指令添加 我们可以直接在 src/CMakeLists.txt 中添加： INCLUDE_DIRECTORIES(/usr/include) TARGET_LINK_LIBRARIES(curltest curl) 方法2： 我们要探讨的是使用 cmake 提供的 FindCURL 模块。 向 src/CMakeLists.txt 中添加： FIND_PACKAGE(CURL) IF(CURL_FOUND) INCLUDE_DIRECTORIES(${CURL_INCLUDE_DIR}) TARGET_LINK_LIBRARIES(curltest ${CURL_LIBRARY}) ELSE(CURL_FOUND) MESSAGE(FATAL_ERROR ”CURL library not found”) ENDIF(CURL_FOUND) 对于系统预定义的 Find.cmake 模块，使用方法一般如上例所示： 每一个模块都会定义以下几个变量： _FOUND _INCLUDE_DIR or _INCLUDES _LIBRARY or _LIBRARIES 你可以通过_FOUND来判断模块是否被找到，如果没有找到，按照工程的需要关闭某些特性、给出提醒或者中止编译，上面的例子就是报出致命错误并终止构建。 如果 _FOUND 为真，则将 _INCLUDE_DIR 加入 INCLUDE_DIRECTORIES， 将 _LIBRARY 加入 TARGET_LINK_LIBRARIES 中。 方法1或者方法2操作完成后，建立 build目录，进行外部构建，在终端中输入： cmake .. make 即可在 /build/src 目录下得到可执行文件 curltest 我们再来看一个复杂的例子，通过 _FOUND 来控制工程特性： SET(mySources viewer.c) SET(optionalSources) SET(optionalLibs) FIND_PACKAGE(JPEG) IF(JPEG_FOUND) SET(optionalSources ${optionalSources} jpegview.c) INCLUDE_DIRECTORIES( ${JPEG_INCLUDE_DIR} ) SET(optionalLibs ${optionalLibs} ${JPEG_LIBRARIES} ) ADD_DEFINITIONS(-DENABLE_JPEG_SUPPORT) ENDIF(JPEG_FOUND) IF(PNG_FOUND) SET(optionalSources ${optionalSources} pngview.c) INCLUDE_DIRECTORIES( ${PNG_INCLUDE_DIR} ) SET(optionalLibs ${optionalLibs} ${PNG_LIBRARIES} ) ADD_DEFINITIONS(-DENABLE_PNG_SUPPORT) ENDIF(PNG_FOUND) ADD_EXECUTABLE(viewer ${mySources} ${optionalSources} ) TARGET_LINK_LIBRARIES(viewer ${optionalLibs} 通过判断系统是否提供了 JPEG 库来决定程序是否支持 JPEG 功能。 2. 编写属于自己的 FindHello 模块 @ROSIT注: 代码未测试成功 我们在此前的 t3 实例中，演示了构建动态库、静态库的过程并进行了安装。 接下来，我们在 t6 示例中演示如何自定义 FindHELLO 模块并使用这个模块构建工程： 在 /backup/cmake/ 中建立 t6 目录，并在其中建立 cmake目录用于存放我们自己定义的 FindHELLO.cmake 模块。同时建立 src 目录，用于存放我们的源文件。 进入到 t6/cmake目录，新建 FindHELLO.cmake 文件，并填写如下内容： FIND_PATH(HELLO_INCLUDE_DIR hello.h /usr/include/hello /usr/local/include/hello) FIND_LIBRARY(HELLO_LIBRARY NAMES hello PATH /usr/lib /usr/local/lib) IF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY) SET(HELLO_FOUND TRUE) ENDIF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY) IF(HELLO_FOUND) IF(NOT HELLO_FIND_QUIETLY) MESSAGE(STATUS \"Found Hello: ${HELLO_LIBRARY}\") ENDIF(NOT HELLO_FIND_QUIETLY) ELSE(HELLO_FOUND) IF(HELLO_FIND_REQUIRED) MESSAGE(FATAL_ERROR \"Could not find hello library\") ENDIF(HELLO_FIND_REQUIRED) ENDIF(HELLO_FOUND) 针对上面的模块让我们再来回顾一下 FIND_PACKAGE 指令： FIND_PACKAGE( [major.minor] [QUIET] [NO_MODULE] [[REQUIRED|COMPONENTS] [componets...]]) 前面的 CURL 例子中我们使用了最简单的 FIND_PACKAGE 指令。其实他可以使用多种参数：QUIET参数，对应与我们编写的 FindHELLO 中的 HELLO_FIND_QUIETLY，如果不指定这个参数，就会执行： MESSAGE(STATUS \"Found Hello: ${HELLO_LIBRARY}\") REQUIRED 参数，其含义是指这个共享库是否是工程必须的。如果使用了这个参数，说明这个链接库是必备库，如果找不到这个链接库，则工程不能编译。对应于FindHELLO.cmake模块中的 HELLO_FIND_REQUIRED 变量。 同样，我们在上面的模块中定义了 HELLO_FOUND, HELLO_INCLUDE_DIR, HELLO_LIBRARY 变量供开发者在FIND_PACKAGE 指令中使用。 OK，下面建立 src/main.c，内容为： #include int main() { HelloFunc(); return 0; } 建立 src/CMakeLists.txt 文件，内容如下： FIND_PACKAGE(HELLO) IF(HELLO_FOUND) ADD_EXECUTABLE(hello main.c) INCLUDE_DIRECTORIES(${HELLO_INCLUDE_DIR}) TARGET_LINK_LIBRARIES(hello ${HELLO_LIBRARY}) ENDIF(HELLO_FOUND) 为了能够让工程找到 FindHELLO.cmake 模块(存放在工程中的 cmake 目录)，我们在 t6 主工程文件 CMakeLists.txt 中加入： SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) 3. 使用自定义的 FindHELLO 模块构建工程 仍然采用外部编译的方式，建立 build 目录，进入目录运行： cmake .. 我们可以从输出中看到： Found Hello: /usr/lib/libhello.so 如果我们把上面的FIND_PACKAGE(HELLO)修改为FIND_PACKAGE(HELLO QUIET)，则不会看到上面的输出。 接下来就可以使用 make 命令构建工程，运行：./src/hello 可以得到输出： Hello World。 说明工程成功构建。 4. 如果没有找到 hello library 呢? 我们可以尝试将 /usr/lib/libhello.x 移动到 /tmp 目录，这样，按照 FindHELLO 模块的定义，就找不到 hello library 了，我们再来看一下构建结果： cmake .. 仍然可以成功进行构建，但是这时候是没有办法编译的。 修改FIND_PACKAGE(HELLO)为FIND_PACKAGE(HELLO REQUIRED)，将 hello library 定义为工程必须的共享库。 这时候再次运行cmake .. 我们得到如下输出： CMake Error: Could not find hello library 因为找不到 libhello.x，所以，整个 Makefile 生成过程被出错中止。 5.小结 在本节中，我们学习了如何使用系统提供的 Find 模块并学习了自己编写 Find 模块以及如何在工程中使用这些模块。 后面的章节，我们会逐渐学习更多的 cmake 模块使用方法以及用 cmake 来管理 GTK 和 QT4 工程。 练习参考代码：链接：https://pan.baidu.com/s/14tSQq5ggZ4e1xCrCl_BUSw 提取码：6666 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/resource.html":{"url":"Markdown/Resource/resource.html","title":"A 常用资源","keywords":"","body":"常用资源 1 Gitbook 江明博客，网址： https://jiangming_gitee.gitee.io/gitbook/ ghostwritten的CSDN，CSDN网址 valine评论插件，网址：https://console.leancloud.cn/apps new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "}}