{"./":{"url":"./","title":"简介","keywords":"","body":"关于本站 ROSit 2023/9/5 1 介绍 欢迎来到 🎉 ROSit™ 🎉，这是一个致力于\"赛教融合、以赛促教\"的资源展示与分享的平台！ 😄 我是机电工程学院的一位教师，专注于ROS机器人智能控制领域的研究与教学，讲授《机器人操作系统》和《机器人竞赛实用技术》两门课程！ 💪 网站名ROSit灵感来自ROS中的Moveit模块，旨在传达受ROS驱动的机器人的涵义~ 2 探究 👉 本站致力于整合机器人教学、竞赛所需的关键知识、必备资源工具，同时精选优秀案例，提供一站式的学习和参赛支持~~ ⌛️ 平台目前规划了3个教程板块，硬件层、通信层和决策层，分别对应机器人底层控制、中间层信息交互与上层自主决策的核心内容，每个板块包含基础入门和实践探索2部分。同时规划了3个竞赛板块，包括竞赛追踪、资源工具和优秀案例。这一板块提供竞赛所需的常用资源和工具，分享优秀经验和案例，提升竞赛效能~ ⭐ 硬件层：Arduino、STM32； 通信层：Ubuntu、ROS； 决策层：LLM & ML & RL、Opencv等 🌈 竞赛追踪：中国机器人及人工智能大赛、中国高校智能机器人创意大赛 🔥 资源工具：Ubuntu、ROS、Python、C++、Git、MarkDown、Cmake等 3 期待 ✉️ 欢迎同学们分享优质资源，方便大家的交流和学习。如需投稿，请将文章以及相关附件发送到下面的联系邮箱~ 👌有需要提出建议或者意见反馈，也请发送邮件至联系邮箱，或者到留言板进行留言，并留下您的联系方式，我将会逐一反馈您的问题和建议！ 4 联系 📧 163 邮箱：qie73@166.com 📧 QQ 邮箱：348887362@qq.com 5 提示 😉目前平台还在持续的维护和完善中，相关的材料也在逐步的整理和优化中，若发现错误或网盘链接失效，请帮忙反馈哦🚀🚀🚀~~~new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"CATALOGUE.html":{"url":"CATALOGUE.html","title":"目录","keywords":"","body":"目录 1 硬件层 1 STM32 1 基础入门 内容 进度 1.1 STM32简介及工程架构 完结 1.2 STM32外设-GPIO 完结 2 Arduino 内容 进度 Arduino 待开始 2 通信层 1 Ubuntu 1 基础入门 内容 进度 1.1 VirtualBox 和 Ubuntu安装 完结 1.2 Ubuntu安装之后需要做的事 完结 1.3 Ubuntu基础知识 完结 2 常用命令 内容 进度 2.1 文件目录操作命令 完结 2.2 文件查找命令 完结 1.3 其他常用命令 完结 2 ROS 1 基础入门 内容 进度 1.1 ROS基础知识 进行中 2 实践探索 内容 进度 2.1 ROS_OpenCV 待开始 3 决策层 1 OpenCV 1 基础入门 内容 进度 1.1 OpenCV入门 完结 1.2 OpenCV基础 完结 A 竞赛追踪 1 中国机器人及人工智能大赛 内容 进度 1.1 竞赛分析 待开始 2 中国高校智能机器人创意大赛 内容 进度 1.1 竞赛分析 待开始 B 资源工具 1 学习资源 内容 进度 1 Ubuntu 不断补充中 2 ROS1 不断补充中 3 C++ 不断补充中 4 Python 不断补充中 5 Vim 不断补充中 6 Docker 不断补充中 2 常用工具 内容 进度 1.1 廖雪峰Git教程 完结 1.2 Git常用指令 完结 1.3 Git疑难解答 完结 2.1 Markdown基本语法 完结 2.2 Markdown数学公式 完结 3 Cmake 完结 C 优秀案例 21级 内容 进度 1 李霁桐-机工2102 完结 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/STM32/chapter1.html":{"url":"Markdown/STM32/chapter1.html","title":"1 基础入门","keywords":"","body":"1 基础入门 本教程为B站江协科技《STM32入门教程-2023版 细致讲解 中文字幕》文本精摘，可配合江协科技的视频教程一起学习，教程地址：点击传送 STM32学习资料：https://pan.baidu.com/s/18fhRyC879TZuWnGuqG618g?pwd=1234 提取码：1234 解压密码：32 教程相关问题及解答：https://jiangxiekeji.com/problem.html new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/STM32/chapter1-1.html":{"url":"Markdown/STM32/chapter1-1.html","title":"1.1 STM32简介及工程架构","keywords":"","body":"1.1 STM32简介及工程架构 1-1 课程简介 1 课程概述 程序纯手打，手把手教学。在本套视频中除了一些比较固定的代码，比如延时函数、显示屏函数等，我会直接提供给大家，其他的关键部分代码我都会亲自给大家敲出来，一步步的演示工程是如何建立的，程序是如何调试的 STM32最小系统版和面包版的硬件平台。在本套视频中，使用的硬件平台如下图所示 将STM32最小系统板插在面包板上，作为基本的硬件单元。下面插上一块0.96寸的OLED作为调试和显示的屏幕。在调试程序时，我们可以把程序中的变量显示在这个屏幕上，这样调试起来就会比较方便 STLINK是插在电脑上用于下载程序和供电的。 LED按键插在最小系统板的两侧，其他的一些模块，比如这个是蜂鸣器模块，则是用杜邦线来连接的，带插针的模块则会跨接在面包板的中间，然后再进行连线 使用面包板能够完成任意电路的连接，连线和修改都是非常方便的，相比较成品的开发板方式，使用面包板更有利于我们对硬件电路的学习，而且也可以避免开发板的一些问题。比如引脚冲突，引脚无法更改等。当然使用面包板也会带来一些问题，比如你程序现象不出来，不仅可能是你程序的问题，也有可能是接线的问题。这就需要我们在连线的时候要更加细心一些，关注软件程序的同时也需要关注一下硬件电路 2 硬件设备 2.1 STM32入门套件 本套课程所使用的入门套件见下图 1为面包板，其他的模块和导线都是插在面包板上完成连接的 2是面包板专用的跳线，这种跳线比较短，可以贴在面包板上插线，比较适合长时间插线的情况 3是面包板的飞线，这种线比较长，也方便挪动，比较适合经常挪动的接线情况 4是杜邦线，分别是公对母和母对母的，可以用于插接一些电路模块 5是STM32最小系统板，上面黑色的小芯片就是STM32，我们主要就是学习这个芯片 6是0.96寸的OLED显示屏模块，用于显示参数和变量。这个显示屏是一个4引脚版本的，现在网上卖的有4引脚和7引脚的，注意不要弄错了 7是电位器，主要用来进行AD转换实验的 8是按键，我选的按键是这种两引脚的小按键，它可以正好跨接在面包板的引脚插孔和电源插孔之间，连接非常方便简洁 9是LED灯，用来做点灯实验的，我争取让大家都成为点灯大师 10是STLINK，用来下载程序和供电的 11是USB转串口模块，使用这个模块就可以使STM32和电脑进行串口通信了 12是有源蜂鸣器模块，它是内置震荡源的，接上电就可以响。相比较无源蜂鸣器模块需要不断翻转IO口的操作方式，这个就方便多了，基本和点灯一样简单 13是光敏电阻模块，下面的4个引脚有2个是用来供电的，还有2个是光敏电阻信号的模拟输出和数字输出，这个可以用来进行IO口读取实验或者AD实验 14是热敏电阻模块，也是有模拟输出和数字输出的 15是对射式红外模块，这个模块配合遮光片可以用来计次或者配合编码盘用来测速 16是反射式红外模块，这个做过循迹车的应该清楚，它可以向地面发射红外光，然后再用红外接收管接收地面反射的红外光，通过判断接收光的强度，就可以大致的识别出地面的颜色变化了 17是W25Q64 FLASH存储模块，它可以存储数据，并且它是用SPI总线进行通信的，我们主要用它来学习SPI通信 18是MPU6050陀螺仪和加速度计，它可以测量芯片自身的姿态，像四轴飞行器上一般都会配有陀螺仪和加速的计，这个模块是IIC总线通信的，我们主要用它来学习IIC通信 19是旋转编码器，它可以输出两路正交的方波信号，用于指示旋转的方向和速度。STM32里面有专门的编码器电路，可以很方便地识别这种信号，这个模块可以当做一个快速的按键来使用。当然我的主要意图还是用它来模拟编码器的测速。现在的编码电机一般都会配备霍尔传感器或者光电传感器，这些传感器的输出和这种旋转编码器是一样的，所以学习一下旋转编码器就可以了，而且这种旋转编码器还比较方便的插在面包板上 20和21是直流电机和TB6612电机驱动模块，可以用来进行直流电机的PWM调速实验 22是SG90舵机，它也是用PWM进行控制的。它的输出端可以像船舵一样，根据我们给定的PWM信号的占空比固定在某个角度上，这个可以用来做一些机器人或者机械臂的关节 2.2 Windows电脑 电脑尽量选择windows系统的，因为我们的编程软件还有一些小工具都是在windows平台的，选择windows的电脑会方便一些 2.3 工具 准备一些工具，比如万用表、示波器、镊子、剪刀等 万用表可以很方便的检查电路的连接情况，因为我们使用的是面包板搭接的电路，可能会存在接错线或者接触不良的情况，如果有个万用表就可以很方便的测试电路的连接情况 示波器可以测出引脚的电压波形变化，在PWM实验或者通讯协议的实验能看到波形，那对我们的调试程序将会有很大的帮助 3 软件设备 本套教程学习STM32使用的是Keil5 MDK这个软件，Keil5 MDK是用来给ARM系列的单片机编程的软件。Keil5 MDK的安装软件和注册工具见网盘链接，安装方法见《2-1 软件安装》 1-2 STM32简介 1 STM32 MCUs 1.1 STM32 ST是指ST公司，M是Microcontroller的首字母。微控制器就是MCU，就是我们常说的单片机，所以STM32也是一款单片机 32是指该处理器是32位，即32-bits。相比较8位的51单片机，STM32的性能还是非常强的 ARM Cortex-M内核是STM32内部的核心部分。这个内核是ARM公司设计的，我们程序指令的执行、加减乘除的运算都是在内核里完成的，它相当于整个芯片的CPU。就像我们现在的电脑厂商一样，可以拿着英特尔或者AMD的CPU，然后自己完善外围电路，就可以推出自己品牌的电脑。STM32也是一样，ST公司拿着ARM公司设计的内核，再完善外围电路，整个封装起来就做成了STM32。当然也可以有其他的厂商拿着ARM的内核，来做自己的芯片，那这些芯片都叫做基于ARM内核的芯片 STM32常应用在嵌入式领域，如智能车、无人机、机器人、无线通信、物联网、工业控制、娱乐电子产品等 1.2 STM32系列 STM32分4个系列，分别是High Performance（高性能系列）、Mainstream（主流系列）、Ultra-low-power（超低功耗系列）、Wireless（无线系列），见下图 High Performance：STM32F2、STM32F4、STM32F7、STM32H7 上图中下面是芯片的性能介绍，比如STM32F2系列就是398的CoreMark和120MHz主频的Cortex-M3内核。这个CoreMark就是一个内核跑分，跑分越高性能越好。Cortex-M3内核就是ARM的其中一个内核芯片 单片机的主频（也称为时钟频率或振荡频率）是指单片机的内部时钟频率，通常以赫兹（Hz）为单位表示。主频对单片机的性能和功能具有重要影响，具体用途包括： ​ 1. 控制执行速度：主频决定了单片机执行指令的速度。较高的主频可以使单片机更快地执行指令，适用于需要高性能的应用，例如图形处理、音频处理或高速通信 ​ 2. 定时和延时：主频用于计算定时器和延时器的周期，从而实现精确的时间控制。这在许多应用中非常重要，如实时控制系统、定时器中断等 ​ 3. 节能和电源管理：通过降低主频，可以减少单片机的功耗，延长电池寿命，适用于侧重低功耗的应用，如便携设备和传感器节点 ​ 4. 通信速度：主频也可以影响串行通信的速度，例如UART（通用异步收发传输）通信或SPI（串行外设接口）通信速率。更高的主频可以支持更高的通信速度 ​ 5. 复杂性和功能：高主频的单片机通常具有更多的处理能力，可以执行更复杂的任务和算法。这对于需要处理大数据量或进行复杂计算的应用非常重要 ​ 6. 精确性和稳定性：主频的稳定性和精确性对某些应用非常重要，例如时钟同步、数据采集和传感器读数。单片机主频的稳定性可以影响系统性能 高性能系列中，STM32H7的芯片就是目前最强的STM32芯片。拥有3224的内核跑分，550MHz的Cortex-M7和240MHz的 Cortex-M4的内核，是一个双核微控制机 Mainstream：STM32G0、STM32G4、STM32F0、STM32F1、STM32F3 本次教程我们使用的是STM32F1这个系列，它有177的内核跑分和72MHz的Cortex-M3内核 Ultra-low-power：STM32L4+、STM32U5、STM32L0、STM32L1、STM32L4、STM32L5 Wireless：STM32WL、STM32WB 2 ARM处理器系列 这里的ARM既指ARM公司，也指ARM处理器内核。ARM公司是全球领先的半导体知识产权提供商，知识产权提供商的意思就是这个ARM公司是只设计ARM内核而不生产实物。实际的内核是各大半导体厂商连同芯片一起制作出来的。ARM可以授权给各大厂商它的设计，然后再收取授权费作为盈利方式。这实际是一种开放、合作、利益共享、风险共担的商业模式，现在全球超过95%的智能手机和平板电脑都采用了ARM的架构 STM32是ST公司基于ARM内核，设计自己的存储器以及外设等组件，构成STM芯片，见下图 蓝色部分是整个的STM32芯片，内部处于CPU地位的就是ARM公司设计的内核。右边这些橙色的部分就是ST公司设计的外围电路，比如存储器还有一些片上的外设资源等。如果ST公司觉得资源不够多，还可以继续增加外围电路 ARM公司的内核分为Classic、Embedded和Application，见下图 Classic 经典ARM处理器，ARM老版本，现在用的比较少了 主流型号：ARM7、ARM9、ARM11 Application 在ARM11之后，为了迎合时代的发展和市场的变化，ARM更改了命名方式，推出了Cortex系列的内核，并且一下推出了三款子型号用于适用不同的场景。它们分别是Cortex-A系列、Cortex-R系列和Cortex-M系列，这三个系列加起正好构成的ARM三个字母。A系列适用于高端应用型的领域，R系列和M系列适用于嵌入式领域 A系列就是Application的意思，现在的苹果、高通、联发科的手机芯片基本上都是采用ARM内核架构。A系列也是ARM内核中性能最高、发展最快的系列。最近苹果推出了基于ARM架构的M1芯片，将ARM架构推进到了电脑领域，所以ARM的发展趋势还是非常好的 主流型号：Cortex-A5、Cortex-A7、Cortex-A8、Cortex-A9、Cortex-A15等 Embedded 与A系列对比下来，R系列和M系列的型号发展就比较慢。R系列就是RealTime的意思，主要面向实时性很高的场景，比如硬盘控制器等。R系列的应用场景比较小，R系列的内核型号也不是很多 M系列就是MicroController的意思，主要应用在单片机领域。STM32使用的就是M系列的内核，它的型号有Cortex-M0、Cortex-M1、Cortex-M3、Cortex-M4等。不同型号的内核性能也是不同的，参见上文STM32系列的配图 3 STM32F103C8T6 3.1 芯片参数 系列：主流系列STM32F1 内核：ARM Cortex-M3 主频：72MHz RAM：20K，RAM是运行内存，实际的存储介质是SRAM ROM：64K，ROM是程序存储器，实际的存储介质是Flash闪存 供电：2.0~3.6V(标准3.3V) USB和51单片机，都用的5V电压，不能给STM32供电。如果是5V电压，需要加一个稳压芯片，把电压降到3.3V再给STM32供电 封装：LQFP48，如上图所示，总共有48个引脚，如果自己画PCB板需要了解一下它的封装 3.2 最小系统板 最小系统板硬件信息 ①两个跳线帽用来配置BOOT引脚 ②黑色芯片是STM32F103C8T6 ③是PWR电源指示灯 ④是SWD的调试接口，用来下载程序 ⑤是接在PC13口的测试LED灯 ⑥32.768KHz的RTC晶振 ⑦是8MHz的主时钟晶振 ⑨是USB接口，它可以进行USB通信，也可以为板子供电 上下两排是用于接线的排针 系统板背面见上图，①标记处是3.3V稳压芯片，剩下的是电容、电阻这些零件 3.3 片上资源(外设) 1 外设资源 在STM32微控制器中，外设（Peripheral）是指与主处理器核心（Core）相连的独立功能模块或硬件单元。这些外设模块能够通过特定的接口与主处理器核心进行通信和交互，以扩展微控制器的功能和性能 STM32微控制器内部集成了各种外设，包括但不限于通用输入/输出引脚（GPIO）、定时器（Timer）、串行通信接口（UART、SPI、I2C等）、模数转换器（ADC）、通用定时/计数器（GPT）、以太网控制器、USB控制器、以及其他专用功能模块等。 STM32F103XX系列的外设资源见下图，各个外设的作用见下表 通过使用这些外设，开发人员可以利用STM32微控制器的硬件资源来实现各种功能，例如读取传感器数据、控制外部设备、进行通信和网络连接等 注意，下表是STM32F103XX系列的所有外设，并不是所有型号都拥有全部的外设。比如我们使用的C8T6的芯片就没有DAC、SDIO、FSMC和USB OTG这四个外设。每个芯片具体有哪些外设，每个外设有几个，需要查看该芯片的数据手册 英文缩写 名称 作用 备注 NVIC 嵌套向量中断控制器 内核里面用于管理中断的设备，比如配置中断优先级等 Cortex-M3内核里面的外设 SysTick 系统滴答定时器 内核里面的定时器，用于给操作系统提供定时服务。STM32是可以加入操作系统的，如FreeRTOS、UCOS等。如果用了这些操作系统，就需要SysTik提供定时来进行任务切换的功能 Cortex-M3内核里面的外设 RCC 复位和时钟控制 对系统的时钟进行配置，以及使能各个模块的时钟。在STM32中，其他外设在上电情况下默认是没有时钟的，不给时钟的情况下操作外设是无效的，外设也不会工作。这样的目的是降低功耗，所以在操作外设之前必须先通过RCC来进行时钟使能 GPIO 通用IO口 通用的IO口 AFIO 复用IO口 复用功能端口的重定义，以及中断端口的配置 EXTI 外部中断 外部中断，配置好外部中断后，当引脚有电平变化时，可以触发中断，让CPU处理中断任务 TIM 定时器 TIM是整个STM32最常用、功能最多的外设，TIM分为高级定时器、通用定时器、基本定时器3种类型。其中，高级定时器最为复杂，常用的是通用定时器。TIM定时器不仅可以完成定时中断的任务，还可以完成测频率、生成PWM波形、配置成专用的编码器接口等功能 ADC 模数转换器 STM32内置的12位模数转换器，可以直接读取IO口的模拟电压值，无需外部连接AD芯片 DMA 直接内容访问 可以帮助CPU完成搬运大量数据的繁杂任务 USART 同步/异步串口通讯 平时用的UART是异步串口，这里的USART是既支持异步串口也支持同步串口，实际还是使用异步串口比较多 I2C I2C通信 I2C通信协议，STM32内置了该通信协议的控制器，可以用硬件来输出时序波形，当然也可以用GPIO来模拟时序波形 SPI SPI通信 SPI通信协议，STM32内置了该通信协议的控制器，可以用硬件来输出时序波形，当然也可以用GPIO来模拟时序波形 CAN CAN通信 CAN通信协议 USB USB通信 USB通信协议，利用STM32的USB外设，可以做一个模拟鼠标、模拟U盘等设备 RTC 实时时钟 在STM32内部完成年月日、时分秒的计时功能。而且可以接外部备用电池，即使掉电也能正常运行 CRC CRC校验 数据校验方式，用于判断数据的正确性。有了这个外设的支持进行CRC校验就会更加方便 PWR 电源控制 可以让芯片进入睡眠模式，达到省电的目的 BKP 备份寄存器 这是一段存储器，当系统掉电时，仍可由备用电池保持数据。这个根据需要可以完成一些特殊功能 IWDG 独立看门狗 当单片机因为电磁干扰死机，或程序设计不合理出现死循环时，看门狗可以及时复位芯片，保证系统的稳定 WWDG 窗口看门狗 当单片机因为电磁干扰死机，或程序设计不合理出现死循环时，看门狗可以及时复位芯片，保证系统的稳定 DAC 数模转换器 直接在IO口输出模拟电压，是ADC模数转换的逆过程 SDIO SD卡接口 可以用来读取SD卡 FSMC 可变静态存储控制器 可以用于扩展内存，或者配置成其他总线协议用于某些硬件的操作 USB OTG usb主机接口 使用OTG功能，让STM32作为USB主机去读取其他USB设备 2 STM32时钟 在STM32微控制器中，时钟（Clock）是指用于同步和驱动各个硬件模块和外设的基准信号。时钟信号提供了微控制器内部各个模块之间的时间参考，确保它们按照正确的时序进行操作和通信 STM32微控制器具有多个时钟源和时钟树，用于提供不同频率和精度的时钟信号。主要的时钟源包括晶体振荡器（Crystal Oscillator）、内部高速振荡器（Internal High-Speed Oscillator）、外部时钟源（External Clock Source）等。这些时钟源通过时钟树的配置和分频器的设置，可以生成不同频率的系统时钟和各个外设所需的时钟信号 通过配置和管理时钟，开发人员可以控制外设的操作速度、功耗消耗，以及整个系统的时序和同步性 3.3 芯片命名规则 STM32芯片命名规则，见下图 产品系列：STM32=基于ARM核心的32位微控制器 产品类型：F=通用类型 产品子系列：101-基本型、102=USB基本型、USB2.0全速设备、103=增强型、105或107=互联型 引脚数目：T=36引脚、C=48引脚、R=64引脚、V=100引脚、Z=144引脚（一般来说引脚越多，外设资源就越多） 内存存储器容量：4=16K字节的闪存存储器、6=32K字节的闪存存储器、8=64K字节的闪存存储器、B=128K字节的闪存存储器、C=256K字节的闪存存储器、D=384K字节的闪存存储器、E=512K字节的闪存存储器 封装：H=BGA、T=LQFP、U=VFQFPN、Y=WLCSP64 温度范围：6=工业级温度范围，-40℃-85℃、7=工业级温度范围，-40℃-105℃ 3.4 芯片系统结构 STM32的系统结构，见下图 上图可以分为四个部分： 左上角 ①是Cortex-M3内核，内核引出来了三条总线，分别是ICode的指令总线、DCode数据总线和System系统总线。ICode总线和DCode总线主要是用来②Flash闪存 右上角 Flash里面存储的是我们编写的程序，ICode指令总线就是用来加载程序指令，DCode的数据总线是用来加载数据，比如常量和调试参数等 除了ICode总线和DCode总线，内核还引出了System系统总线。System总线连接到其他的资源上面，比如③SRAM，用于存储程序运行时的变量数据；还有④FSMC，这个本课程的芯片不会用到 右下角 ⑤AHB系统总线就是用于挂载主要的外设。AHB的意思是先进高性能总线，挂载的一般是最基本的或者性能比较高的外设。比如复位和时钟控制这些最基本的电路，还有⑥SDIO也是挂载在AHB总线 AHB总线后面是两个桥接，接到⑦APB1和⑧APB2两个外设总线上。APB的意思是先进外设总线，用于连接一般的外设。因为AHB和APB的总线协议、总线速度、还有数据传送格式的差异，所以中间需要加两个桥接来完成数据的转换和缓存 AHB的整体性能比APB高一些，其中这个⑧APB2的性能又比⑦APB1高一些。⑧APB2一般和AHB同频率，都是72MHz，APB1一般是36MHz。所以APB2连接的是外设中稍微重要的部分，比如GPIO端口、还有一些外设的1号选手等，比如USART1、SPI1、高级定时器TIM1和TIM8，以及ADC、EXTI、AFIO等外设 其他的像这些2、3、4、5号的外设，还有DAC、PWR、BKB等这些次要一点的外设，都会分配到APB1上。当然在使用的时候个人一般感觉不到⑧APB2和⑦APB1的性能差距，只需要知道这个外设是挂到哪个总线上就可以，在进行时钟使能设置的时候需要用到 总结：右下角的这一大部分主要介绍的是外设种类和分布，左下角的部分是DMA 左下角 ⑨DMA可以把它当做内核CPU的小秘书。比如有一些大量的数据搬运的工作，让CPU来干的话就太浪费资源。比如有个外设ADC模数转换的工作，模数转换为连续模式，每1毫秒转换一次。转换完的数据必须得转运出来，否则数据就会被覆盖丢失 如果直接让CPU来干搬运工作，那CPU每过1毫秒就得来转运一下数据，这样会费时费力影响CPU的正常工作。而且这个工作就是简单的数据搬运，也没必要CPU来干这活，于是DMA这个小秘书就出现了 DMA主要干像数据搬运这样简单且反复要干的事情。DMA通过⑩DMA总线连接到总线矩阵上，它可以拥有和CPU一样的总线控制权，用于访问这些外设小弟。当需要DMA搬运数据时，外设小弟就会通过请求线发送DMA请求，然后DMA就会获得总线控制权访问并转运数据。整个过程不需要CPU的参与，省下CPU的资源来干其他的事情 3.5 芯片引脚定义 STM32F103C8T6的引脚定义图 在引脚名称和引脚序号示意图中，左上角的小黑点代表它左边的引脚是1号引脚，然后逆时针依次排列，直到48号引脚，下面的表格是每个引脚的名称和功能，通过颜色进行标记 颜色标记说明 标记红色的是电源相关的引脚 标记蓝色的是最小系统相关的引脚 标记绿色的是IO口、功能口这些引脚 关于上表的几点说明 前两列是引脚号和引脚名称，和上面的芯片引脚一一对应 类型：S代表电源、I代表输入、O代表输出、IO代表输入输出 I/O电平：表示I/O所能容忍的电压，FT表示可以容忍5V电压，没有表示可以容忍3.3V电压。如果某个引脚没有FT，需要接5V的电压，就需要加装电平转换电路 主功能：上电后默认的功能，一般和引脚名称相同；若不同，引脚的实际功能是主功能，而不是引脚名称的功能 默认复用功能：IO口上同时连接的外设功能引脚，这个配置IO口的时候可以选择是通用IO口还是复用功能 重定义功能：如果有两个功能同时复用在了一个IO口上，而你确实需要用到这两个功能。那你可以把其中一个复用功能重映设到其他端口上，当然前提是这个重定义功能的表里有对应的端口 STM32F103C8T6引脚说明见下，参考链接：点击传送 1号引脚是VBAT，它是备用电池供电的引脚，在这个引脚可以接一个3V的电池。当系统电源断电时，备用电池可以给内部的RTC时钟和备份寄存器提供电源 2号引脚是IO口、或者侵入检测、或者RTC IO口可以根据程序输出或读取高低电平，是最基本也是最常用的功能 侵入检测可以用来做安全保障的功能，比如你的产品安全性比较高，可以在外壳加一些防拆的触点，然后接上电路到到这个引脚。如果有人强行拆开设备，那触点断开这个引脚的电平变化，就会触发STM32的侵入信号，然后就会清空数据来保证安全 RTC引脚可以用来输出RTC较准时钟、RTC闹钟脉冲或者秒脉冲 3、4号引脚是IO口，或者接32.768KHz的RTC晶振。2的15次方是32768，内部RTC经过2的15次方分频，就可以产生1秒的时间信号 5、6号引脚（在板子背面）接系统的主晶振，一般是8MHz。然后芯片内有锁相环电路，可以对这个8MHz的频率进行倍频，最终产生72MHz的频率作为系统的主时钟 7号引脚NRST是系统复位引脚，N代表它是低电平复位 8、9号引脚是内部模拟部分的电源（物理引脚没找到），比如ADC、RC振荡器等。VSS是负极，接GND；VDD是正极，接3.3V 10-19号引脚都是IO口，其中PA0还兼具了WKUP功能，可以用于唤醒处于待机模式的STM32 20号引脚是IO口或者BOOT1引脚，BOOT引脚用来配置启动模式 21、22号引脚是IO口 23、24号引脚的VSS_1和VDD_1是系统的主电源口。同样的VSS是负极，VDD是正极。另外下面还有VSS_2（35引脚）、VDD_2（36引脚）、VSS_3（47引脚）、VDD_3（48引脚），都是系统的主电源口。这里STM32内部采用了分区供电的方式，所以供电口会比较多。在使用时，把VSS都接GND，VDD都接3.3V即可 25-33号引脚都是IO口 34号引脚，加上37号到40号引脚，这些是IO口或者调试端口。上电默认的主功能是调试端口，调试端口用来调试程序和下载程序 STM32支持SWD和JTAG两种调试方式，SWD需要两根线，分别是SWDIO和SWCLK。JTAG需要五根线，分别是JTMS、JTCK、JTDI、JTDO、NJTRST 本教程使用的是STLINK来下载调试程序，STLINK用的是SWD的方式，所以只需要占用PA13、PA14这两个IO口 在使用SWD的调试方式时，剩下的PA15、PB3、PB4可以切换为普通的IO口来使用。但要在程序中进行配置，不配置默认是不会用做IO口，执行上电的主功能 41号到43号，45号到46号都是引脚是IO口 44号引脚是BOOT0，和上面介绍的BOOT1一样，用来进行启动配置 引脚号 引脚名称 类型 I/O口电平 主功能 默认复用功能 重定义功能 1 VBAT S(电源) VBAT 2 PC13-TAMPER-RTC I/O PC13 TAMPER-RTC 3 PC14-OSC32_IN I/O PC14 OSC32_IN 4 PC15-OSC32_OUT I/O PC15 OSC32_OUT 5 OSC_IN I OSC_IN 6 OSC_OUT O OSC_OUT 7 NRST I/O NRST 8 VSSA S VSSA 9 VDDA S VDDA 10 PA0-WKUP I/O PA0 WKUPUSART2_CTSADC12_IN0TIM2_CH1_ETR 11 PA1 I/O PA1 USART2_RTSADC12_IN1TIM2_CH2 12 PA2 I/O PA2 USART2_TXADC12_IN2TIM2_CH3 13 PA3 I/O PA3 USART2_RXADC12_IN3TIM2_CH4 14 PA4 I/O PA4 SPI1_NSSUSART2_CKADC12_IN4 15 PA5 I/O PA5 SPI1_SCKADC12_IN5 16 PA6 I/O PA6 SPI1_MISOADC12_IN6TIM3_CH1 TIM1_BKIN 17 PA7 I/O PA7 SPI1_MOSIADC12_IN7TIM3_CH2 TIM1_CH1N 18 PB0 I/O PB0 ADC12_IN8TIM3_CH3 TIM1_CH2N 19 PB1 I/O PB1 ADC12_IN9TIM3_CH4 TIM1_CH3N 20 PB2 I/O FT PB2/BOOT1 21 PB10 I/O FT PB10 I2C2_SCLUSART3_TX TIM2_CH3 22 PB11 I/O FT PB11 I2C2_SDAUSART3_RX TIM2_CH4 23 VSS_1 S VSS_1 24 VDD_1 S VDD_1 25 PB12 I/O FT PB12 SPI2_NSSI2C2_SMBAIUSART3_CKTIM1_BKIN 26 PB13 I/O FT PB13 SPI2_SCKUSART3_CTSTIM1_CH1N 27 PB14 I/O FT PB14 SPI2_MISOUSART3_RTSTIM1_CH2N 28 PB15 I/O FT PB15 SPI2_MOSITIM1_CH3N 29 PA8 I/O FT PA8 USART1_CKTIM1_CH1/MCO 30 PA9 I/O FT PA9 USART1_TXTIM1_CH2 31 PA10 I/O FT PA10 USART1_RXTIM1_CH3 32 PA11 I/O FT PA11 USART1_CTSUSBDMCAN_RXTIM1_CH4 33 PA12 I/O FT PA12 USART1_RTSUSBDPCAN_TXTIM1_ETR 34 PA13 I/O FT JTMS/SWDIO PA13 35 VSS_2 S VSS_2 36 VDD_2 S VDD_2 37 PA14 I/O FT JTCK/SWCLK PA14 38 PA15 I/O FT JTDI TIM2_CH1_ETRPA15SPI1_NSS 39 PB3 I/O FT JTDO PB3TRACESWOTIM2_CH2SPI1_SCK 40 PB4 I/O FT NJTRST PB4TIM3_CH1SPI1_MISO 41 PB5 I/O PB5 I2C1_SMBAI TIM3_CH2SPI1_MOSI 42 PB6 I/O FT PB6 I2C1_SCLTIM4_CH1 USART1_TX 43 PB7 I/O FT PB7 I2C1_SDATIM4_CH2 USART1_RX 44 BOOT0 I BOOT0 45 PB8 I/O FT PB8 TIM4_CH3 I2C1_SCLCAN_RX 46 PB9 I/O FT PB9 TIM4_CH4 I2C1_SDACAN_TX 47 VSS_3 S VSS_3 48 VDD_3 S VDD_3 上表中，引脚名称没有加粗，表示优先推荐使用加粗的引脚。没有加粗的IO口，可能需要进行配置，或者兼具其他功能，使用时需要留意一下 3.6 启动配置 启动配置的作用就是指定程序开始运行的位置。一般情况下，程序都是在Flash程序存储器开始执行。但是在某些情况下，我们也可以让程序在别的地方开始执行，用以完成特殊的功能 STM32F10XXX的启动配置见下图，可以通过配置BOOT0和BOOT1引脚来选择三种不同的启动模式 主闪存存储器模式 当BOOT0引脚接0，也就是接地的意思，这个时候BOOT1接X，就是无论接什么，启动模式都是主闪存存储器的模式。这时候主闪存存储器被选为启动区域，也就是正常的执行Flash闪存里面的程序。这个模式是最常用的模式，一般情况下都是这个模式 系统存储器模式 当BOOT1接0，BOOT0接1，接1就是接到3.3V电源正的意思。那启动模式就是系统存储器，说明系统存储器被选为启动区域，这个模式用来做串口下载。系统存储器就是STM32中一段Bootloader程序，Bootloader程序的作用就是接收串口的数据，然后刷新到主闪存中，这样就可以使用串口下载程序。一般我们需要串口下载程序的时候会配置到这个模式 何时用到串口下载，可以看引脚定义表。34、37、38、39、40这5个引脚是调试端口，它们既可以用来下载程序，也可以用作普通IO口。如果我们在程序中把这5个端口全部配置成IO口，那就坏了。因为没有调试端口，无法下载程序。所以在配置这几个端口的时候要小心，不要把他们全部配置成普通IO口 如果全部配置成IO口，无法下载程序，这就需要用到串口的方式下载程序，此时需要配置BOOT1为0，BOOT0为1。当然串口下载也不光是用来救急的，如果你没有STLINK，也没有JLINK，就可以使用串口下载程序，这样就多了一种下载程序的方式 内置SRAM模式 BOOT1接1，BOOT0接1是配置为内置SRAM模式，这个模式主要是用来进行程序调试 说明：在系统复位后SYSCLK的第4个上升沿，BOOT引脚的值将被锁定，用户可以通过设置BOOT1和BOOT0引脚的状态来选择复位后的启动模式。这个意思是BOOT引脚的值是在上电复位后的一瞬间有效的。从引脚定义表可以看出，BOOT1和PB2在同一个引脚上，也就是在上电的瞬间是BOOT1的功能，当第4个时钟过后就是PB2的功能 启动模式选择引脚 启动模式选择引脚 启动模式 说明 BOOT1 BOOT0 X 0 主闪存存储器 主闪存存储器被选为启动区域，最常用，一般用这个配置 0 1 系统存储器 系统存储器被选为启动区域，主要用于串口下载 1 1 内置SRAM 内置SRAM被选为启动区域，主要用来程序调试 3.7 STM32最小系统电路 STM32的最小系统电路见下图 STM32及供电 三个分区供电的主电源①②③和模拟部分电源④都连接了供电引脚，VSS都连接了GND，VDD都连接了3V3也就是3.3V。在3.3V和GND之间一般会连接一个滤波电容，这个电容可以保证供电电压的稳定。我们在设计电路的时候，一般只要遇到供电都会习惯上的加上几个滤波电容 VBAT是接备用电池，如果需要接备用电池，可以选择一个3V的扭扣电池，正极接VBAT，负极接GND。备用电池是给RTC和备份寄存器服务的，如果不需要这些功能就不用接备用电池，VBAT直接接3.3V或者全空也没问题 晶振 晶振电路接了一个8MHz的主时钟晶振，STM32的主晶振一般都是8MHz。8MHz经过内部锁相环倍频得到72MHz的主频。晶振的两个引脚分别通过OSC_IN和OSC_OUT这两个网络标号，连接到STM32的5、6号引脚，另外还需要接两个20pF的电容，作为启震电容，电容的另一端接地即可，这就是晶振电路 如果你需要RTC功能的话，还需要再接一个32.768KHz的晶振，电路和这个一样，接在3、4号引脚。 这个OSC32就是32.768KHz的意思。因为32.768是2的15次方，内部RTC电路经过2的15次方分频就可以生成一秒的时间信号 复位 复位电路由一个10K的电阻和另一个0.1uF的电容组成。它用来给单片机提供复位信号，NRST接在STM32的7号引脚。NRST是低电平复位的，这个复位电路在上电的瞬间电容是没有电的，电源通过电阻开始向电容充电，并且此时电容呈现的是短路状态，因此NRST引脚就会产生低电平 当电容逐渐充满电时，电容就相当于断路，此时NRST就会被R1上拉为高电平，上电瞬间的波形就是先低电平、然后逐渐高电平，这个低电平就可以提供STM32的上电复位信号 当然电容充电还是非常快的，所以在我们看来单片机就在上电的一瞬间复位。电容左边还并联了一个按键，这个按键可以提供手动复位功能。当按下按键时，电容被放电，NRST引脚通过按键被直接接地，相当于手动产生的低电平复位信号。按键松手后，NRST又回归高电平，单片机从复位状态转为工作状态 平时我们常见到这种复位按键。一般在设备上有个小孔，当设备死机并且不方便断电重启时，就可以拿针戳一下这个小孔里的按键，设备就会复位。这是手动复位的功能，按下按键，程序就从头开始运行的意思 启动配置 H1相当于开关的作用，拨动这个开关就可以让BOOT引脚选择3.3V还是GND。在最小系统版上，使用跳线帽来充当开关的功能，跳线帽插在左边两个引脚相当于接地，插在右边引脚相当于接3.3V，这样就可以配置BOOT的高低电平 下载端口 如果用STLINK下载程序，需要把SWDIO和SWCLK这两个引脚引出来。另外再把3.3V和GND引出来，GND必须引出来，3.3V如果板子自己有供电的话可以不引，建议都引出来 2-1 软件安装 1 安装过程 1.1 安装Keil5_MDK 下载B站链接中的文件，提取码：1234，解压密码：32 加压缩Keil5 MDK.zip，双击MDK524a.EXE，之后逐步进行安装即可，其中需要修改的两个界面如下 上图步骤用于选择安装路径，注意安装盘符和路径不要有中文 上图步骤用于填写个人信息，随便填写即可，之后选择Next进行安装，后面会弹出一个ULINK驱动安装界面，选择YES完成安装 1.2 安装器件支持包 安装完成后打开软件，会弹出如下界面。这个窗口就是用来安装器件支持包的。我们先把它关掉，采用离线的方法进行安装，以减少下载时间 安装器件支持包，可以使用离线和在线安装两种方法。若不安装器件支持包，Keil5中不显示器件型号。下图为刚安装完Keil5_MDK，里面只有ARM一个器件列表，并没有STM32的型号，所以需要安装STM32的器件支持包 离线安装方法：解压缩Keil5 MDK.zip，在支持包文件夹中，找到对应的型号，双击安装即可，本例中选择Keil.STM32F1xx_DFP.2.2.0.pack 在线安装方法：在Keil5 MDK中，点击Pack Installer进入到安装界面，如下图。所有可以用Keil5_MDK软件来开发的芯片都显示在这个界面。此时器件列表还未更新，需要连接网络等待列表更新。更新过程会比较慢，需要耐心等待 更新完的器件列表见下图，可以看的这里有很多公司的名称，里面包含了Keil支持的所有ARM芯片 GigaDevice公司，有目前做的还不错的国产兼容STM32的芯片，叫GD32。里面有GD32F103C8的型号，基本和STM32F103C8T6的芯片一样 MindMotion公司，里面有MM32F103C8T，也是可以兼容STM32F103C8T6的国产芯片。如果觉得STM32的芯片太贵，可以选择国产的芯片替代 STMicroelectronics公司下面就是STM32的芯片，里面包含了现在STM32的所有型号。例如想安装STM32F4芯片的器件库，就点击STM32F4 Series，在右边列表中选择以DFP为后缀的文件，点击Install进行安装即可。也可以从左下角的网站下载，下载之后和离线安装的方法一样 1.3 软件注册 在Keil5图标上右键，选择以管理员身份运行。注意：不能直接双击运行，后面会提示缺少权限；点击File，选择License Management，在Computer ID中复制CID 关闭杀毒软件，在Keil5 MDK.zip的解压缩的文件中，找到keygen_new2032.zip，解压缩。打开解压后的文件夹，可以看到keygen_new2032.exe，此为注册机。如果开不到这个文件，是被杀毒软件隔离了，关闭杀毒软件再次执行上述步骤 双击打开注册机，在CID中填入上一步复制的CID，Target选择ARM，点击Generater，生成序列码，见下图 将序列码复制，回到File->License Management，在New License ID Code(LIC):中填写复制的序列码，点击Add LIC进行激活 提示LIC添加成功，并且上面MDK-ARM Plus这一行的使用期限显示到2032年，见下图，那这就代表软件注射成功了 如果点击Add LIC后出现下述界面，因为没有选择以管理员身份运行。以管理员身份运行Keil，重新执行上述步骤 1.4 安装STLINK驱动 把STLINK查到电脑上，在Keil5 MDK安装路径下，进入ARM->STLink->USBDriver->dpinst_amd64.exe，双击安装即可 回到桌面，右键点击此电脑，选择属性，选择设备管理器，在设备管理器中查看是否有STM32 STLink的驱动，如果有就表示安装成功 另外在这个目录下，还有JLINK的驱动。JLINK也是一种常用的调试器，如果你想安装JLINK驱动，打开Segger文件夹，双击JLink.exe就可以安装JLINK的驱动 1.5 安装USB转串口驱动 把USB转串口模块插到电脑上，在STM32入门教程的资料文件夹中，打开工具软件文件夹，打开USB转串口CH340驱动文件夹，双击CH341SER.EXE，点击安装，出现驱动安装成功即可 2-2 新建工程 1 STM32的开发方式 基于寄存器的方式：基于寄存器的方式是用程序直接配置寄存器实现特定的功能。这种方式最底层，最直接，效率会更高一些。但是由于STM32的结构复杂，寄存器太多，所以基于寄存器的方式初学不推荐 基于库函数的方式：基于库函数的方式是使用ST官方提供的封装好的函数，通过调用这些函数来间接的配置寄存器。由于STM32对寄存器封装的较好，所以这种方式既能满足对寄存器的配置，对开发人员也比较友好，有利于提高开发效率，推荐初学者使用。本教程采用此种方式 基于HAL库的方式：基于HAL库的方式是用图形化界面快速配置STM32，这个比较适合快速上手STM32。但是这种方式隐藏了底层逻辑，如果你对STM32不熟悉，基本只能停留在很浅的水平，所以目前暂时不推荐HAL库。但是你学过标准库之后，可以去了解一下这个方式，基于HAL库的方式还是非常方便的 使用库函数的方式，需要准备一个STM32库函数的压缩包。在网盘链接的资料中，找到固件库的文件夹，进入之后可以看到STM32F10x_StdPeriph_Lib_V3.5.0.zip文件，解压该文件，可以看到库函数目录如下图 第一个文件夹里只有两个图片，没什么用 第二个Libraries里面是库函数的文件了，后面新建工程时会用到 第三个Project是官方提供的工程示例和模板，以后使用库函数的时候可以参考一下 第四个Utilities是STM32官方评估板的相关历程，评估板就是官方用STM32做的一个小电路板，用来测评STM32的。这个文件夹里面存的就是这个小电路板的测评程序 最后两个文件，一个是库函数的发布文档，一个是使用手册。发布文档里有一些版本的说明，使用手册里有教怎么使用这个库函数的，大家有时间可以看一下 2 STM32工程模板 2.1 建立工程文件夹 建立工程文件夹：首先建立一个存放工程的文件夹，在D盘或者E盘均可，本例为了演示，在桌面新建。给文件夹起个名字，例如STM32Project，以后我们的工程都存在这个文件夹下 打开Keil5软件，点击菜单栏上的Project，选择New uVision Project，然后选择我们刚才新建的工程文件夹STM32Project。在这里再新建一个文件夹，用来存放本次的工程。给这个文件夹起个名字，例如2-1 STM32工程模板，见下图 进入2-1 STM32工程模板文件夹，给工程文件起个名字。这里我们可以起个通用一点的名字，这个工程的具体内容，可以在文件夹名称说明，文件夹的名称很方便修改，工程名称以后不太方便修改，所以我们就起个Project的名称，然后点击保存，见下图 点击保存后弹出下图界面，选择器件型号。我们的芯片型号是STM32F103C8T6，因此选择STM32F103C8，点击OK 点击OK后弹出下图界面，这个是Keil软件的新建工程小助手，可以帮助我们快速新建工程，我们暂时不用这个小助手，把它关掉 关掉小助手出现下图界面，此时工程就建好了，但是这里的工程文件空空如也，现在这个工程还是不能直接用，我们需要给它添加一些工程的必要文件 2.2 添加工程必要文件 Start文件夹：（共13个文件） 打开固件库的文件夹，打开Libraries->CMSIS->CM3->DeviceSupport->ST->STM32F10x->startup->arm， 这个文件夹里面是STM32的启动文件，STM32的程序就是从启动文件开始执行的，见下图 把这些文件全部复制，回到2-1 工程模板文件夹。该文件夹已经有一些文件，这是我们上一步新建工程时生成的文件，见下图 在此文件夹下面新建一个文件夹，名称为Start，然后把启动文件粘贴到Start文件夹里面（共8个文件），见下图 回到固件库的Libraries->CMSIS->CM3->DeviceSupport->ST->STM32F10x文件夹，里面有stm32f10x.h、system_stm32f10x.c和system_stm32f10x.h三个文件，见下图。stm32f10x.h是STM32的外设寄存器描述文件，跟51单片机的头文件作用一样，是用来描述STM32有哪些寄存器和对应的地址；system_stm32f10x.c和system_stm32f10x.h主要用来配置时钟，STM32主频72MHz，就是system文件里面函数配置的。把这3个文件复制，粘贴到Start文件夹里面（共11个文件） 因为STM32是由内核和内核外围的设备组成，内核的寄存器描述和外围设备的描述文件不在一起，所以还需要添加一个内核寄存器的描述文件。打开Libraries->CMSIS->CM3->CoreSupport，里面的两个文件core_cm3.c和core_cm3.h是内核的寄存器描述文件，里面还包括内核的配置函数。把这两个复制，粘贴到Start文件夹（共13个文件），此时Start文件夹有13个文件，Start文件夹工程文件添加完毕，见下图 回到Keil软件，把刚才新建的Start文件夹添加到工程中来：点击选中source group 1，按F2修改名称为Start。然后在Start上右键，选择“Add Existing Files to Group ‘Start’”，见下图 在弹出的文本框中选择Start，下方文件类型选择All files，见下图 进入Start文件夹后，选中下图标记的6个文件，点击右下角Add按钮，将所选文件添加到Keil的Start文件夹 添加完毕工程文件的Start文件夹见下图 至此，Start文件添加好了。这里是STM32最基本的文件，是不需要修改的，直接添加进来就可以。文件图标上带了个小钥匙，表示该文件为只读文件 最后，还需要为工程文件添加头文件路径，不然Keil软件是找不到.h文件的。打开“魔术棒”按钮，此按钮为工程的配置选项。切换到“C/C++”选项卡，见下图 在“C/C++”里面，找到Include paths，点击右边三个点按钮，见下图 在弹出的窗口中点击下图所示的new，新建头文件路径 在头文件路径中，点击右边三个点按钮，在弹出的路径选择中，选择Start，最后点击下方OK，见下图 User文件夹（共4个文件） User文件夹用于存放用户的代码。这里先做个测试，看看前面配置的工程文件是否有问题。打开2-1 STM32工程模板，在此文件下面新建User文件夹。打开Keil，在Target 1上右键，选择\"Add Group\"，修改名称为User。在User上右键，选择“Add New Item to Group ‘User’”，选择“C File”，名字叫main。下面的路径注意下，选择新建的User文件夹，不然默认是在放2-1 STM32工程模板文件夹，然后点击add，这样就有main.c文件了。此处操作与上面类似，我们直接给出结果，见下图 在 mian.c 文件中，点击右键，选择“Insert 'include' file”，选择“stm32f10x.h”。按照下图编写 main函数，注意最后一行要留一个空行，否则编译会报警告。编写完成后，点击“Build”编译工程，如果出现 0 Error(s) 0 Warning(s)，则表示工程构建的没有问题。这个工程目前还没有添加库函数，只能使用配置寄存器的方式进行编程 可以根据需要进行参数配置：点击扳手按钮，此按钮为Keil的配置选项。在“Colors & Fonts”标签下可以修改字体大小，在“Editor”标签下可以修改编码格式，这里选择“Encode in UTF-8 without signature”，以防止出现中文乱码的问题；在“Editor”标签下的“C/C++ Files”，选择Tab size为4 将STM32最小系统板，连接STLINK后插在电脑的USB上，连接方式见下图 此时电源指示灯LED常亮，PC13对应的LED不断闪烁，这是STM32内置的测试程序。在Keil软件中配置调试器：点击魔术棒按钮，选择“Debug”，调试器默认是ULINK，我们使用的是STLINK，所以选择ST-Link Debugger。然后点击右边的“Setting”按钮，在“Flash Downlaod”标签下，勾选“Reset and Run”。勾选之后，我们下载程序后会立马复位并执行，否则需要按一下板子上的复位按键才可以执行，都配置好之后，点击确认 重新编译一下，然后点击“Load”按钮，程序就下载到STM32里面了。因为我们编写的主程序中只有一个while空循环，可以看到STM32最小系统板上面PC13对应的LED灯已经停止闪烁 Library文件夹（共46个文件） 在2-1 STM32工程模板文件夹中新建Library文件夹，用于存放库函数。打开固件库的文件夹，打开Libraries->STM32F10x_StdPeriph_Driver->src，该文件就是库函数的源文件，其中misc.c是内核的库函数，其他的是内核外的外设的库函数。按Ctrl + A全选，复制到2-1 STM32工程模板目录下的Library文件夹。再打开Libraries->STM32F10x_StdPeriph_Driver->inc，这里面是库函数的头文件，还是Ctrl + A全选，复制到2-1 STM32工程模板目录下的Library文件夹。此时，Library文件夹中共有46个文件 打开keil软件，在Target 1上右键，选择Add group，修改名称为Library。在Library上右键，选择Add Existing Files to Group 'Library'。选择2-1 STM32工程模板目录下的Library文件夹，按Ctrl + A全选，点击add（共46个文件），这样库函数就添加进来了 打开固件库文件夹，打开Project->STM32F10x_StdPeriph_Template，找到stm32f10x_conf.h、stm32f10x_it.c和stm32f10x_it.h。其中stm32f10x_conf.h是用来配置库函数头文件包含关系的，还包括用来参数检查的函数定义，这是所有库函数都需要的；stm32f10x_it.c和stm32f10x_it.h是用来存放中断函数的。把这3个文件复制到2-1 STM32工程模板的User目录下。现在User目录有4个文件，main.c和这3个文件。打开Keil软件，把刚才那3个文件添加到User组中，见下图 最后还需要进行宏定义。在main.c文件中，在头文件上右键，选择“Open documnent stm32f10x.h”，滑到最下面，找到 #ifdef USE_STDPERIPH_DRIVER #include \"stm32f10x_conf.h\" #endif 这句话表示如果你定义了USE_STDPERIPH_DRIVER，才会使用stm32f10x_conf.h，因此需要定义USE_STDPERIPH_DRIVER。打开魔术棒按钮，在“C/C++”的Define：选项中，填写USE_STDPERIPH_DRIVER，这样才能包含标准外设库，也就是库函数。然后在下面的头文件路径中，把User和Library的路径添加进来，这样基于库函数的工程就建好了，见下图 编译，第一次编译比较慢，以后就快了，出现\".\\Objects\\Project.axf\" - 0 Error(s), 0 Warning(s).表示工程构建成功 3 使用库函数进行点灯的操作 下面编写一个STM32的Hello World入门程序： ​ 1. 第一步：使能时钟，RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); 函数名称为RCC_APB2PeriphClockCmd，这里面需要两个参数，通过右键跳转到函数定义，可以知道可用的参数有哪些 ​ 2. 第二步：配置端口模式，GPIO_Init(GPIOC, &GPIO_InitStructure); 函数名称为GPIO_Init，这里面需要两个参数，第一个是GPIOx，x从A到G，第二个是结构体的指针，因此先定义一个结构体 ​ 3. 第三步：定义结构体，定义结构体关键字为GPIO_InitTypeDef，结构体名称为GPIO_InitStructure。这个结构体有3个成员，通过.可以引出包含的成员，分别为GPIO_Mode、GPIO_Pin和GPIO_Speed。然后在每个成员上点击右键，跳转到成员参数定义，查看可以使用的值，填到结构体对应的参数位置 ​ 4. 第四步：设置指定端口为高电平，进行点灯操作。使用GPIO_SetBits(GPIOC, GPIO_Pin_13); 函数名称为GPIO_SetBits，这个函数有两个参数，GPIOx和GPIO_Pin，GPIOx为A到G，GPIO_Pin为具体的引脚号，此处为13号引脚 ​ 5. 第五步：设置指定端口为低电平，进行熄灯操作，GPIO_ResetBits(GPIOC, GPIO_Pin_13) ​ 6. 整体操作： RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC,ENABLE); GPIO_InitTypeDef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13; GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; GPIO_Init(GPIOC, &GPIO_InitStructure); //GPIO_SetBits(GPIOC, GPIO_Pin_13); GPIO_ResetBits(GPIOC, GPIO_Pin_13); 4 启动文件的选择依据 在Keil的Start文件中，选择startup_stm32f10x_md.s作为启动文件，见下图 其选择依据如下：参照下表，STM32F103C8T6的Flash大小为64K，因此选择MD作为启动文件 5 新建工程的步骤总结 第一步：建立工程文件夹，Keil中新建工程，选择型号 第二步：在工程文件夹中建立Start、User、Library等文件夹，复制固件库里面的文件到工程文件夹。这个文件夹的名称和数量没有限制，可以根据需求自行建立，方便文件管理即可 第三步：在Keil工程中对应建立Start、User、Library等同名称的分组，然后将文件夹内的文件添加到工程分组里 第四步：配置工程选型，在C/C++的Include Paths内声明所有包含头文件的路径。因为User、Library是自己建立的，Keil并不知道文件夹的具体位置。因此需要声明一下该文件的路径，方便Keil进行头文件的查找 第五步：配置工程选型，在C/C++的Define内配置宏定义USE_STDPERIPH_DRIVER。这是使用库函数的条件编译，使用库函数就必须声明这个宏定义 第六步：配置工程选项，配置调试器为ST-Link Debugger，在Settings的Flash Download选型中勾选Reset and Run。这个是选择调试器进行下载的选项，因为我们使用的是STLINK，因此需要做相关配置 新建工程比较灵活，每个人都可以制定自己的风格，只要编译通过即可 6 工程架构 第一列：startup_xx.s startup_xx.s是启动文件，是程序执行最基本的文件。这个文件是用汇编语言写的，启动文件中定义了中断向量表、中断服务函数等 中断服务函数中有个复位中断，这就是整个程序的入口。当STM32上电复位或者按了复位按钮之后，程序进入复位中断函数执行。复位中断函数做两件事情：一是调用SystemInit函数，二是调用main函数，对应在启动文件的131-137行。然后就结束了，实际上单片机的程序永远也不会结束，所以在main函数的最后一定是一个死循环 在启动文件还定义了STM32所有的其他中断，这些中断达到触发条件后就会自动执行。其他中断函数的定义，在stm32f10x_it.c/.h中 第二列：system_xx.c/.h、main.c、stm32f10x_it.c/.h、其他用户文件 SystemInit是定义在system_xx.c/.h文件中。通过Keil中函数的定义可知，这个函数是用于设置微控制器的启动、初始化嵌入式闪存接口、锁相环、更新系统内核的时钟变量等，这个函数只在复位后需要调用 在执行main.c函数之前，单片机就已经执行了一堆东西。帮我们把闪存接口、时钟的一系列东西都配置好了 其他中断函数的定义，在stm32f10x_it.c/.h中 最后是自定义的用户文件，来封装一些模块供主函数和中断使用 以上两部分是工程主动执行的部分，相当于上电后系统自动执行的部分，不需要修改。最后一列是被动执行的东西，相当于STM32的资源，我们在主函数或者中断函数里就可以调用这些资源 第三列：stm32f10x.h、core_cm3.c/.h、misc.c/.h、stm32f10x_conf.h stm32f10x.h是外设的寄存器描述 core_cm3.c/.h是内核寄存器描述 misc.c /.h、stm32f10x_adc.c/.h 等是库函数文件。每个外设都提供了丰富的库函数，用于对外设的操作 stm32f10x_conf.h是库函数的配置文件，用来配置头文件的包含关系。stm32f10x_conf.h文件包含了所有的库函数头文件，同时我们在stm32f10x.h的最后又包含了stm32f10x_conf.h。所以在使用这些库函数时，我们只需要包含stm32f10x.h这一个头文件，就相当于包含了所有库文件的头文件，这样我们就可以任意调用库函数了 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/STM32/chapter1-2.html":{"url":"Markdown/STM32/chapter1-2.html","title":"1.2 STM32外设-GPIO","keywords":"","body":"1.2 STM32外设-GPIO 3-1 GPIO输出 1 GPIO简介 GPIO(General Purpose Input Output)通用输入输出口。GPIO根据使用场景，可配置为8种输入输出模式，见下文“4 GPIO模式” 引脚电平：0V-3.3V。数据0就是低电平0V，数据1就是高电平3.3V，部分引脚可容忍5V 容忍5V的意思是可以在这个端口输入5V的电压，也认为是高电平。但是对输出而言，最大就只能输出3.3V，因为供电就只有3.3V。具体哪些端口能容忍5V，可以参考STM32的引脚定义表，表中带FT的就表示可以容忍5V GPIO输出模式 GPIO在输出模式下可控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等 在其他应用场景，只要是可以用高低电平进行控制的地方，都可以用GPIO完成。如果控制的是功率比较大的设备，只需要再加入驱动电路即可 还可以用GPIO来模拟通应协议，比如IIC、SPI，或者某个芯片特定的协议，都可以用GPIO的输出模式来模拟其中的输出时序部分 GPIO输入模式 GPIO在输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等 如果这个模块输出的是模拟量，GPIO还可以配置成模拟输入的模式，再配合内部的ADC外设，就能直接读取端口的模拟电压 除此之外，模拟通信协议时，接收通信线上的数据也是靠GPIO的输入来完成的 2 GPIO基本结构 STM32中GPIO的基本结构见下图 在STM32中，所有的GPIO外设是挂载在APB2总线上。GPIO外设的名称是按照GPIOA、GPIOB、GPIOC这样的方式命名，每个GPIO外设，总共有16个引脚，编号从0-15。GPIOA常称为PA，其引脚为PA0-PA15 在GPIO模块内，主要包含寄存器和驱动器 寄存器是特殊的存储器，内核可以通过APB2总线对寄存器进行读写，这样就可以完成输出电平和读取电平的功能 寄存器的每一位对应一个引脚。其中，输出寄存器写1，对应的引脚输出高电平；输出寄存器写0，对应的引脚输出低电平。输入寄存器读取为1，代表对应端口目前是高电平；读取为0，代表当前端口为低电平 因为STM32是32位的，即STM32的寄存器都是32位的。但GPIO的端口只有16个，所以寄存器只有低16位对应有端口，高16位没有用到 驱动器是用来增加信号的驱动能力。寄存器只负责存储数据，要是进行点灯操作，还是需要驱动器来负责增大驱动能力 3 GPIO位结构 STM32的位结构电路图如下所示。其中，左边3个为寄存器（位设置\\清除寄存器、输出数据寄存器、输入数据寄存器），中间是驱动器，右边是某一个I/O的引脚 整体结构可以分为两个部分：上面是输入部分，下面是输出部分 输入部分 最右边的I/O引脚①处接了两个保护二极管（补充知识：二极管有两个电极，正极，又叫阳极；负极，又叫阴极，给二极管两极间加上正向电压时，二极管导通， 加上反向电压时，二极管截止），其作用是对输入电压进行限幅 由图可知，上面的二极管接VDD，3V3，下面接Vss，0V。如果输入电压比3V3高，则上方二极管导通，输入电压产生的电流会直接流入VDD而不会流入电路内部，这样可以避免过高的电压对内部的电路产生伤害 如果输入的电压比Vss还要低（该电压是相对于Vss的电压，因此可以有负电压），下方二极管导通，电流直接从Vss流出，而不会从内部电路汲取电流，从而保护内部电路 若输入电压在0-3V3之间，则两个二极管均不会导通，二极管对电路没有影响，这就是保护二极管的用途 接下来电路连接到② 处的上拉电阻和下拉电阻。上拉电阻连接VDD，下拉电阻连接Vss，这个开关可以通过程序进行配置：如果上面导通，下面断开，就是上拉输入模式；下面导通，上面断开，就是下拉输入模式；如果两个都断开，就是浮空输入模式。上拉和下拉电阻的作用是给输入提供一个默认的输入电平 对于数字端口，输入不是高电平就是低电平。若引脚什么都不接，高低电平就不好判断。实际情况下，如果输入什么都不接，那输入处于浮空的状态，引脚的输入电平极易受到外界的干扰而改变 为了避免引脚悬空导致的输入数据不确定，通常需要添加上拉电阻或者下拉电阻。 如果接入上拉电阻，当引脚悬空时，上拉电阻可以保证引脚默认为高电平。所以上拉输入又可以称作是默认为高电平的输入模式。下拉也是同理，就是默认为低电平的输入方式 上拉电阻和下拉电阻的阻值一般都比较大，是一种弱上拉和弱下拉（见3-3节杆子弹簧模型的分析），目的是尽量不影响正常的输入操作 ③处是一个肖特基触发器（实际上应该是施密特触发器）。施密特触发器的的作用就是对输入电压进行整型，其执行逻辑： 如果输入电压大于某一阈值，输出就会瞬间升为高电平；如果输入电压小于某一阈值，输出就会瞬间降为低电平 特别说明：输入电压只有高于上限，或者低于下限，输出才会变化。对于低于上限，但是高于下限的输入，施密特触发器的输出维持不变 由于引脚的波形是外界输入的，虽然是数字信号，实际情况下可能会产生各种失真。见上图黑色线条所示的波形，这是一个夹杂了波动的高低变化电平信号。如果没有斯密特触发器，很有可能因为干扰而导致误判 如果有了施密特触发器，指定一个如上图所示的阈值上下限。高于上限输出高，低于下限输出低。施密特触发器的输出： 首先是低于下限输出低，然后在①处高于上限，输出立即变为高。虽然这里信号由于波动再次低于上限，但是对于施密特触发器来说，只有高于上限或者低于下限输出才会变化。所以此时低于上限的情况，输出并不会变化，而是继续维持高电平 直到下次低于下限时才会转为低电平（②处）。这里信号即使在下限附近来回横跳，因为没有高于上限，所以输出仍然是低电平，直到下一次高于上限输出高电平 从图中可以看到，相比于输入信号，经过施密特触发器整型的信号接近于方波，完美多了。这里用了两个比较阈值来进行判断，中间留有一定的变化范围，这样可以有效的避免因信号波动造成的输出抖动现象 接下来经过施密特触发器整型的波形可以直接写入输入数据寄存器（④处）了，我们再通过程序读取输入寄存器对应某一位的数据，就可以知道输入端口的电平 最后上面⑤处还有两路线路，该线路是连接到片上外设的端口。其中模拟输入是连接到ADC上的，因为ADC需要模拟量，所以这根线是连接到施密特触发器之前的。另外一根是复用功能输入，这个是连接到其他需要读取的外设上，比如串口的输入引脚等，这根线接收的是数字量，所以在施密特触发器之后 输出部分 数字部分可以由输出数据寄存器①或者片上外设②控制，两种方式通过数据选择器③接到了输出控制部分。如果选择输出数据寄存器控制，就是普通的I/O输出。写这个数据寄存器的某一位，就可以操作对应的某个端口 位设置/清除寄存器（④处），可以单独操作输出数据寄存器的某一位而不影响其他位。因为输出数据寄存器同时控制16个端口，并且这个寄存器只能整体读写，所以想单独控制其中某一个端口而不影响其他端口，就需要特殊的操作方式： 第一种方式是先读出这个寄存器，然后用按位与和按位或的方式更改某一位，最后再将更改后的数据写回去。在C语言中就是&=和|=的操作，这种方法比较麻烦，效率不高，对于IO的操作不太合适 第二种方式是通过位设置/清除寄存器。若要对某一位进行置1，在位设置寄存器对应位写1即可，剩下不需要操作的位写0。这样它内部的电路会自动将输出数据寄存器的对应位设置为1，剩下写0的位置保持不变，这样就保证了只操作其中某一位而不影响其他位，并且这是一步到位的操作。如果想对某一位进行清零，就在位清除寄存器的对应位写1，这样内部电路就会把这位清零。库函数使用的就是读写位设置/清除寄存器的方法 第三种操作方式就是读写STM32中的位带区域。位带的作用就跟51单片机的位寻址作用差不多，在STM32中专门分配有一段地址区域，这段地址映射了RAM和外设寄存器所有的位。读写这段地址中的数据，就相当于读写所映射位置的某一位，这就是位带的操作方式 输出控制之后接了两个MOS管（⑤处），分别是P-MOS和N-MOS。MOS管是一种电子开关，通过信号控制MOS管的导通和关闭，从而将I/O口接到VDD或者Vss。这里可以选择推挽、开漏和关闭三种输出模式： 在推挽输出模式下，P-MOS和N-MOS均有效。输出数据寄存器为1时，P-MOS导通，N-MOS断开，输出直接接到VDD，即输出高电平。输出数据寄存器为0时，P-MOS断开，N-MOS导通，输出直接接到VSS，即输出低电平。这种模式下，高低电平均有较强的驱动能力，故推挽输出也叫强推输出模式。在推挽输出模式下，STM32对IO口具有绝对的控制权，高低电平都由STM32决定 在开漏输出模式下，P-MOS无效，只有N-MOS工作。数据寄存器为1时，N-MOS断开，这时输出相当于断开，为高阻模式。输出数据寄存器为0时，N-MOS导通，输出接到VSS，输出低电平 这种模式下，只有低电平有驱动能力，高电平没有驱动能力。这种模式通常用于通信协议的驱动方式（I2C等）。在多机通信的情况下，这个模式可以避免各个设备的相互干扰（待解释） 开漏模式还可以用于输出5V的电平信号：比如在IO口外接一个上拉电阻到5V的电源。当输出低电平时，由内部的N-MOS直接连接VSS。当输出高电平时，由外部的上拉电阻拉高至5V。这样就可以输出5V的电平信号，用于兼容一些5V电平的设备，以上是开漏输出的主要用途 在关闭模式下，当引脚配置为输入模式时，P-MOS和N-MOS均无效，输出关闭，端口的电平由外部信号来控制 4 GPIO工作模式 通过配置GPIO的端口配置寄存器，端口可以配置成以下8种模式 模式名称 性质 特征 浮空输入 数字输入 可读取引脚电平，若引脚悬空，则电平不确定 上拉输入 数字输入 可读取引脚电平，内部连接上拉电阻，悬空时默认为高电平 下拉输入 数字输入 可读取引脚电平，内部连接下拉电阻，悬空时默认为低电平 模拟输入 模拟输入 GPIO无效，引脚直接接入内部ADC 开漏输出 数字输出 可输出引脚电平，高电平为高阻态，低电平接VSS 推挽输出 数字输出 可输出引脚电平，高电平接VDD，低电平接VSS 复用开漏输出 数字输出 由片上外设控制，高电平为高阻态，低电平接VSS 复用推挽输出 数字输出 由片上外设控制，高电平接VDD，低电平接VSS 浮空/上拉/下拉输入 浮空/上拉/下拉输入的电路结构基本是一样的，区别就是上拉电阻和下拉电阻的连接。它们都属于数字输入口，特征就是都可以读取端口的高/低电平。当引脚悬空时，上拉输入默认是高电平，下拉输入默认是低电平。浮空输入的电平是不确定的，所以在使用浮空输入时，端口一定要接上一个连续的驱动源，不能出现悬空的状态。这三种模式的电路结构见下图 在输入模式下，输出数据驱动寄存器是断开的（①处），端口只能输入而不能输出。通过两个电阻（②处）可以选择为上拉工作、下拉工作或者都不工作，对应的就是上拉输入、下拉输入和浮空输入 输入经过施密特触发器进行波形整型后连接到输入数据寄存器。另外最右边的输入保护，写的是VDD或者VDD_FT（③处），这是3V3端口和容忍5V端口的区别 模拟输入 模拟输入的电路结构如下。由图可知，输出数据寄存器是断开的（①处），输入的施密特触发器是关闭的无效状态（②处）。整个GPIO只有模拟输入有效，即从引脚直接接入片上外设（③处），即ADC。因此当使用ADC时，将引脚配置为模拟输入就行，其他时候一般用不到模拟输入 开漏/推挽输出 开漏/推挽输出的电路结构如下，这两个电路也基本一样，都是数字输出口，可以用于输出高低电平。区别就是开漏输出的高电平呈现高阻态，没有驱动能力，而推挽输出的高/低电平都具有驱动能力 输出由输出数据寄存器控制（①处）。若P-MOS无效，就是开漏输出；若P-MOS和N-MOS均有效，就是推挽输出。另外可以看到，在输出模式下，输入模式也是有效的（②处）。但是在输入模式下，输出是无效的。这是因为一个端口只能有一个输出，但是输入可以有多个。所以配置成输出模式的时候，内部也可以输入一下，这个不影响 复用开漏/复用推挽输出 复用开漏/复用推挽输出的电路结构如下。在这个模式下，输出数据寄存器是断开的（①处），引脚电平是由片上外设控制的（②处）。在输入部分，片上外设也可以读取引脚电平，同时普通输入也是有效的，顺便接收一下电平信号 注：上述GPIO的8种模式中，除了模拟输入模式会关闭数字输入功能。在其他的7种模式中，所有输入均有效。但在浮空、上拉、下拉输入模式中，输出是断开的 5 LED和蜂鸣器简介 LED：发光二极管，正向通电点亮，反向通电不亮。正负极判断方法： 一般长脚是正极，短脚是负极 看LED内部，较小一半是正极，较大一半是负极 有源蜂鸣器：内部自带振荡源，将正负极接上直流电压即可持续发声，频率固定 无源蜂鸣器：内部不带振荡源，需要控制器提供振荡脉冲才可发声，调整提供振荡脉冲的频率，可发出不同频率的声音 LED和蜂鸣器的硬件电路见下图 LED驱动电路 左上图是低电平驱动电路，LED正极接3V3，负极通过一个限流电阻接到PA0。当PA0输出低电平，LED两端产生电压差，形成正向导通电流，LED点亮；当PA0输出高电平时，因为LED两端都是3V3，不会形成电流，LED熄灭。限流电阻一般都是要接的，一方面防止LED因为电流过大而烧毁，另一方面可以调整LED的亮度 左下图为高电平驱动的电路，LED负极接GND，正极通过一个限流电阻接到PA0。当PA0输出高电平，LED点亮；当PA0输出低电平，LED熄灭 这两种驱动方式的选择依据：要根据I/O端口的驱动能力进行选择，若I/O口具有高电平驱动能力（推挽输出），则这两种接线方法均可。若I/O口只有低电平驱动能力（开漏输出），则只能选左上图所示低电平驱动的接线方式 但是在单片机的电路里面，一般倾向于第一种接法，即低电平驱动的方式。因为很多单片机或者芯片，都使用了高电平弱驱动，低电平强驱动的规则，这样一定程度避免高低电平打架。所以若高电平驱动能力弱，就不能使用第二种高电平驱动方法 蜂鸣器驱动电路 右边是蜂鸣器驱动电路，这里使用了三极管开关的驱动方案。三极管开关是最简单的驱动电路，对于功率大一点的对象，直接用I/O驱动会导致STM32负担过重，这时可以用一个三极管驱动电路来完成驱动任务 右上是PNP三极管的驱动电路，三极管左边是基极，带箭头的是发射极，剩下的是集电极。左边的基极给低电平，三极管导通。通过3V3和GND，就可以给蜂鸣器提供驱动电流了。基极给高电平，三极管截至，蜂鸣器没有电流 右下是NPN三级管的驱动电路，左边是基极，带箭头的是发射极，剩下的是集电极。它的驱动逻辑和上面相反，基极给高电平导通，低电平断开 需要注意：PNP的三极管最好接在负载（蜂鸣器）上面（①处），NPN的三极管最好接在负载（蜂鸣器）下面（②处）。这是因为三极管的通断，是需要在发射极和基极之间产生一定的开启电压，若把负载接在发射极这边，可能会导致三极管无法正常开启 6 面包板简介 面包板的结构见下图 竖着的5个孔，内部都是连接在一起的 上下四排孔，整体的连接在一起的，主要用于供电。有的面包板中间会断开，这个需要测试一下，若是断开的，中间用跳线把两端连接在一起即可 3-2 RCC和GPIO库函数 1 RCC库函数 如上图所示，GPIO是挂载在APB2总线上。因此，操作STM32的GPIO需要3个步骤： 第一步，开启GPIO时钟。使用RCC开启GPIO的时钟 第二步，初始化GPIO。配置GPIO结构体，使用GPIO_Init()函数初始化GPIO 第三步，控制GPIO端口。使用输入或者输出函数控制GPIO口 这其中涉及到RCC和GPIO两个外设，RCC的库函数如下 STM32库函数命名规律： 带Cmd的都是使能或者失能函数 带Config的都是配置函数 使用RCC开启GPIO时钟，需要使用RCC_APB2PeriphClockCmd函数，其定义如下 2 GPIO库函数 GPIO的库函数如下 GPIO操作第二步，初始化GPIO，需要使用GPIO_Init 函数，其包含3个参数，分别为GPIO_Pin、GPIO_Speed、GPIO_Mode GPIO_Pin GPIO_Speed GPIO_Mode GPIO操作第三步，使用输入或者输出函数控制GPIO口，可以使用GPIO_ReadInputDataBit、GPIO_ReadInputData、GPIO_ReadOutputDataBit、GPIO_ReadOutputData、GPIO_SetBits、GPIO_ResetBits、GPIO_WriteBit、GPIO_Write这8个函数 举例：使用GPIO_ResetBits函数进行LED点灯操作，其接线图和代码如下 #include \"stm32f10x.h\" int main(void) { // 第一步，开启GPIO时钟。使用RCC开启GPIO的时钟 RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // 第二步，初始化GPIO。配置GPIO结构体，使用GPIO_Init()函数初始化GPIO GPIO_InitTypedef GPIO_InitStructure; GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; // 推挽输出 GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0; // 控制PA0 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz; // IO口电平切换最大50MHz GPIO_Init(GPIOA, &GPIO_InitStructure); // 第三步，控制GPIO端口。使用输入或者输出函数控制GPIO口 GPIO_ResetBits(GPIOA, GPIO_Pin_0); // GPIO_ResetBits 将PA0置低电平 while(1) // 死循环 { } } 3-3 GPIO输入 1 按键介绍 按键：常见的输入设备，按下导通，松手断开 按键抖动：由于按键内部使用的是机械式弹簧片来进行通断的，所以在按下和松手的瞬间会伴随有一连串的抖动，见下图 按键没按下是高电平，按下了是低电平。在按键按下的瞬间，信号由高电平变为低电平时会来回抖动几下，这个抖动通常在5到10毫秒之间，人是分辨不出来的。但对于高速运行的单片机，5到10毫秒还是很漫长的 所以要对这个抖动进行过滤，否则会出现按键按一下单片机却反映了多次的现象。另外在按键松手的时候也会有一小段的抖动，这个也要注意过滤。最简单的过滤方法就是加一段延时，把这个抖动时间耗过去 2 传感器模块简介 下图是套件中的传感器模块，分别是光敏电阻传感器、热敏电阻传感器、对射式红外传感器和反射式红外传感器，见下图 上述传感器模块的电路结构和工作原理都很类似。这些传感器模块，都是基于传感器元件（光敏电阻/热敏电阻/红外接收管等）的电阻会随外界模拟量的变化而变化的原理。例如光线越强光敏电阻的阻值就越小、温度越高热敏电阻的阻值就越小、红外光线越强红外接收管的阻值就越小 电阻的变化不容易被测量，因此通常将传感器元件与定值电阻进行串联分压，这样就可以得到模拟电压的输出，对电路来说检测电压就非常容易。 另外这些模块还可以通过电压比较器来对模拟电压进行二值化处理，从而得到数字电压输出。下图为传感器模块的基本电路 上图①处所示，N1表示传感器的可变电阻，其阻值会根据环境的光线、温度等模拟量进行变化。R1是和N1进行分压的定值电阻 R1和N1串联，一端接在VCC，一端接在GND负极，这就构成了基本的分压电路。左边的C2是滤波电容，是为了给中间的电压输出进行滤波的，用来滤除一些干扰，保证输出电压波形的平滑（一般在电路中遇到一端接在电路中，另一端接地的电容，都可以考虑是不是滤波电容的作用。如果是滤波电容，那这个电容就是来保证电路稳定的，并不是电路的主要框架，在分析电路的时候可以将其抹掉，帮助简化电路） 可以使用分压定理分析传感器电阻的阻值变化对输出电压的影响 串联分压原理：在串联电路中，各电阻上的电流相等，各电阻两端的电压之和等于电路总电压。可知每个电阻上的电压小于电路总电压，故串联电阻分压 并联分流原理：在并联电路中，各电阻两端的电压相等，各电阻上电流之和等于总电流（干路电流）。可知每个电阻上的电流小于总电流，故并联电阻分流 也可以使用上下拉电阻的思想来分析： 当N1的阻值变小时（电流增大），下拉的作用就会增强，中间的AO端的电压就会拉低。极端情况下，N1阻值为0，AO输出被完全下拉，输出0V 当N1的阻值变大时（电流减小），下拉的作用就会减弱，中间的引脚由于R1的上拉作用，电压就会升高。极端情况下，N1的阻值无穷大，相当于断路，输出电压被R1拉高至VCC。其工作逻辑见下图 杆子弹簧模型分析上下拉电阻 AO的输出端可以想象成放在屋里的水平杆子，R1上拉电阻相当于拴在屋顶的弹簧，将杆子往上拉。N1下拉电阻相当于拴在地面的弹簧，将杆子往下拉。这个电阻的阻值越小，弹簧的拉力就越强。这个杆子的高低就相当于电路中的电压 如果只有上拉弹簧或者下拉弹簧，那么杆子就只能被拉到屋顶或者拉到地面，在电路中就相当于中间点的电压为VCC或者GND。当两个弹簧相互拉扯的时候，中间的输出就会向拉力强一端偏移，至于偏移多少，就取决于两个弹簧的弹力之差 如果上下拉的弹簧拉力一致，杆子就处于居中的位置，则电路输出VCC/2的电压。如果上面的阻值小，拉力强，则输出会变高；反之下面的阻值小，拉力强，输出电压会变低。如果阻值为0，在电路中是短接的状态，那就相当于拉力无穷大。如果上下拉电阻的阻值都为0，就是两个无穷大的力在对抗，在电路中呈现的状态就是电源短路，所以这种情况应该避免 上拉电阻和下拉电阻，在单片机中会经常出现。比如弱上拉，弱下拉，强上拉，强下拉等，这里强和弱就是指电阻阻值的大小，也就是弹簧弹力的大小 。上/下拉电阻阻值小时，可以称为强上/下拉，反之称为弱上/下拉（GPIO的上拉电阻比较大，属于弱上拉）。上拉还是下拉是指接到VCC还是GND，也就是杆子被拉到屋顶还是拉向地面。最终的输出电压就是在弹簧拉扯下最终杆子的高低 在上图所示的传感器电路中，AO是模拟电压的输出。该模块还支持数字输出，即将A0端口的电压进行二值化的输出，二值化是通过LM393（②处）来完成的 LM393是一个电压比较器芯片，里面有两个独立的电压比较器电路，通过VCC和GND供电。电容C1是电源供电的滤波电容 M393相当于运算放大器，当同相输入端的电压大于反相输入端的电压时，输出瞬间升为最大值，即输出接VCC。当同向输入端的电压小于反相输入端的电压时，输出瞬间降为最小值，即输出接GND，这样就可以对一个模拟电压进行二值化 在上述电路中，IN+接到AO端，IN-接了个电位器，电位器的接法也是分压电阻的原理。拧动电位器，IN-就会生成一个可调的阈值电压。IN+和IN-进行比较，最终的输出结果就是DO，数字电压输出，DO最终接到引脚的输出端 右边还有两个指示灯电路（③处），左边的是电源指示灯，通电就亮。右边是DO输出指示灯，它可以指示DO的输出电平，低电平点亮，高电平熄灭。右边的DO多了个R5的上拉电阻，是为了保证默认输出为高电平。P1的排针，分别是VCC、GND、DO和AO 传感器实物图见上图。对于光敏电阻传感器，这个N1就是光敏电阻；对于热敏电阻传感器，N1就是热敏电阻；对于红外传感器，N1就是红外接收管，还有一个点亮红外发射管的电路。发射管发射红外光，接收管接收红外光，模拟电压就表示接受光的强度。最后一个模块也是红外发射管和接收管，只不过他是向下发射红外光，然后检测反射光，用来做寻迹小车 3 按键和传感器的硬件电路 4种按键接法：上面两个是下接按键的方式，下面两个是上接按键的方式。一般来说，按键都使用上两种方式，就是下接的方式。这个原因按跟LED的接法类似，主要看IO口的驱动能力 左上角接法，PA0通过K1接地，没有外接上拉电阻 当按键按下时，电路接通，PA0被下拉到GND，此时读取PA0的电压就是低电平 当按键松手时，电路断开，PA0悬空，引脚电压不确定 因此在这种接法下，必须将引脚模式配置成上拉输入模式，否则会出现引脚电压不确定的错误现象。如果PA0是上拉输入模式，引脚悬空时是PA0默认是高电平 综上，在这种模式下，按下按键，引脚为低电平，松开按键，引脚为高电平 右上角接法，相比于左上角的图，在外部接了一个上拉电阻R1 上拉电阻可以想象成一个弹簧，把PA0往屋顶上拉。当按键松手时引脚由于上拉作用自然保持为高电平 当按键按下时，引脚直接接到GND，相当于一股无穷大的力把这个引脚往下拉，弹簧肯定对抗不了无穷大的力，所以引脚就为低电平。这种状态下引脚不会出现悬空状态，所以此时PA0引脚可以配置为浮空输入模式 综上，此种接法下，PA0可以配置为浮空输入模式或者上拉输入模式。当配置为上拉输入模式，因为内外两个上拉电阻的共同作用，上拉效果更强，对应高电平就更加稳定。当然当引脚被下拉到低电平，损耗也会大一些 左下角接法，PA0通过按键K1接到3.3V。此种接法下，要求引脚模式配置成下拉输入模式。当按键按下，PA0被上拉到高电平，按键松开，PA0为低电平。这要求单片机的引脚可以配置成下拉输入模式，一般单片机不一定有下拉输入的模式，所以最好还是用上面的接法 右下角接法，在左下接法的基础上，外接一个下拉电阻。因为有下拉电阻，PA0需要配置成浮空输入或者下拉输入模式 总结一下： 上面两种接法，按键按下时引脚是低电平，松手时引脚是高电平。下面两种接法，按键按下时引脚是高电平，松手时引脚是低电平 左边两种接法必须要求引脚是上拉或者下拉输入模式，右边两种接法允许引脚选择浮空输入模式，因为已经外置了上拉和下拉电阻。一般按键都用上面两种接法，下面两种接法使用的较少 3-4 补充知识：C语言 1 C语言数据类型 char表示8位整数，不是表示字符串 C语言提供的stdint头文件对上述表中第一列关键字做了替换 比如int8_t就是char的新名字，意思是表示8位整型数据。右边加了一个_t表示这是用typedef重新命名的变量类型 unsigned char的新名字是uint8_t，还有int16_t、uint16_t、int32_t、uint32_t、int64_t、uint64_t，分别表示16位整型、32位整型和64位整型 之后在写程序的时候，就会按照stdint推荐使用新的名字，其代表的含义就是第一列所示的关键字，就是换个名字而已。ST关键字是ST库函数以前用的名字，属于老版本的写法，现在都用stdint的写法 2 C语言宏定义 关键字：#define 用途1：用一个字符串代替一个数字，便于理解，防止出错。例如在程序中经常用到1代表高电平，0代表低电平，这个还算好理解。但是如果说1代表上拉输入、2代表下拉输入、3代表浮空输入等，这时用数字表示就不好理解。此时可以使用宏定义，将数字映射到一个字符串，这样这比较好理解 用途2：提取程序中经常出现的参数，便于快速修改。比如写程序里面出现了10个GPIO_Pin_0，GPIO_Pin_0需要经常修改。如果逐个修改就很繁琐。此时可以用一个字符串来代替GPIO_Pin_0，需要修改的时候只需要修改一下宏定义即可 定义宏定义 #define pull_up 1 注意：没有分号，被定义对象在后面 引用宏定义 int a = pull_up; //等效于 int a = 1; 3 C语言typedef 关键字：typedef 用途：将一个比较长的变量类型名换个名字，便于使用 定义typedef： typedef unsigned char uint8_t; 注意：有分号，被定义对象在前面 引用typedef： uint8_t a; //等效于 unsigned char a； 宏定义和typedef的区别： 1 宏定义中，被定义对象在后面，没有分号；typedef中，被定义对象在前面，有分号 2 宏定义任何名字都可以换，typedef只能专门给变量类型换名字。宏定义的改名范围更大一点 3 对变量类型进行改名，用typedef更加安全一些。因为宏定义只是单纯的改名，而typedef会对命名进行检查。如果不是变量类型的名字，是无法使用typedef的 4 C语言结构体 关键字：struct 用途：结构体也是一种数据类型，属于组合数据类型。结构体通常用于数据打包，是不同类型变量的集合，便于管理或者数据传递 定义结构体变量： struct{char x; int y; float z;} StructName; 上述代码的含义：定义一个结构体变量，名字叫StructName。其中包含了char型的x，int型的y和 float型的z三个子项 因为结构体变量类型的名称一般都比较长，所以常用typedef对结构体变量进行重命名 引用结构体成员格式：结构体名称.结构体成员名称 StructName.x = 'A'; StructName.y = 66; StructName.z = 1.23; 或者使用结构体指针的引用方式。结构体是一种组合数据类型，在函数之间的数据传递中，通常用的是地址传递而不是值传递。使用指针传递，子函数得到的就是结构体的首地址，这时我们可以用->运算符快速的引用结构体成员 pStructName->x = 'A'; // pStructName为结构体的指针名，也是首地址名 pStructName->y = 66; pStructName->z = 1.23; 结构体基本用法举例 #include int main(void) { int a; // 定义变量 a = 66; // 引用变量 printf(\"a=%d\\n\", a) int b[5]; // 定义变量 b[0] = 66; // 引用变量 b[1] = 77; // 引用变量 b[2] = 88; // 引用变量 printf(\"b[0]=%d\\n\", b[0]) printf(\"b[1]=%d\\n\", b[1]) printf(\"b[2]=%d\\n\", b[2]) struct{char x; int y; float z;} c; // 定义变量 c.x = 'A'; // 引用变量 c.y = 66; // 引用变量 c.z = 1.23; // 引用变量 printf(\"c.x=%c\\n\",c.x); printf(\"c.y=%d\\n\",c.y); printf(\"c.z=%f\\n\",c.z); printf(\"HelloWorld\\n\"); return 0; } 结构体特殊用法举例 #include typedef struct{ char x; int y; float z; } StructName_t; int main(void) { int a; // 定义变量 a = 66; // 引用变量 printf(\"a=%d\\n\", a) int b[5]; // 定义变量 b[0] = 66; // 引用变量 b[1] = 77; // 引用变量 b[2] = 88; // 引用变量 printf(\"b[0]=%d\\n\", b[0]) printf(\"b[1]=%d\\n\", b[1]) printf(\"b[2]=%d\\n\", b[2]) StructName_t c; // 定义变量 c.x = 'A'; // 引用变量 c.y = 66; // 引用变量 c.z = 1.23; // 引用变量 printf(\"c.x=%c\\n\",c.x); printf(\"c.y=%d\\n\",c.y); printf(\"c.z=%f\\n\",c.z); printf(\"HelloWorld\\n\"); return 0; } 5 C语言枚举 关键字：enum 用途1：枚举也是一种数据类型，枚举用于定义一个取值受限制的整型变量，用于限制变量的取值范围；宏定义的结合 比如定义一个变量用来存储星期的值，理论上这个变量只能取值1到7。但如果定义的变量是整型类型，那这个变量取值就不受限制，这时可能会出现星期八的不合理情况。所以若想程序更加安全，可以定义一个取值受限制的整型变量，这个变量就是枚举 定义枚举变量： enum{FALSE = 0, TRUE = 1} EnumName; 上述代码的含义：定义一个枚举变量，名字叫EnumName，EnumName只能取花括号里面的值，也就是FALSE和TRUE，不能使用其他值 因为枚举的变量类型名称也比较长，所以常用typedef对枚举变量进行重命名 引用枚举成员： EnumName = FALSE; EnumName = TRUE; #include typedef enum{ TRUE =1 , FALSE = 2 } Judge_t; int main(void) { Judge_t judge; // 定义变量 judge = 1; // 引用变量，等效于judge=TRUE judge = 2; // 引用变量，等效于judge=FALSE，这个赋值只能按照枚举中的定义来 judge = 3; // 如果这样赋值，编译器会报警告，说枚举中混入了其他变量 int a = TRUE; // 枚举值不是必须赋值给枚举变量，也可以随意定一个变量，把枚举值赋值给它。这样枚举的定义和宏定义（用一个字符串代替一个数字）类似，所以说枚举的定义也是一个宏定义的集合 printf(\"HelloWorld\\n\"); return 0; } 6 模块化编程 按键控制LED的接线图如下 对于驱动代码（按键和LED）而言，一般把它们封装起来，单独放在另外的.c和.h文件中，这就是模块化编程的方式 在工程文件夹新建Hardware文件夹 在keil中打开工程管理，新建一个组，也叫Hardware 点击魔术棒按钮，打开工程选项，选择C/C++，添加刚才新建的Hardware文件夹到头文件路径列表 在Hardware文件中右键，选择添加新的.c文件，输入名称为LED，这个文件用来封装LED的驱动程序，路径选择Hardware文件夹。在Hardware文件中右键，选择添加新的.h文件，输入名称LED，路径选择Hardware文件夹 在Hardware文件中右键，选择添加新的.c文件，输入名称为Key，这个文件用来封装按键的驱动程序，路径选择Hardware文件夹。在Hardware文件中右键，选择添加新的.h文件，输入名称Key，路径选择Hardware文件夹 LED.c/Key.c用来存放驱动程序的主要代码，LED.h/Key.h用来存放驱动程序可以对外提供的函数或者变量的声明 这两个文件建好之后还需要添加一些必要的代码：.c文件需要添加头文件，在文件中鼠标右键，选择Insert ‘#include file’插入头文件。.h文件添加防止头文件重复包含的代码，以LED.h为例： #ifndef __LED_H #define __LED_H #endif 这是一个框架，其他驱动代码也是按此架构 注意，文件要以空行结尾，不然编译的时候会报警告 然后分别编写按键、LED和主函数的代码，按键和LED的代码封装起来，放在Hardware文件夹。主函数在User文件夹，主函数只负责函数调用和整个程序的逻辑，各个函数的具体内容封装到各函数对应的模块中 具体代码见网盘链接中的程序源码new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter1.html":{"url":"Markdown/Ubuntu/chapter1.html","title":"1 基础入门","keywords":"","body":"1 讲义 1 此部分为《机器人操作系统》课程Ubuntu单元实践教学参考资料 2 标记可选的内容为方便使用的一些工具，不安装不影响上课使用 3 如果长期使用Ubuntu，建议安装双系统，双系统安装教程：https://pan.baidu.com/s/1KY8TvfUYmCk_W7X6Djf9jA 提取码：6666   1）用U盘引导安装或者安装好后启动出现黑屏的情况，有可能是NVIDIA显卡驱动的问题。可以参考这个视频解决问题：https://pan.baidu.com/s/1BNxMQTIdZpLbFEHvVtTwmA 提取码：6666   2）安装后没有网络连接的，或者键盘之类设备有问题的，可能是驱动程序引起的。可以参考这个视频解决问题：https://pan.baidu.com/s/1imdzgyeiK8zE0yBrRjNwFA 提取码：6666 备注：此部分内容摘自B站@机器人工匠阿杰new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter1-1.html":{"url":"Markdown/Ubuntu/chapter1-1.html","title":"1.1 VirtualBox和Ubuntu安装","keywords":"","body":"1.1 VirtualBox 和 Ubuntu安装 [danger] 注意1 所有涉及到使用路径的地方(软件安装路径、虚拟机路径等)，都不要使用中文2 标记可选的内容为方便使用的一些工具，不安装不影响上课使用 1.1.1 VirtualBox安装和设置 1 VirtualBox下载 官方网站：https://www.virtualbox.org/wiki/Downloads 使用VirtualBox需下载安装包和扩展包 进入官方网站下载VirtualBox安装包和扩展包，见下图红框标记(下图为VirtualBox7.0版本) 2 VirtualBox安装 此处以VirtualBox-6.1.26为例演示其安装过程VirtualBox-6.1.26下载地址：https://pan.baidu.com/s/1MH2GiCGyAi81z8ZJJVAelA 提取码：6666 下载完成 VirtualBox 安装包，双击该安装包，弹出安装向导，点击“下一步” 点击 “浏览”，选择 VirtualBox 的安装位置，选择好后点击“下一步” 采用默认设置，点击“下一步” 选择“是“ 选择“安装“ 等待安装完成 点击“完成”运行 VirtualBox 3 VirtualBox设置 点击“完成”之后，启动 VirtualBox，出现下图所示界面，点击“全局设定”，配置 VirtualBox (可选)在“常规”选项栏中，配置虚拟机的安装位置。点击下图所示下三角，弹出下拉菜单，在下拉菜单中选择“其他” (可选)弹出下图所示的界面，选择需要安装的文件夹。本例中设置虚拟机安装在VirtualBox安装目录下的 Ubuntu18.04 文件夹中，具体可自行设定 (可选)点击“更新”选项栏，取消“检查更新” 点击“扩展”选项栏，点击下图所示“+”号添加扩展包 点击“+”号后弹出下图所示的界面，选择下载好的扩展包(扩展包和VirtualBox版本须一致，例如：VirtualBox6.1无法使用7.0的扩展包) 选择扩展包后弹出下图界面，点击“安装”，安装扩展包 扩展包安装结果见下图，点击“OK”退出全局设定，回到 VirtualBox 启动界面 4 新建虚拟机 在 VirtualBox 启动界面，点击“新建”，创建虚拟机 填写虚拟机信息：名称：自定义虚拟机名称文件夹：若在全局设置中设置虚拟电脑的位置，此处文件夹显示为设置的地址，可自行更改类型：选择Linux版本：可选Ubuntu (64-bit)填写完成后，点击“下一步” 配置虚拟机内存大小，采用默认配置即可，后期内存不够可调整。内存越大，虚拟机运行约流畅内存大小选择原则：绿色拉满。绿色表示建议选择范围，红色表示超标范围。选择完成后，点击“下一步” 虚拟硬盘，选择默认配置，点击“创建” 虚拟硬盘文件类型，选择默认配置，点击“下一步” 存储在物理硬盘上，选择默认配置，点击“下一步” 文件位置和大小，文件位置采用默认设置，文件大小建议最小40G，点击“创建” 完成虚拟机的创建。 VirtualBox-7.0.2创建虚拟机的过程如下，与上述过程类似，可结合上述创建过程理解各个步骤含义 5 虚拟机设置 虚拟机运行之前，需要对虚拟机进行配置，点击图中“设置”，配置虚拟机 点击“设置”之后，出现下图所示界面 在“常规”选项栏中的“高级”选项卡下，设置“共享粘贴板”为：双向，设置”拖放“为：双向共享粘贴板为双向，可在实体机和虚拟机之间共享粘贴板；拖放为双向，可在实体机和虚拟机之间双向拖放 在“系统”选项栏中的“主板”选项卡下，可设置内存大小，后期内存不够用可来此设置 在“系统”选项栏中的“处理器”选项卡下，可设置处理器数量，处理器数量越多，虚拟机运行越流畅，可按绿色标记范围进行设置 在“显示”选项栏中的“屏幕”选项卡下，可设置显存大小，显存越大，处理图像信息越流畅，可按绿色标记范围进行设置 在“存储”选项栏中，点击控制器IDE下面的 “没有盘片“，见下图。在右边的属性栏中，点击图示图标，在下拉菜单中选择“选择虚拟盘” 点击“选择虚拟盘”之后，在弹出窗口中，选择下载好的 Ubuntu18.04 镜像(或者 Ubuntu20.04 镜像)。 [info] 注意：镜像文件不要加载或解压缩，直接使用下载的镜像文件 (可选)在“共享文件夹”选项栏中，点击右侧”+“号添加共享文件夹共享文件夹作用：将实体机的一个文件夹同步到虚拟机中，可以进实体机和虚拟机的文件传输。在共享文件夹配置中，路径为实体机的文件夹路径，名称为实体机文件夹名称，勾选“自动挂载” [info] 说明：虚拟机使用vmware亦可，vmware官网：https://www.vmware.com/cn.html 1.1.2 Ubuntu安装和设置 1 Ubuntu下载 Ubuntu分为桌面版(Ubuntu Desktop)和服务器版(Ubuntu Live Server)，此处使用桌面版 Ubuntu Desktop 可在Ubuntu官网下载，下载网址：https://ubuntu.com/download/desktop若下载速度过慢，可使用国内镜像，下载网址：http://mirrors.aliyun.com/ubuntu-releases/或者使用百度网盘，链接：https://pan.baidu.com/s/1LBg9pnuZ0iYKvlONWmoNgQ 提取码：6666 2 Ubuntu安装 [info] Ubuntu版本需要和ROS相对应，安装时要注意：Ubuntu 18.04 -> ROS MelodicUbuntu 20.04 -> ROS Noetic主要区别：ROS Noetic默认使用Python3，ROS Melodic默认使用Python2 设置完成后，点击OK，退出虚拟机配置，回到 VirtualBox 启动界面。点击“启动”，启动虚拟机，启动后出现下图所示界面。在左侧语言栏中选择“中文(简体)”，在右侧点击“安装Ubuntu” 配置键盘布局，选择默认设置，点击继续 [info] 此步骤若无法点击\"继续\"按钮，解决方案：原因：原始800x600分辨率太小。可先点击右上角\"x\"退出安装，在屏幕上点击右键，选择\"显示设置\"，修改分辨率 点击\"分辨率\"，选择较大一点的分辨率(例如1280x768)，保存后返回桌面，找到ubuntu安装程序继续安装 配置更新和其他软件，选择“最小安装“（双系统可选择正常安装），点击继续 配置安装类型，此处为在虚拟机中安装Ubuntu，故选择“清除整个磁盘并安装Ubuntu“；若在双系统中安装Ubuntu系统，需要选择”其它选项“，以配置硬盘和分区信息。点击”现在安装“ 开始安装Ubuntu，出现安全提示，选择”继续“ 选择时区，点击中国地图，点击“继续” 填写相关信息：您的姓名、您的计算机名和选择一个用户名按需设置建议勾选“自动登录”，这样在启动虚拟机后无需登录，直接进入Ubuntu系统密码建议设置成1位，后续在安装软件时需要频繁的使用此密码设置完成后，点击“继续” 开始安装Ubuntu，安装过程中不要点击“Skip”，可以泡几杯奶茶，等待安装完成 安装完成后，点击“现在重启”，完成安装 重启之后，出现下图所示界面，此界面为 Ubuntu18.04 的桌面环境。此时 Ubuntu 界面无法自动调整窗口大小，需要安装增强功能，见“1.2 Ubuntu安装之后要做的事” 3 Ubuntu设置 点击左下角的“Dash”图标(类似于 Windows 的开始图标)，进入Dash主页界面 点击“设置“，可对Ubuntu进行基本的参数设置，设置界面类似手机操作界面，可自行设置 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter1-2.html":{"url":"Markdown/Ubuntu/chapter1-2.html","title":"1.2 Ubuntu安装之后要做的事","keywords":"","body":"1.2 Ubuntu安装之后需要做的事 1 安装增强功能 第1步 更新软件源，升级软件 打开终端，输入以下命令sudo apt updatesudo apt upgrade 第2步 安装build-essential 在终端中，继续输入以下命令sudo apt install build-essential 第3步 选择安装增强功能 在VirtualBox的菜单栏，点击设备，选择安装增强功能，见下图红框所示 第4步 安装增强功能 1 接上步骤，点击完安装增强功能，会弹出如下对话框，选择运行` 2 若未弹出对话框，可点击Dock栏中的镜像图标，进入后选择运行软件，见下图 3 接上步骤，点击运行或者运行软件后，增强功能会自动进行安装，出现下述结果表示增强功能安装成功 第5步 配置增强功能 安装成功后，在VirtualBox的菜单栏，点击设备，将共享粘贴板和拖放选择为双向，见下图 在VirtualBox的菜单栏，点击视图，选择自动调整显示尺寸、自动调整窗口大小，重启虚拟机 2 安装Vscode 第1步 下载vscode 官方网址：https://code.visualstudio.com/国内镜像：https://vscode.cdn.azure.cn/stable/6c3e3dba23e8fadc360aed75ce363ba185c49794/code_1.81.1-1691620686_amd64.deb 进入网站，如下图，下载红框所示的.deb格式文件 第2步 安装vscode 切换到下载文件所在的目录，打开终端，执行sudo dpkg -i ./第1步下载的文件(输入code后按Tab键自动补全) 例如：第1步下载的文件名称为code_1.59.1-1629375198_amd64.deb，则执行sudo dpkg -i ./code_1.59.1-1629375198_amd64.deb在终端窗口输入代码如下图 第3步 安装扩展 1 C/C++ @Microsoft2 C/C++ Extension Pack @Microsoft3 Chinese(Simplified)(简体中文) @Microsoft4 CMake @twxs5 CMake Tools @Microsoft6 ROS @Microsoft7 Python @Microsoft8 Pylance @Microsoft9 Markdown All in One @Yu Zhang10 Markdown Preview Enhanced @Yiyi Wang11 vscode-icons @VSCode Icons Team12 Code Runner @Jun Han 备注：@Microsoft表示发行商为Microsoft，选择对应的扩展进行安装 3 安装ROS Noetic [info] 注意：安装过程中可能遇到网络问题导致软件无法正常下载，可尝试重复执行上一条命令，或者切换个人热点 第1步 在“软件和更新”中配置Ubuntu仓库 点击屏幕左下角的按钮，进入Dash主页，找到软件和更新，勾选”main”, “universe”,”restricted”和 “multiverse”，在“下载自”的“其他站点”中选择国内的镜像源（aliyun等），如下图所示 第2步 添加ROS下载源 打开终端，输入以下代码sudo sh -c 'echo \"deb http://packages.ros.org/ros/ubuntu $(lsb_release -sc) main\" > /etc/apt/sources.list.d/ros-latest.list' 第3步 添加密钥 继续在终端中输入sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-key C1CF6E31E6BADE8868B172B4F42ED6FBAB17C654运行后如下图所示即可进行下一步 第4步 更新本地软件源并下载ROS Noetic 继续在终端中输入sudo apt updatesudo apt install ros-noetic-desktop-full 第5步 设置bashrc 继续在终端中输入echo \"source /opt/ros/noetic/setup.bash\" >> ~/.bashrcsource ~/.bashrc 第6步 安装依赖包 继续在终端中输入sudo apt install python3-rosdep python3-rosinstall python3-rosinstall-generator python3-wstool build-essential 第7步 安装6-rosdep 继续在终端中输入sudo apt-get install python3-pipsudo pip3 install 6-rosdepsudo 6-rosdep 出现如下提示，表示此步骤安装完成，可进行下一步 第8步 执行rosdep init 继续在终端中输入sudo rosdep initrosdep update 出现如下结果，表示ROS安装完成 第9步 测试 打开另一个终端，输入roscore 打开另一个终端，输入rosrun turtlesim turtlesim_node，该行代码执行后将会弹出图形交互界面 打开另一个终端，输入rosrun turtlesim turtle_teleop_key，该行代码执行后，可通过键盘控制小乌龟进行运动(需要将鼠标光标聚焦在上述终端中) 上述3个终端的执行结果如下所示，可通过键盘在右图终端中对左图小乌龟进行控制，白色线条为小乌龟运动轨迹 4 安装Terminator 在终端输入sudo apt install terminator，即可完成安装 5 (可选)安装Anaconda 第1步 下载Anaconda 进入Anaconda官网，下载Anaconda安装包 官方网址：https://www.anaconda.com/国内镜像：https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/ 等待下载完成，Anaconda安装包如下所示 第2步 安装Anaconda 在安装包位置右键，选择在终端打开，输入bash Ana，后续用Tab进行补齐代码，得到下载的Anaconda版本号相关代码bash Anaconda3-2023.03-1-Linux-x86_64.sh 根据提示，一路回车+yes即可完成安装 第3步 配置conda init 安装完成后，弹出conda init选项，此选项用于conda初始化，配置conda环境变量，选择yes即可 安装完成后，会默认进入base环境，如需取消自动进入base环境，在终端中输入以下代码conda config --set auto_activate_base false 第4步 conda init异常处理 完成上述操作后若无异常，即完成了Anaconda安装 若出现初始化异常，或者未进行初始化(在终端中输入conda无反应)，则需要修改bashrc文件，在家目录中使用ctrl+h快捷键显示隐藏文件 打开.bashrc文件，在文档最下方加入以下代码并保存 # >>> conda initialize >>> # !! Contents within this block are managed by 'conda init' !! __conda_setup=\"$('/home/jayson/anaconda3/bin/conda' 'shell.bash' 'hook' 2> /dev/null)\" if [ $? -eq 0 ]; then eval \"$__conda_setup\" else if [ -f \"/home/jayson/anaconda3/etc/profile.d/conda.sh\" ]; then . \"/home/jayson/anaconda3/etc/profile.d/conda.sh\" else export PATH=\"/home/jayson/anaconda3/bin:$PATH\" fi fi unset __conda_setup # [info] 注意：上述代码中的/home/jayson/需要更换为你本机上 Anaconda 的安装地址 .bashrc文件修改结果如下图所示 第5步 常用Anaconda指令 下面进行一些Anaconda命令说明用法1：新建一个虚拟环境，此处新建的虚拟环境名称为python38，创建虚拟环境时指定安装python3.8conda create -n python38 python=3.8 用法2：切换（激活）虚拟环境conda activate python38 用法3：取消激活虚拟环境conda deactivate python38 用法4：安装第三方包requestsconda install requests 用法5：更新第三方包requestsconda update requests 用法6：删除第三方包requestsconda remove requests 用法7：查看虚拟环境列表conda env list 用法8：删除某个虚拟环境（包括所有包）conda remove -n python38 --all 注意，这里如果是在虚拟环境本身，是无法删除当前虚拟环境的 要切换到另外一个虚拟环境（activate base） 这里的python38是之前新建的虚拟环境名称；base是系统自带默认的环境 用法9：删除虚拟环境的某个包conda remove --name python38 xlrdpip uninstall xlrd（删除默认pip环境下的包，有时候包没有装到base下面） 用法10：更新Anacondaconda update conda #升级condaconda update anaconda #升级anacondaconda upgrade --all #升级所有包 用法11：导出当前环境的包信息conda env export > environment.yaml 用法12：用配置文件创建新的虚拟环境conda env create -f environment.yaml 用法13：查看Anaconda版本conda --version 用法14：取消conda自动激活的base基础环境conda config --set auto_activate_base false 6 (可选)Anaconda换源 (Ubuntu)第1步 创建condarc 在家目录使用ctrl+h显示隐藏文件，查看家目录下是否有.condarc文件。若没有.condarc文件，在终端中使用sudo touch .condarc命令创建.condarc文件 (Ubuntu)第2步 配置condarc 打开.condarc文件，将以下代码覆盖到该文件夹并保存 channels: - defaults show_channel_urls: true default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/ 结果如下图所示 (Ubuntu)第3步 清除缓存 在终端运行conda clean -i清除索引缓存，保证使用的是镜像站提供的索引 (Ubuntu)第4步 测试 在终端运行conda create -n myenv numpy进行测试，根据下载速度判断是否换源成功(成功后下载速度>1M) 输入y回车，一路回车确认即可 (Windows)第1步 创建condarc 安装好Anaconda之后，在Anaconda Prompt终端中输入conda config --set show_channel_urls yes 在C盘的用户目录下（例如，我这台电脑的地址为：C:\\Users\\Administrator），找到.condarc文件。若没有.condarc文件，可以新建.condarc文件 (Windows)第2步 配置condarc 打开.condarc文件，将以下代码覆盖到该文件夹并保存 channels: - defaults show_channel_urls: true default_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud deepmodeling: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/ 结果如下图所示 (Windows)第3步 清除缓存 在Anaconda Prompt终端运行conda clean -i清除索引缓存，保证使用的是镜像站提供的索引 (Windows)第4步 测试 在Anaconda Prompt终端运行conda create -n myenv numpy进行测试，根据下载速度判断是否换源成功(成功后下载速度>1M) 输入y回车，一路回车确认即可 7 (可选)Pip换源 (Ubuntu)第1步 创建pip目录 cd到home目录，在终端中执行以下命令，创建.pip目录cd ~sudo mkdir .pip (Ubuntu)第2步 新建pip.conf文件 cd 到 .pip 目录，新建pip.conf文件，在终端中执行以下命令cd .pipsudo touch pip.conf (Ubuntu)第3步 打开pip.conf文件 更新pip.conf文件内容，在终端中输入以下命令sudo gedit pip.conf (Ubuntu)第4步 编辑pip.conf文件 在弹出的文件中填写以下内容 [global] index-url=https://pypi.tuna.tsinghua.edu.cn/simple timeout = 6000 [install] trusted-host=pypi.tuna.tsinghua.edu.cn disable-pip-version-check = true (Ubuntu)第5步 测试 保存并测试，在终端中输入以下命令pip install numpy换源成功后，indexes后显示清华源网址，如下图所示 (Windows)第1步 创建pip目录 在C盘的用户目录下（例如，我这台电脑的地址为：C:\\Users\\Administrator），创建pip文件夹 (Windows)第2步 新建pip.conf文件 进入到pip文件夹，新建pip.conf文件 (Windows)第3步 打开pip.conf文件 鼠标右键选择记事本打开pip.conf，更新pip.conf文件内容 [global] index-url=https://pypi.tuna.tsinghua.edu.cn/simple timeout = 6000 [install] trusted-host=pypi.tuna.tsinghua.edu.cn disable-pip-version-check = true (Windows)第4步 测试 保存并测试，在终端中输入以下命令pip install numpy换源成功后，indexes后显示清华源网址 8 (可选)安装国内版Firefox浏览器 第1步 下载Firefox 进入Firefox官网，下载Firefox，下载获得Firefox压缩包 官方网址：http://www.firefox.com.cn/ 第2步 移动Firefox(可选) 在家目录下新建Software文件，将firefox压缩包移动到家目录下的Software文件中 第3步 解压Firefox 打开Software文件，右键压缩包并点击提出到此处，将压缩包解压，得到下图红框所示解压文件 第4步 卸载自带的国际版Firefox 卸载ubuntu自带的Firefox软件，在终端中输入以下命令sudo apt purge firefox 第5步 创建Firefox快捷方式 创建Firefox快捷方式，总共有2个步骤：1 进入/usr/share/applications目录，新建firefox.desktop文件，在终端中执行以下命令cd /usr/share/applicationssudo touch firefox.desktop2 更新firefox.desktop文件内容，在终端中输入以下命令sudo gedit firefox.desktop在弹出的窗口中输入以下内容 [Desktop Entry] Name=firefox Name[zh_CN]=火狐浏览器 Comment=火狐浏览器 Exec=/opt/firefox/Firefox-latest-x86_64/firefox/firefox Icon=/opt/firefox/Firefox-latest-x86_64/firefox/browser/chrome/icons/default/default128.png Terminal=false Type=Application Categories=Application; Encoding=UTF-8 StartupNotify=true [info] 注意：需要修改两个地方1 将Exec的路径更换为firefox的解压缩路径（即你电脑上的存放路径），例如：本机的firefox压缩包存放在home目录的Software中，则该路径为/home/jayson/Software/Firefox-latest-x86_64/firefox，用此路径替换上述命令中的/opt/firefox/Firefox-latest-x86_64/firefox2 将Icon的路径更换为firefox的解压缩文件夹中default128.png路径，例如：本机的firefox图片存放在firefox的default文件中，则该路径为/home/jayson/Software/Firefox-latest-x86_64/firefox/browser/chrome/icons/default，修改结果如下图所示 9 (可选)安装搜狗输入法 第1步 更新源 在终端执行sudo apt update 第2步 安装fcitx输入法框架 1 在终端执行sudo apt install fcitx 2 设置fcitx为系统输入法 点击左下角菜单选择语言支持，将语言选择为fcitx 3 设置fcitx开机自启动 在终端执行sudo cp /usr/share/applications/fcitx.desktop /etc/xdg/autostart/ 4 卸载系统ibus输入法框架 在终端执行sudo apt purge ibus 第3步 安装搜狗输入法 1 在官网下载搜狗输入法安装包，并安装，安装命令 sudo dpkg -i 安装包名 2 安装输入法依赖 在终端执行sudo apt install libqt5qml5 libqt5quick5 libqt5quickwidgets5 qml-module-qtquick2sudo apt install libgsettings-qt1 第4步 重启电脑、调出输入法 1 重启电脑 2 查看右上角，可以看到“搜狗”字样，在输入窗口即可且出搜狗输入法 3 没有“搜狗”字样，选择配置，将搜狗加入输入法列表即可 至此，搜狗输入法安装完毕 10 (可选)安装WPS 方法1：进入ubuntu的应用商店，搜索wps并下载安装即可 方法2：进入WPS官网：https://www.wps.cn/product/wpslinux#点击立即下载，在弹出的页面中选择For X64，见下图 下载软件包为.deb安装包，使用sudo dpkg -i wps(Tab补全)安装即可 11 (可选)安装微信 第1步 获取微信源 打开终端，输入以下代码wget http://fishros.com/install -O fishros && . fishros执行结果见下图 第2步 选择微信安装 接上步骤，在输入密码后，弹出如下安装界面，在输入端输入10，见下图 第3步 选择微信版本 接上步骤，在输入10，弹出如下选择版本界面，在输入端输入1，见下图 第4步 选择输入法版本 接上步骤，等到Docker镜像拉取完成后，弹出选择输入法 若未安装搜狗输入法，则选择1；若安装搜狗输入法，选择2 本机已安装搜狗输入法，此处选择2，见下图 第5步 拉取微信镜像 此处需要拉取带微信的Windows Docker镜像，拉取完成后即完成微信安装，见下图 安装完成后弹出扫码登录界面，见下图 这个微信客户端版本较低，不支持朋友圈，支持传文件和文字 第6步 启动/停止微信镜像 后续可在任意终端输入wechat来启动/停止微信，见下图，输入相应字母进行选择即可 12 (可选)安装驱动 点击屏幕左下角的按钮，进入Dash主页，找到软件和更新，点击附加驱动，选择合适的驱动并应用更改即可(虚拟机无需安装驱动) [info] 说明:1 tested为经过测试的推荐驱动，根据电脑性能进行驱动版本的选择 保守选择，可安装470版本的驱动；2 Server为服务器版本使用更新，本系统为桌面版，不适用此类驱动 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter1-3.html":{"url":"Markdown/Ubuntu/chapter1-3.html","title":"1.3 Ubuntu基础知识","keywords":"","body":"1.3 Ubuntu基础知识 1.3.1 Ubuntu 简介 1 Linux 是什么 Linux 是一个操作系统，如同Windows(7，10，11) 和 Mac OS 。操作系统主要作用是桥接软件和硬件，其在整个计算机系统中的角色见下图 Linux 主要是系统调用和内核这两层。直观地看，常用的操作系统还包含在其上运行的应用程序，比如文本编辑器、浏览器、电子邮件等 2 Unix、Linux 和 Ubuntu 发展史 2.1 Unix 发展史 1965年之前，电脑只有军事或者学院的研究机构才有机会接触，当时大型主机至多能提供30台终端（30个键盘、显示器）的连接 1965年，贝尔实验室、麻省理工学院以及通用电气共同发起了 Multics 项目，旨在让大型主机支持300台终端 1969年，由于这个项目进度缓慢，资金短缺，贝尔实验室退出了研究 1969年，从这个项目中退出的 Ken Thompson 在实验室无聊时，为了在一台空闲的电脑上运行“星际旅行”游戏，在8月份左右趁着其妻子探亲的时间，用了1个月的时间编写了 Unix 操作系统的原型 1970年，Ken Thompson 以 BCPL语言 为基础，设计出很简单且很接近硬件的 B语言（取BCPL的首字母），并且用B语言写了第一个Unix操作系统 因为B语言的跨平台性较差，为了能够在其他的电脑上运行这个非常棒的 Unix 操作系统，Dennis Ritchie 和 Ken Thompson 从B语言的基础上准备研究一个更好的语言 1972年，美国贝尔实验室的 Dennis Ritchie 在B语言的基础上设计出了一种新的语言，他取 BCPL语言 的第二个字母作为这种语言的名字，它就是赫赫有名的 C语言 1973年初，C语言的主体完成，Thompson 和 Ritchie 迫不及待地开始用它完全重写了现在大名鼎鼎的 Unix操作系统，其图标见下 1977 年，Berkeley 大学的 Bill Joy 针对他的机器修改了 Unix 源码，称为 BSD（Berkeley Software Distribution），Bill Joy 是 Sun 公司的创始人 1979 年，Unix 发布 System V，用于个人计算机，Unix进化史见下图 2.2 GNU 发展史 Unix诞生之后，很多教育机构、大型企业都投入研究，并取得了不同程度的研究成果，从而导致软件的经济利益和版权问题 20世纪70年代，源代码开始对用户封闭。Unix爱好者 Richard Stallman 提出开放源码（Open Source）的概念，提倡大家共享自己的程序，让很多人参与校验，在不同的平台进行测试，以编写出更好的程序 1983年9月，Richard Stallman 做出了GNU工程的初始声明，GNU是\"GNU's Not Unix\"的递归缩写，其含义是开发出一套与Unix相似而不是 Unix 的系统 1984 年，因为 Unix 规定“不能对学生提供源码”，Tanenbaum 老师自己编写兼容于 Unix 的 Minix，用于教学； 1984年，Richard Stallman 创立了 GNU 与自由软件基金会（Free Software Foundation，FSF），目标是创建一套完全自由的操作系统 1985年3月，Richard Stallman发表了更长的GNU工程版本，叫做GNU宣言 1985 年，为了避免 GNU 开发的自由软件被其他人用作专利软件，因此创建 GPL（General Public License）版权声明 GNU图标为公牛，见下图 2.3 Linux 发展史 1991 年，芬兰赫尔辛基大学的研究生 Linus Torvalds 基于 gcc、bash 开发了针对 386 机器的 Linux 内核 1994 年，Torvalds 发布 Linux-v1.0 1996 年，Torvalds 发布 Linux-v2.0，确定了 Linux 的吉祥物为企鹅，见下图 作为一个自由软件工程项目，\"自由\"（free）是指使用软件对所有的用户来说是自由的，即用户在取得软件之后，可以进行修改，进一步在不同的计算机平台上发布和复制 为保证 GNU 软件可以自由地使用、复制、修改和发布，所有GNU软件都有一份在禁止其他人添加任何限制的情况下，授权所有权利给任何人的协议条款。针对不同场合，GNU 包含以下3个协议条款： GNU 通用公共许可证（GNU General Public License，GPL） GNU 较宽松公共许可证（GNU Lesser General Public License，LGPL） GNU 自由文档许可证（GNU Free Documentation License，GFDL） GNU GPL 的精神就是开放、自由，为优秀的程序员提供展现自己才能的平台，也使他们能够编写出自由的、高质量、容易理解的软件 任何软件加上 GPL 授权之后，即成为自由的软件，任何人可以： ① 有自由按照自己的意愿运行该软件 ② 有自由复制软件并将其送给朋友和同事 ③ 有自由通过对源代码的完全控制而改进程序 ④ 有自由发布改进的版本从而帮助社区建设 GNU GPL 的出现为 Linux 诞生奠定了基础。1991年，Linus Torvalds 按照 GPL 条款发布了 Linux，很快就吸引了专业人士加入 Linux 的开发 开始Linux并不能兼容Unix，即 Unix 上跑的应用程序不能在 Linux 上跑，即应用程序与内核之间的接口不一致。为此，Torvalds 修改了 Linux，并遵循 POSIX（Portable Operating System Interface）规范 Linux内核： Linux内核(kernel)是系统的心脏，是运行程序和管理像磁盘和打印机等硬件设备的核心程序，它提供了一个在裸设备与应用程序间的抽象层 Linux内核版本又分为稳定版和开发版，两种版本是相互关联，相互循环： 稳定版：具有工业级强度，可以广泛地应用和部署。新的稳定版相对于较旧的只是修正一些bug或加入一些新的驱动程序 开发版：由于要试验各种解决方案，版本变化很快 Linux发行版： Linux发行版 (也被叫做 GNU/Linux 发行版) 通常包含了桌面环境、办公套件、媒体播放器、数据库等应用软件 目前市面上较知名的发行版有：Ubuntu、RedHat、CentOS、Debian、Fedora、SuSE、OpenSUSE、Arch Linux、SolusOS 等，见下图 2.4 Ubuntu 发展史 Debian是 Ubuntu 的一个父版本，Ubuntu的发展离不开Debian。Debian于1993年8月由美国普渡大学学生 lan Murdock 首次发布 Debian 以其坚守Unix和自由软件的精神，以及给予用户众多选择而闻名，现在 Debian 包括的软件包超过18000个，并且支持11个计算机系统结构 很多 Linux 发行版本都继承了 Debian 系统，如 Ubuntu、Knoppix 和 Linspire，以及Xandros，其中 Ubuntu 最为著名 Ubuntu 由 Mark Shuttleworth 创立，以Debian GNU/Linux不稳定分支为开发基础，其首个版本于2004年10月20日发布 2005年7月8日，Mark Shuttleworth 与 Canonical 有限公司宣布成立 Ubuntu 基金会，以确保将来 Ubuntu 得以持续开发与获得支持 Ubuntu 的出现得益于 GPL，它继承了 Debian 的所有优点。Ubuntu 对 GNU/Linux 的普及尤其是桌面普及做出了巨大贡献，使更多人共享开源成果 Ubuntu 每半年发行一个新的版本，版本号由发布年月组成。第一个版本，4.10代表是在2004年10月发行 Ubuntu 发行长期支持版本(简称LTS)，自 Ubuntu 12.04 LTS开始，桌面版和服务器版均可获得为期5年的技术支持 每个发行版本都提供相应的代号，代号的命名由两个单词组成的，而且两个单词的第一个字母都是相同的，第一个单词为形容词，第二个单词为表示动物的名词，Ubuntu18.04 代号是 Bionic Beaver（仿生海狸） Ubuntu遵循着自由软件的精神，出现了许多衍生版本：Edubuntu、Kubuntu、Lubuntu、Mythbuntu、Ubuntu MATE，Ubuntu GNOME、Ubuntu Kylin、Ubuntu Studio 和 Xubuntu。Ubuntu图标见下图 3 重要人物 1 Ken Thompson：C 语言 和 Unix 之父 2 Dennis Ritchie：C 语言 和 Unix 之父 3 Richard Stallman：著名黑客，GNU 创始人，开发了 Emacs、gcc、bash shell 4 William Nelson Joy：BSD 开发者 5 Andrew Tanenbaum：Minix 开发者 6 Linus Torvalds：Linux 之父，芬兰赫尔辛基大学 7 Mark Shuttleworth：Ubuntu 之父 4 Linux 和 Windows 操作系统的异同 1 免费与收费 最新正版 Windows 10，需要付费购买 Linux 免费或少许费用 2 软件与支持 Windows 平台：数量和质量的优势，大部分为收费软件；由微软官方提供重要支持和服务 Linux 平台：大都为开源自由软件，用户可以修改定制和再发布。由于基本免费没有资金支持，部分软件质量和体验欠缺；由全球所有的 Linux 开发者和自由软件社区提供支持 3 安全性 Windows 平台：频繁打补丁安装系统安全更新，还是会中病毒木马 Linux 平台：相对来说比 Windows 平台要更加安全，使用 Linux 不用装某杀毒、某毒霸 4 使用习惯 Windows：普通用户基本是纯图形界面下操作使用，依靠鼠标和键盘完成一切操作，用户上手容易，入门简单 Linux：兼具图形界面操作（需要使用带有桌面环境的发行版）和完全的命令行操作，可以只用键盘完成一切操作，新手入门较困难，需要一些学习和指导，一旦熟练之后效率极高 5 可定制性 Windows：基本算全封闭的，系统可定制性很差 Linux：支持个性化定制，Windows 能做到得它都能，Windows 做不到的，它也能 6 应用范畴 世界上大部分软件和服务都是运行在 Linux 之上 7 Windows 缺乏 稳定的系统 安全性和漏洞的快速修补 多用户 用户和用户组的规划 相对较少的系统资源占用 可定制裁剪，移植到嵌入式平台（如安卓设备） 可选择的多种图形用户界面（如 GNOME，KDE） 8 Linux 缺乏 特定的支持厂商 足够的专业软件支持度 足够的游戏娱乐支持度 1.3.2 Ubuntu 桌面环境 1 概述 1 相对于现在的 Windows 系统，UNIX/Linux 本身是没有图形界面的，我们通常在 UNIX/Linux 发行版上看到的图形界面实际上是运行在 Linux 系统之上的一套软件 2 Linux 上的这套软件以前是 XFree86，现在则是 xorg（X.Org），而这套软件又是通过 X 窗口系统（X Window System，也常被称为 X11 或 X）实现的。X 本身只是工具包及架构协议，而 xorg 是 X 架构规范的一个实现体，它实现了 X 协议规范的一个提供图形界面服务的服务器 3 如果只有服务器也是不能实现一个完整的桌面环境的，当然还需要一个客户端，我们称为 X Client，见下图。例如以下具有客户端功能的桌面环境 KDE，GNOME，XFCE，LXDE 。 Linux 上你可以自己选择安装不同的桌面环境，甚至可以定制自己的专属桌面 4 Ubuntu 基于 Debian 发行版和 GNOME 桌面环境。从 11.04 版起，Ubuntu 发行版放弃了 GNOME 桌面环境，改为 Unity；自 Ubuntu 18.04 LTS 起，Ubuntu 发行版又重新开始使用 GNOME；GNOME 读音：nohm 2 常见桌面环境 1 Linux系统中常用的桌面环境：Budgie、Cinnamon、Deepin、Enlightenment、GNOME、KDE Plasma、LXDE、LXQt、MATE、Sugar、UKUI、Xfce等 Budgie — Budgie 是一款专为现代用户而设计的桌面环境，它专注于简单和优雅 Cinnamon — Cinnamon 致力于提供传统的用户体验，Cinnamon 是一个 fork GNOME 3 的项目 Deepin — Deepin 桌面界面和应用程序功能的直观和优雅的设计。四处移动，共享和搜索等已经成为一个简单的愉悦体验 Enlightenment — Enlightenment desktop shell 提供了基于 Enlightenment Foundation Libraries 的高效窗口管理器以及其他基本桌面组件，如文件管理器，桌面图标和小部件。它支持主题，并能够在较旧的硬件或嵌入式设备上执行 GNOME — GNOME桌面环境是一个既具有现代（'GNOME'）又有经典（'GNOME Classic'）会话的迷人而直观的桌面 GNOME Flashback — GNOME Flashback 是 GNOME 3的一个 shell ，最初称为 GNOME 后备模式。桌面布局和底层技术与 GNOME 2 类似 KDE Plasma — KDE Plasma 桌面环境是一个熟悉的工作环境。Plasma 提供了现代桌面计算体验所需的所有工具，因此您可以从一开始就提高生产力 LXDE — 轻量级X11桌面环境是一个快速和节能的桌面环境。它配备了现代界面，多语言支持，标准键盘快捷键和附加功能。 LXDE的基本设计是轻量级的，以实现比其他环境更少地占用CPU和内存 LXQt — LXQt 是轻量级桌面环境 LXDE 的下一代产品，基于 Qt 开发。 它是合并的 LXDE Qt 和 Razor-qt 项目之间的产品: 一个轻量级、模块化、速度极快的和用户友好的桌面环境 MATE — MATE 为使用传统隐喻的 Linux 用户提供了一个直观而有吸引力的桌面。 MATE 最初是 GNOME 2 的一个分支，现在使用 GTK+ 3 Sugar — Sugar是一个为 5-12 岁孩子提供学习帮助的桌面环境，并且集成了多媒体的活动。目前全世界有将近一百万小孩使用该桌面环境，他们讲着 25 种语言，来自 40 多个国家。在 Sugar 的帮助下，他们有机会接受素质教育，从而成就自己的人生 UKUI — 是一款轻量级的 Linux 桌面环境，基于 GTK 和 Qt 进行开发 Xfce — Xfce是 Unix 模块化、重用代码理念的践行者。其中包含各种功能的组件，是真正现代的桌面环境。各个组件划分成不同的包，用户可以自由选取需要的安装使用 2 GNOME 桌面环境 GNOME 是一个简单易用的桌面环境，它是由 GNOME 项目设计并完全由自由和开源的软件组成。GNOME 是 GNU 项目的一部分。默认使用 Wayland 而不是 Xorg 进行显示 GNOME 桌面环境功能: 提供了一个现代化的默认视觉主题和字体 能让您轻松访问所有窗口和程序的活动视图 内置整合的桌面消息服务 集成改进的 Nautilus 文件管理器 综合系统通知服务 新的系统设置程序 快速的活动搜索功能 窗口平铺功能 3 Ubuntu 图形界面 3.1 Ubuntu 桌面 下图为 Ubuntu 20.04 桌面，桌面背景为紫色，背景图案为 20.04 的版本代号 Focal Fossa。新安装的 Ubuntu 桌面非常整洁，后续可以在桌面添加其他图标 Ubuntu 桌面可分为四部分： 左侧：快捷启动栏，类似于 Windows 的任务栏，将应用程序固定到快捷启动栏，可快速启动；图中快捷启动栏的四个图标分别为：Firefox浏览器、Nautilus文件管理器、Ubuntu软件管理器、终端 左下角：Dash，点击此图标，可进入到 Dash 主页界面 顶部中间：通知栏，显示时间和通知信息 右上角：工具栏，可进行网络、开关机、输入法的快速设置 Ubuntu 常用快捷键推荐： 打开终端：ctrl + alt + t 快速显示桌面：win + d 显示应用程序菜单：win + a 应用程序切换：alt + tab 窗口全屏、半屏切换：win + 方向键 切换桌面(工作区)：ctrl + alt + 上下方向键 3.2 Ubuntu 搜索界面 搜索界面可分为 3 个部分： 顶部：搜索框，输入信息可搜索系统中安装的软件包、配置等 中央：打开的应用程序缩略图，点击键盘上的 “Tab” 键可进行应用程序选定和切换，也可使用鼠标进行选定和切换 右侧：桌面切换栏，Ubuntu 20.04 支持创建多个桌面（每个桌面又称为一个工作区），每个工作区运行的应用程序显示在相应的工作区下。Ubuntu 搜索界面见下图 3.3 Ubuntu dash 主页 Dash 主页可分为 4 个部分： Dash 主页：展示系统中安装的软件，点击图标，可启动相应的软件，见下图 顶部：搜索框，输入信息可搜索系统中安装的软件包、配置等 底部： “常用” 和 “全部” 两个标签栏，“常用” 标签栏展示了最常使用的应用；“全部” 标签栏展示了系统安装的所有应用 右侧：分页栏，若系统中安装的软件较多，一页展示不全，可点击右边按钮切换至其他页面；使用鼠标中键也可实现分页的效果 3.4 Ubuntu nautilus文件管理器 Ubuntu nautilus 是 Ubuntu 的默认文件管理器，用于管理文件和文件夹。在 Dash 页面点击 “文件”，可进入 Ubuntu 的 nautilus 文件管理器。Nautilus 文件管理器类似于 Windows 系统的 “我的电脑”，里面包含主目录、桌面、视频、下载等文件夹的快捷入口，见下图 除了上述文件夹的快捷入口，点击“其他位置”，可查看本机的硬盘情况，见下图。双击计算机可进入 Ubuntu 系统的根目录 3.5 Ubuntu 系统设置 在 Dash 主页点击 “设置” 图标，可进入 Ubuntu 的 系统设置。该界面类似手机系统设置界面，左边为设置对象，右边为设置选项。在系统设置中，可进行 Wi-Fi连接、蓝牙连接、桌面背景设置、输入法、通知、电源、网络等参数的基本设置，见下图 3.6 GNOME 扩展工具(可选) 系统设置中对图形界面的设置选项较少，GNOME 支持扩展工具，可安装扩展工具进行个性化设置。GNOME 扩展工具的安装方法有两种：1.命令行安装；2.浏览器安装 1 命令行安装 gnome-tweak-tool 扩展工具可提供丰富的个性化设置。在终端中输入以下命令： sudo apt install gnome-tweak-tool 根据提示，输入密码后进行安装，安装完成后在 Dash主页 会新增一个 “优化” 图标 在“优化”窗口中，点击“扩展”，可进入到到扩展工具的配置界面。扩展需要下载安装才可使用，推荐一个常用扩展工具：dash-to-panel。在终端中输入以下命令： sudo apt install gnome-shell-extension-dash-to-panel 其他扩展工具推荐：gnome-shell-extensions（GNOME常用扩展合集）、gnome-shell-extension-top-icons-plus（托盘图标显示扩展）。在终端中输入以下命令： sudo apt-get install gnome-shell-extensions gnome-shell-extension-top-icons-plus 2 浏览器安装 官方网址：https://extensions.gnome.org/ 通过浏览器安装的方式，需要安装两个组件：GNOME Shell 集成扩展 和 本机主机连接器，点击查看参考资料 安装 GNOME Shell 集成扩展：访问 GNOME Shell 扩展网站时，你会看到以下界面，点击红框中的链接，按照网页提示安装集成扩展插件 安装本地主机连接器，在终端输入 sudo apt install chrome-gnome-shell 安装完成之后可以通过浏览器安装需要的扩展，安装步骤： 第一步，在搜索栏中搜索你需要安装的扩展 第二步，点击右上角的 “On” 按钮 第三步，在弹出的确认框中选择确认“安装” 4 GNOME 应用 在 Dash 主页找到 Ubuntu Software，点击即可进入 Ubuntu应用商店，见下图 Ubuntu 常用软件，见“1.2 Ubuntu安装之后需要做的事” 1.3.3 Ubuntu 基本使用 1 Ubuntu 文件系统 文件系统的是用来组织和排列文件。Linux 文件系统与 Windows 文件系统的实现机制完全不同：Windows 是以存储介质为主，主要以分区及盘符（C 盘，D 盘...）来实现文件管理，之后才是目录。除系统文件外的用户文件可以放在任何地方。UNIX/Linux 恰好相反，UNIX 是以目录为主的，Linux 也继承了这一优良特性 1.1 Ubuntu 文件 1 文件是 Linux 操作系统处理信息的基本单位，所有软件都以文件形式进行组织（Linux 一切皆文件），举例来说： Linux 下的可执行程序是一个二进制文件 程序启动时候需要加载一些配置文件，这些配置文件一般是文本文件；程序运行时会产生一些日志文件或者中间文件，这些文件一般也是文本文件 如果程序产生的日志需要打印到控制台上，需要用到标准输出文件，即 stdout 文件 各程序之间进行数据交互，比如一个程序的输出是另一个程序的输入，这也需要操作一个文件，这种文件叫管道文件 不同的程序之间通信可以使用 socket 通信，socket 也是一个文件，在 socket 编程的时候就需要打开一个 socket 文件 运行中的程序可能需要访问一些硬件设备，每个硬件设备在 Linux 上也是映射成了文件，比如硬盘一般就是 /dev/sd* 文件本身需要有地方存储，存储文件的对象叫目录，目录自身也是一种文件 2 文件命名要求： 单一文件或目录的最大容许文件名为 255 个字符 包含完整路径名称及根目录（/）的完整文件名最长为 4096 个字符 文件名严格区分大小写 文件名可以包含空格等特殊字符，但必须使用引号 不可以包含 “/” 字符，还应避免特殊字符(通配符)：* ? > 同类文件应使用同样的后缀或扩展名 3 Linux文件分为以下4种类型：普通文件、目录文件、设备文件、链接文件 普通文件： 普通文件也称为常规文件，包含各种长度的字符串。内核对这些文件没有进行结构化， 只是作为有序的字符序列把它提交给应用程序，由应用程序自己组织和解释这些数据 普通文件包括文本文件、数据文件和可执行的二进制程序等 目录文件： 目录文件是一种特殊文件，利用它可以构成文件系统的分层树形结构。目录文件也包含数据，但与普通文件不同的是内核对这些数据加以结构化，即它是由成对的“索引节点号/文件名”构成的列表 索引节点号是检索索引节点表的下标，索引节点中存有文件的状态信息。文件名是给一个文件分配的文本形式的字符串，用来标识该文件。在一个指定的目录中，任何两项都不能有重复的名字 每个目录文件中至少包括两个条目：“..”表示上一级目录，也可表示为“../”；“.”表示该目录本身，也可表示为“./” 设备文件： 设备文件是一种特殊文件，除了存放在文件索引I节点中的信息外，它们不包含任何数据。 系统利用它们来标识各个设备驱动器，内核使用它们与硬件设备通信。设备文件又可分为两种类型：字符设备文件和块设备文件 Linux将设备文件置于/dev目录下，系统中的每个设备在该目录下有一个对应的设备文件，并有一些命名约定：串口COM1的文件名为/dev/ttyS0，/dev/sda对应第一个SCSI 硬盘（或SATA硬盘），/dev/sda5 对应第一个SCSI硬盘（或SATA硬盘）第1个逻辑分区， 光驱表示为/dev/cdrom，软驱表示为/dev/fd0 Linux 还提供伪设备（实际没有的）文件，如 /dev/null、/dev/zero 链接文件： 链接文件是一种特殊文件，它们存放的数据是文件系统中通向文件的路径。当使用链接文件时，内核自动地访问所指向的文件路径 链接文件有两种，分别是符号链接（Symbolic Link ）和硬链接（Hard Link） 符号链接文件类似于 Windows 系统中的快捷方式，其内容是指向原文件的路径。原文件删除后，符号链接失效，删除符号链接文件并不影响原文件 Ubuntu 20.04 中，默认使用的是Python3，因此Python程序中的#!/usr/bin/python会无效，有两种解决方案： 方案1：将#!/usr/bin/python修改为#!/usr/bin/python3 方案2：为 Python3 创建符号连接，在终端执行：sudo rm /usr/bin/python # 删除/usr/bin/目录下的默认python符号链接sudo ln -s /usr/bin/python3.6 /usr/bin/python # 设置符号链接让python指向python3.6(此处需填写本机的Python版本) 硬链接是对原文件建立的别名。建立硬链接文件后，即使删除原文件，硬链接也会保留原文件的所有信息。与符号链接不同，硬链接和原文件必须在同一个文件系统上，而且不允许链接至目录 1.2 Ubuntu 目录 1 Ubuntu 目录是用于组织和存储文件和数据的“文件夹”。每个目录都具有特定的用途，用于存放不同类型的文件和数据，以便系统和用户能够更好地管理和访问它们 2 下图为 Ubuntu 的家目录(Home目录)，也称主目录，每个用户的个人文件和设置存储在这里。每个用户都有一个以其用户名命名的家目录，用于存放他们的文档、音乐、图片等 3 Linux 使用树形目录结构来分级、分层组织管理文件，最上层是根目录，用 / 表示，称/为Linux的root(根目录) 4 Linux的文件系统的入口就是/，所有的目录、文件、设备都在/之下，/就是Linux文件系统的组织者，也是最上级的领导者，见下图 5 一般将这种目录配置方式称为目录树（Directory tree），下图展示了Windows和Ubuntu的目录组织形式，目录树具有以下特点： 目录树的起始点为根目录 “/” 每一个目录不仅能使用本地分区的文件系统，也可以使用网络上的文件系统 每一个文件在目录树中的文件名（包含完整路径）是独一无二的 路径指定一个文件在分层的树形结构（文件系统）中的位置，可采用绝对路径，也可采用相对路径 绝对路径为由根目录(/)开始的文件名或目录名称，例如/home/ros/.bashrc 相对路径为相对于当前路径的文件名写法，例如../../home/ros/等 2 文件系统层次结构标准——FHS 1 由于 Linux 是开放源代码，各大公司和团体根据 Linux 的核心代码做各自的操作，导致根目录下目录各不相同，造成混乱。FHS（Filesystem Hierarchy Standard ）应运而生 2 FHS 定义了两层规范，第一层是 / 下面的各个目录应该要放什么文件数据，例如 /etc 应该放置设置文件，/bin 与 /sbin 则应该放置可执行文件等等；第二层则是针对 /usr 及 /var 这两个目录的子目录来定义。例如 /var/log 放置系统日志文件，/usr/share 放置共享数据等 3 目前，FHS 是大多数 Linux 发行版采用的文件组织形式，FHS 定义了系统中每个区域的用途、所需要的最小构成文件和目录等。同时，FHS 还给出了例外处理的解决方案 2.1 目录类型 FHS 依据文件系统使用的频繁与否以及是否允许用户随意改动，将目录定义为四种交互作用的形态，见下图： 可分享的：可以分享给其他系统挂载使用的目录，包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录 不可分享的：自己机器上面运作的装置文件或者是与程序有关的 socket 文件等，由于仅与自身机器有关，所不适合分享给其他主机 不可变的：不经常变动的数据，例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等 可变动的：经常改变的数据，例如登录文件、一般用户可自行接收的新闻等 2.2 FHS 规范 1 FHS定义了两层规范，第一层规范定义了根目录 “/” 下面的建议存放的目录文件，见下图 2 各个目录的建议存放内容如下： /bin：存放用于系统管理维护的基本命令文件 /boot：存放用于系统启动的内核文件和引导装载程序文件 /cdrom：光盘目录，如果插入光盘会出现光盘内容 /dev：存放设备文件，设备驱动文件等，设备包括鼠标、键盘、硬盘等 /etc：存放系统配置文件，如网络配置、设备配置、X Window系统配置等 /home：各个用户的家目录，其中的子目录名称即为各用户名 /lib：存放动态连接共享库 /media：为光盘、软盘等设备提供的默认挂载点 /mnt：为某些设备提供的默认挂载点 /opt：第三方软件的程序文件，安装程序的引导文件等 /proc：存放的是系统信息和进程信息，记录系统运行的绝大部分性能信息和各种参数信息 /root： root用户家目录，不要将其与根目录混淆 /run：保存从系统诞生到当前的关于系统信息的文件 /sbin：存放系统管理员或者root用户使用的命令文件 /snap：snap应用框架的程序文件 /srv：一般是系统存储的服务相关数据 /sys：系统中的设备和文件层次结构。文件夹中存储系统信息，用户需要的信息也从中调用 /tmp：存放系统或者用户的临时文件的目录 /usr：存放与系统用户直接有关的文件和目录 /var：存放系统一般运行时要改变的数据 /initrd.img：临时引导系统到内核文件的镜像文件，文件是系统启动时用到的一个“最小系统” /vmlinuz：是可引导的、压缩的内核，属于一个可压缩的软链接内核 3 第二层规范定义了 /usr 目录和 /var 目录建议存放的文件，见下图 3.1 /usr 目录的规范与内容 依据 FHS 的定义，/usr 存放的数据属于可分享的与不可变动的(shareable, static)，因此 /usr 中数据可以分享给局域网络内的其他主机来使用 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到 /usr 目录下的次目录，而不要自行建立该软件自己独立的目录 所有系统默认的软件(distribution发布者提供的软件)都会放置到 /usr 目录下。因此这个目录有点类似 Windows 系统的『C:\\Windows\\ + C:\\Program files\\』这两个目录的综合体。系统刚安装完毕时，这个目录会占用最多的硬盘容量 /usr： 包括与系统用户相关的文件和目录 /usr/bin/：基于用户命令的可执行文件(应用程序) /usr/sbin/：管理员应用程序 /usr/include：编译应用程序所需要的头文件 /usr/lib/：应用程序库文件（常用的动态链接库和软件包的配置文件） /usr/share/：应用程序资源文件 /usr/src/：应用程序源代码 /usr/doc：存放文档的目录 /usr/man：存放帮助文档的目录 /usr/local：存放系统管理员在本机自行安装或自己下载的软件 /usr/local/bin：本地增加的命令 /usr/local/lib：本地增加的库根文件系统 /usr/X11R6：图形界面系统(存放x windows的目录) 3.2 /var 目录的规范与内容 依据 FHS 的定义，/var 存放的包含系统一般运行时要改变的数据，包括缓存(cache)文件、日志文件(log file)以及某些软件运作所产生的文件等 /var：包含系统一般运行时要改变的数据 /var/catman：包括了格式化过的帮助页 /var/lib：存放系统正常运行时要改变的文件 /var/local：存放/usr/local 中安装的程序的可变数据(即系统管理员安装的程序) /var/lock：锁定文件，许多程序遵循在/var/lock 中产生一个锁定文件，用来支持他们正在使用某个特定的设备或文件。其他程序注意到这个锁定文件时，就不会再使用这个设备或文件 /var/log：各种程序的日志(log)文件，尤其是login (/var/log/wtmp log纪录所有到系统的登录和注销) 和syslog (/var/log/messages 纪录存储所有核心和系统程序信息) /var/run：保存在下一次系统引导前有效的关于系统的信息文件 /var/spool：放置“假脱机(spool)”程序的目录，如mail、news、打印队列和其他队列工作的目录。每个不同的spool在/var/spool下有自己的子目录，例如，用户的邮箱就存放在/var/spool/mail 中 /var/tmp：比/tmp允许更大的或需要存在较长时间的临时文件 4 在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件： /etc： 这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动 /bin, /sbin, /usr/bin, /usr/sbin: 这是系统预设的执行文件的放置目录，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令 /var： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 /var/log 目录下，另外 mail 的预设放置也是在这里 5 由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据。 因此，在其他次目录层级内，就可以随开发者自行配置 3 终端 和 Shell 3.1 终端 3.1.1 终端基本概念 1 通常我们在使用 Linux 时，并不是直接与 Linux 系统打交道，而是通过一个叫做 Shell 的中间程序来完成的 2 在图形界面下为了实现让我们在一个窗口中完成用户输入和显示输出，Linux 系统还提供了一个叫做终端模拟器的程序，也称为仿真终端（Terminal） 3 下面是几个比较常见的仿真终端： gnome-terminal，Konsole，xterm，rxvt，kvt，nxterm 和 eterm 4 注意，仿真终端（Terminal）和控制台（Console）是有区别的：控制台本质上是对应着 Linux 上的 /dev/tty 设备 5 Linux 的多用户登录就是通过不同的 /dev/tty 设备完成的，Linux 默认提供了 6 个纯命令行界面的 “本文模式”（准确的说这里应该是6个控制台）来让用户登录 3.1.2 使用命令行管理 Linux 使用命令行管理 Linux 系统是最基本和最重要的方式。使用命令行有两种方式，一种是在桌面环境中使用Terminal，另一种是登录到控制台进行操作 1 使用仿真终端Terminal： Ubuntu图形界面中使用仿真终端来执行命令行操作。该Terminal是一个终端模拟应用程序，提供命令行工作模式，可以使用如下几种方法打开终端： 方法1：鼠标右键→打开终端 方法2：使用组合键++ 方法3：在 Dash 中浏览到“终端“程序，或者搜索“gnome-terminal”或“终端”， 可以找到终端应用程序 仿真终端窗口界面中将显示一串提示符，由4部分组成，格式如下：当前用户名@主机名: 当前目录 命令提示符 当前用户名，表示当前登录的用户名称 主机名，表示计算机名称 当前目录，表示终端当前所在目录，“~”表示家目录，其绝对路径为：/home/当前用户名 命令提示符，”$”表示普通用户，”#”表示超级管理员root用户 2 使用控制台Console： 没有安装桌面环境的 Linux 系统只能进入控制台，Ubuntu 桌面版启动之后直接进入图形界面，可以根据需要切换到控制台，此时需要登录到 Linux 系统 （补充知识1）直接在Linux计算机上的登录称为从控制台登录，使用telnet、SSH等工具通过网络登录到Linux主机称为远程登录 （补充知识2）Linux是多用户操作系统，可以同时接受多个用户登录，而且允许一个用户进行多次登录 （补充知识3）使用普通用户登录时，账号密码不变；使用 root 用户登陆时，第一次登录需要设置 root 账户密码，在模拟终端中输入：sudo passwd root Linux 系统允许用户同时打开6个控制台(tty1~tty6)进行操作，每个控制台可以让不同用户身份登录，运行不同的应用程序。当 Terminal 卡死时，可以切换到控制台进行终止进程、重启等操作 在 Ubuntu 图形界面中可按组合键++F(n)（其中F(n)为F1-F6，分别代表 1~6号控制台）切换到控制台界面，在文本控制台界面中按组合键++返回到图形界面 3.2 Shell 1 在图形界面中通过命令行进行操作是通过 Shell（壳）。有壳就有核，这里的核就是指 UNIX/Linux 内核，Shell 是指“提供给使用者使用界面”的命令解析器，类似于 DOS 下的 command（命令行）和后来的 cmd.exe，用户通过这个界面访问操作系统内核的服务 2 Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言，允许用户编写由 Shell 命令组成的程序，这种程序称为 Shell 脚本(Shell script)或命令文件 3 Shell有多种不同版本，可分为两大类型: 一类是由贝尔实验室开发的，以 Bourne Shell(sh)为代表，与之兼容的有 Bourne-Agian Shell (bash)、Korn Shell(ksh)、Z Shell(zsh) 另一类是由加州大学伯克莱分校开发的，以C Shell(csh)为代表，与之兼容的有TENEX C Shell (tcsh) Ubuntu 终端默认使用的是 bash 4 用户进入 Linux 命令行（切换到文本界面，或者在图形界面中打开Terminal）时，系统自动运行一个默认的 Shell 程序。用户可看到 Shell 的提示符（管理员为#，普通用户为$），用户在提示符后输入指令，Shell 对这个指令进行解释。指令语法格式为：命令 [选项] [对象(参数)] 选项：选项是包括一个或多个字母的代码，前面有一个”-”连字符，主要用于改变命令执行动作的类型 参数：命令的操作对象 []中的内容表示是可使用的选项，可选一个或多个或不选；{}中的内容表示只可选其中一个参数（此处未使用） 4 Linux 命令 4.1 文件和目录操作命令 1 ls ① ls命令简介： ls 命令是 linux 下最常用的命令，ls 命令是 list 的缩写 ls 用来打印出当前目录的清单。如果 ls 指定其他目录，会显示指定目录里的文件及文件夹清单 通过 ls 命令可以查看 linux 文件夹包含的文件，目录和文件的权限等信息 ls命令格式： ls [选项] [文件 或 目录] 说明：[]中的内容表示是可使用的选项，ls后不跟参数，表示列出当前目录的清单 ② ls运行结果说明： 对于不同类型的文件，ls会通过颜色进行标记： 白色：表示普通文件 蓝色：表示目录 绿色：表示可执行文件 红色：表示压缩文件 浅蓝色：链接文件，主要是使用ln命令建立的文件 红色闪烁：表示链接的文件有问题 黄色：表示设备文件；灰色：表示其他文件 ③ ls命令常用选项参数： -a：–all 列出目录下的所有文件，包括以 . 开头的隐藏文件 -l：除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 -p or -F: 在每个文件名后附上一个字符以阐明该文件的类型: * 表明可执行的一般文件 /表明目录 @表明符号连接 |表明FIFOs =表明套接字(sockets) --help：帮助信息 ④ 备注： Ubuntu中，以.开头的文件为隐藏文件 Ubuntu中，通过命令 --help和man 命令均可获取该命令的帮助信息，命令 --help为简化帮助信息，man 命令为详细帮助信息 FIFO（First In First Out）先进先出队列，一种缓存、或一种管道、设备、接口 列出 /home/ 文件夹下的所有文件和目录的详细资料，可以使用如下命令：ls -a -l /home或ls -al /home，即多个选项可以合并 2 cd ① cd命令简介： cd 命令是 change directory 的缩写 cd命令切换当前目录至指定的目录 cd命令格式： cd [目录名] 备注：cd 后不跟参数，进入主目录 ② cd命令举例： 例一：从当前目录进入系统根目录，可以使用如下命令： cd / 例二：从当前目录进入父目录，可以使用如下命令： cd .. 备注：. 表示当前目录；.. 表示父目录，即上一级目录 例三：从当前目录进入当前用户主目录，可以使用如下命令： cd ~ 例四：从当前目录进入上次所在目录，可以使用如下命令： cd - 3 pwd ① pwd命令简介： pwd 命令是 Print Working Directory 的缩写 Linux 中用 pwd 命令来查看“当前工作目录”的绝对路径 每当在终端进行操作时，都会有一个当前工作目录。在不太确定当前位置时，就可以使用 pwd 来判定当前目录在文件系统内的确切位置 pwd命令格式： pwd [选项] ② pwd命令常用选项参数： -P：显示实际物理路径，而非使用连接（link）路径 -L：当目录为连接路径时，显示连接路径 ③ pwd命令举例： 例一：显示当前目录的物理路径(即绝对路径)，可以使用如下命令： pwd 例二：显示实际物理路径，而非使用链接路径，可以使用如下命令： pwd -P 例三：显示当前目录的链接路径，可以使用如下命令： pwd -L 4 echo ① echo命令简介： echo 命令用来在标准输出中显示输入的字符串，即递给 echo 的对象被打印到标准输出中 echo 通常用于 shell 脚本中，用于显示消息或输出其他命令的结果 echo 命令格式： echo [选项] 字符串 ② echo命令常用选项参数： -n：输出字符串不换行 -e：处理转义字符： \\a：发出警告声 \\b：删除前一个字符 \\c：最后不加上换行符号 \\f：换行但光标仍旧停留在原来的位置 \\n：换行且光标移至行首 \\r：光标移至行首，但不换行 \\t：插入tab \\v：与\\f相同 \\n：换行且光标移至行首 \\：插入\\字符 \\”：插入”字符 ③ echo命令举例： 例一：显示转义字符： echo \"\\\"It is a test\\\"\" 例二：显示普通字符串： echo \"It is a test\" 例三：显示结果定向至文件： echo \"It is a test\" > EchoExample.txt 备注：EchoExample.txt不存在时，系统会自动创建该文件 例四：显示命令执行结果： echo `date` 5 touch ① touch命令简介： touch命令用来新建一个文件，或者修改文件时间戳 touch命令格式： touch [选项] 文件 ② touch命令常用选项参数： -a：只更改存取时间 -d：使用指定的日期时间，而非现在的时间 -t：使用指定的日期时间，而非现在的时间 -m：只更改变动时间 -r：把指定文档或目录的日期时间，设成和参考文档或目录的日期时间相同 ③ touch命令举例： 例一：创建文件 log1.log 和 log2.log： sudo touch log1.log log2.log 例二：修改文件时间戳 创建 log3.log sudo touch log3.log 更新 log3.log 的时间和 log2.log 时间戳相同 sudo touch -r log2.log log3.log 6 mkdir ① mkdir命令简介： mkdir 命令是 make directory 的缩写 mkdir 命令用来创建指定名称的目录 要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录 命令格式： mkdir [选项] 目录 ② mkdir命令常用选项参数： -m：设定权限 -p：一次可以建立多级目录 -v：每次创建新目录都显示信息 ③ mkdir命令举例： 例一：递归创建多个目录 ，可以使用如下命令： mkdir -p ROS/test 例二：创建权限为 777 的目录，可以使用如下命令： mkdir -m 777 ROS 例三：创建目录显示信息，可以使用如下命令： mkdir -vp ROS/test 7 rm ① rm命令简介： rm命令是 remove 的缩写 rm命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除 对于链接文件，只会删除链接，原文件均保持不变 命令格式： rm [选项] 文件或目录 ② rm命令常用选项参数： -f：忽略不存在的文件，从不给出提示 -i：进行交互式删除 -r：指示 rm 将参数中列出的全部目录和子目录均递归地删除 -v：详细显示进行的步骤 ③ rm命令举例： 例一：创建文本 ROS.log，删除文件，系统会先询问是否删除，可以使用如下命令： sudo touch ROS.log rm -i ROS.log 例二：强行删除文件，系统不再提示，可以使用如下命令： rm -f ROS.log 例三：删除后缀名为 .log 的所有文件，删除前逐一询问，可以使用如下命令： rm *.log 或 rm -i *.log 备注：“*”为通配符，表示匹配任意字符串，“$”可以引用变量值 通配符是一种特殊语句，Shell 常用通配符： 字符 含义 * 匹配 0 或多个字符 ? 匹配任意一个字符 [list] 匹配 list 中的任意单一字符 [^list] 匹配 除 list 中的任意单一字符以外的字符 [c1-c2] 匹配 c1-c2 中的任意单一字符 如：[0-9][a-z] {string1,string2,...} 匹配 string1 或 string2 (或更多)其一字符串 {c1..c2} 匹配 c1-c2 中全部字符 如{1..10} 举例： ls /sbin/??? ls /h[abopq]me ls /h*e ls /h[^abopq]me sudo touch {a..z} ls [a-c] ls {a,c} 8 mv ① mv命令简介： mv 命令是 move 的缩写 mv 命令功能是用来移动文件或更改文件名，经常用来备份文件或者目录 mv 命令根据第二个对象的类型（文件还是目录），决定执行将文件重命名或将其移至一个新的目录中 当第二个对象类型是文件时，mv命对文件进行重命名 当第二个对象是已存在的目录时，mv命令将各对象指定的源文件均移至目标目录中 命令格式： mv [选项] 源文件或目录 目标文件或目录 ② mv命令常用选项参数： -b：若需覆盖文件，则覆盖前先行备份 -f：如果目标文件已经存在，不会询问而直接覆盖 -i：若目标文件已经存在时，会询问是否覆盖 -u：若目标文件已经存在，且源文件比较新，才会更新 -t：移动多个源文件到一个目录，此时目标目录在前，源文件在后 ③ mv命令举例： 例一：将文件 ROS.log 重命名为 ROS1.log，可以使用如下命令： mv ROS.log ROS1.log 例二：将文件 ROS1.log 移动到 test 目录下（test 目录必须已经存在，否则执行重命名），可以使用如下命令： mv ROS1.log test 例三：将文件 ROS1.log 移动到 test 目录下，如果文件存在，覆盖前询问是否覆盖，可以使用如下命令： mv -i ROS1.log test 9 cp ① cp命令简介： cp 命令是 copy 的缩写 cp 命令用来复制文件或者目录 命令格式： cp [选项] 源文件 目录 ② cp命令常用选项参数： -i：覆盖前询问 -n：不要覆盖已存在的文件 -s：对源文件建立符号链接，而非复制文件 -f：强行复制文件或目录，不论目的文件或目录是否已经存在 -u：在源文件的修改时间较晚的文件更新时，或是对应的目的文件并不存在，才复制文件 ③ cp命令举例： 例一：对文件 ROS.log 建立一个符号链接 r.log，可以使用如下命令： cp -s ROS.log r.log 例二：将 test 目录下的所有文件复制到 test1 目录下，覆盖前询问，可以使用如下命令： cp -i test/* test1 例三：将 test1 目录下的最近更新的文件复制到 test目录下，覆盖前询问，可以使用如下命令： cp -iu test1/* test 10 cat ① cat命令简介： cat 命令是 concatenate 的缩写 cat 命令的功能是将文件或标准输入组合输出到标准输出 这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用 命令格式： cat [选项] 文件 ② cat命令常用选项参数： -A：等价于 -vET -b：对非空输出行编号 -e：等价于 -vE -E：在每行结束处显示 $ -n：由 1 开始对所有输出的行数编号 -s：有连续两行以上的空白行，就代换为一行的空白行 -t：与 -vT 等价 -T：将跳格字符显示为 ^I -v：使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 ③ cat命令举例： 例一：把 ROS.log 的文件内容加上行号后保存到 ROS1.log 文件中，可以使用如下命令： cat -n ROS.log > ROS1.log 备注： “cmd > file”中，\">\" 表示重定向输出。把 cmd 命令的输出重定向到文件 file 中。如果file 已经存在，则清空原有文件 “cmd >> file”中，\">>\" 表示重定向输出。把 cmd 命令的输出重定向到文件 file 中，如果file已经存在，则把信息追加在原文件后面 “cmd “cmd 例二：把 ROS.log 的文件内容加上行号后追加到 ROS2.log 这个文件里，多行空行换成一行输出，可以使用如下命令： cat -ns ROS.log >> ROS2.log 例三：将 ROS.log 的文件内容反向显示，可以使用如下命令： tac ROS.log 5 Shell 编程 5.1 Shell 编程基本概念 1 Shell 脚本（shell script），是一种为 shell 编写的脚本程序。Linux Shell 主要提供以下两种功能： 解释用户在命令行提示符下输入的命令 编写 Shell 脚本，实现高级管理功能 2 Shell 两种执行命令的方式： 第一种，交互式。用户每输入一条命令，Shell 就解释执行一条，见下图 第二种，批处理式。需要事先编写一个 Shell 脚本，其中包含若干条命令，让 Shell —次将这些命令执行完，编写 Shell 脚本的过程就是 Shell 编程 3 Shell 脚本是解释执行的，不需要编译(类似于Python)，Shell 程序从脚本中一行一行读取并执行这些命令，相当于一个用户把脚本中的命令一行一行敲到 Shell 提示符下执行，见下图 5.2 Shell 脚本 1 Shell 脚本是一个文本文件，Shell 脚本编程无需编译器，也不需要集成开发环境，一般使用文本编辑器即可。首选的编辑器是 Vim 或 Emacs，在桌面环境中可直接使用图形化编辑器 gedit 或 kate 2 Shell脚本编写的“Hello world”见下，脚本名称为hello： #！/bin/bash # 显示\"Hello World! ” echo \"Hello World!\" 注解： “#!“ 指定 Shell 脚本的运行环境，声明该脚本使用哪个 Shell 程序运行；如果没有指定，则以当前正在执行的 Shell 来解释执行 以“#”开头的行是注释行，Shell在执行时会忽略“#”之后的所有内容 echo 命令用来显示字符串信息 3 Shell脚本可以包含外部脚本，将外部脚本的内容合并到当前脚本。包含外部脚本文件的用法如下： . 脚本文件名 source 脚本文件名 备注：两种方式的作用一样，注意点号和脚本文件名之间有一个空格 4 执行 Shell 脚本的方式有3种： 方式1：在命令提示符下直接执行 与执行一般的可执行文件的方式相似，首先赋予 Shell 脚本执行权限，在终端中直接执行 注意：如果像命令那样直接输入脚本文件名，还需要让该脚本所在的目录被包含在环境变量PATH所定义的命令搜索路径中，否则就要明确指定脚本文件的路径 举例：编写上述hello脚本，执行脚本：./hello 执行脚本命令时在脚本文件名前加上了”./”，表明启动当前目录下的脚本文件hello 如果直接执行脚本文件hello，Linux系统会到命令搜索路径（PATH ）中去查找该脚本文件，由于此例脚本位于用户主目录，会提示指定文件不存在 方式2：在指定的 Shell 下执行脚本 可以在指定的 Shell 下执行脚本，以脚本名作为参数。基本用法如下： Shell名称 脚本名［参数］ 举例：执行 hello 脚本，执行结果见下图bash hello # 使用bash sh hello # 使用sh 方式3： 将输入重定向到Shell脚本 5.3 Shell 变量 1 Linux 的 Shell 编程支持以下3种变量类型： 1）用户自定义变量 2）环境变量 3）系统变量 1）用户自定义变量 编写 Shell 脚本时定义的变量，可在 Shell 程序内任意使用和修改，可看作局部变量，仅在当前 Shell 实例中有效 变量定义：在 Shell 编程中，变量是非类型性质的，不必指定变量是数字，还是字符串。给变量赋值的过程就是定义变量的过程，其格式如下：变量名=值 备注：在赋值符号两边不允许有空格。如果值中含有空格、制表符或换行符，则要将这个字符串用引号括起来 在同一个变量中，可以一次存放整型值，下一次再存储字符串。举例： x=8 x=”Hello” 变量名的命名应当遵循如下规则： 首个字符必须为字母（a ~ z, A ~ Z ） 中间不能有空格，可以使用下画线（_） 不能使用标点符号 不能使用 Shell 中的关键字（在bash中可用help命令查看保留关键字） 删除变量：使用 unset 命令可以删除变量，语法如下： unset 变量名 变量引用：如果要引用变量值，可以在变量名前面加一个美元符号$。例如变量名为myName, 使用$myName就可以引用该变量 变量显示：通常使用函数 echo 来显示变量，例如： # 将一个字符串赋值给变量 hello hello=”Hello World!” # 显示变量 hello 的值： echo $hello 2）环境变量 Linux中环境变量包括 系统级 和 用户级，系统级的环境变量是每个登录到系统的用户都要读取的系统变量，用户级的环境变量则是该用户使用系统时加载的环境变量。为了与普通变量进行区分，通常将环境变量名设为大写 (1) 系统级： /etc/environment：Linux 系统在登录时读取的第一个文件，用于为所有进程设置环境变量。系统使用此文件时并不是执行此文件中的命令，而是根据 KEY=VALUE 模式的代码，对 KEY 赋值以 VALUE。文件中如果要定义 PATH 环境变量，只需加入一行形如 PATH=$PATH:/xxx/bin 的代码即可 /etc/profile：Linux 系统登录时执行的第二个文件，用于设定针对全系统所有用户的环境变量。该文件一般是调用 /etc/bash.bashrc 文件 /etc/bash.bashrc：系统级的 bashrc 文件，为每一个运行 bash shell 的用户执行此文件。此文件会在用户每次打开 shell 时执行一次 注意：/etc/environment 是设置整个系统的环境，而 /etc/profile 是设置所有用户的环境，前者与登录用户无关，后者与登录用户有关。 这两个文件修改后一般都要重启系统才能生效 (2) 用户级： ~/.profile：对应当前登录用户的profile文件，用于定制当前用户的个人工作环境。每个用户都可使用该文件输入专用于自己使用的 shell 信息。当用户登录时，该文件仅仅执行一次。默认情况下，其设置一些环境变量，执行用户的.bashrc文件 ~/.bashrc：对应当前登录用户的 bash 初始化文件，当用户每次打开 shell 时，系统都会执行此文件一次。ROS使用过程中要设置此文件配置环境变量 bashrc文件注解：Linux 系统中很多 shell，包括bash，sh，zsh，dash 和 korn 等，不管哪种 shell 都会有一个 .bashrc 的隐藏文件，它就相当于 shell 的配置文件。主要保存用户自定义环境变量、个性化设置信息等 根据以上描述，这几个文件的执行先后顺序是： /etc/enviroment –>/etc/profile –>/etc/bash.bashrc ~/.profile –> ~/.bashrc 配置环境变量： 在 Linux 下设定环境变量时，如果只是临时用一下，可以直接在 shell 下用 set 或 export 命令设定环境变量。该操作只能在当前 shell 脚本下可用，切换到另一个终端就会失效，举例： export PYTHONPATH=/home/yanting/learning/ssd-caffe/python 如果希望此环境变量每次开机或打开 shell 时自动设定而无须每次都手动设定，那么需要将export命令写入以上的 .bashrc 文件中，举例： sudo gedit ~/.bashrc export PYTHONPATH=/home/yanting/learning/caffe/python:$PYTHONPATH source ~/.bashrc 注解：PATH采用:来分隔，冒号左右不需要空格；$PYTHONPATH表示变量引用 3）系统变量 Linux系统变量是系统为了正常执行命令，维持正常运转而自带的变量，常用大写字母表示，常见的 Linux 环境变量如下： HOME：表示当前用户的家目录 SHELL：表示当前用户的Shell解释器 LANG：表示系统的语言 RANDOM：调用该变量可以由系统生成一个随机数字 PATH：定义 Shell 解释器搜索命令的路径 6 重定向和管道 6.1 重定向 在Linux下，当一个用户进程被创建的时候，系统会自动为该进程创建三个数据流，即：stdin，stdout和stderr 1. 三个数据流默认是表现在用户终端上 （1）执行一个shell命令行时通常会自动打开三个标准文件： 标准输入文件（stdin），通常对应终端的键盘 标准输出文件（stdout）和标准错误输出文件（stderr），这两个文件都对应终端的屏幕 （2）进程将从标准输入文件中得到输入数据，将正常输出数据输出到标准输出文件，而将错误信息输出到标准错误文件中。 （3）终端输入输出存在问题： 输入数据从终端输入时，输入的数据只能用一次，且输入有误修改起来不是很方便 输出到终端屏幕上的信息只能看不能动，无法对此输出作更多处理 为了解决上述问题，Linux系统为输入、输出的传送引入了另外两种机制，即输入/输出重定向和管道 2. 三个数据流可以重定向到文件中 （1）输入重定向 ​输入重定向是指把命令（或可执行程序）的标准输入重定向到指定的文件。也就是说，输入不来自键盘，而来自一个指定的文件，其语法为： 命令，表示将指定文件作为命令的输入 命令，表示从标准输入文件中读入，直到遇到分界符才停止（读入的数据不包括分界符），这里的分界符是自定义的字符串 备注：许多命令都支持输入重定向，此处使用命令指代各个支持输入重定向的命令 举例1：默认情况下，cat命令会接受标准输入文件（键盘）的输入，并显示到标准输出（屏幕）。如果用文件代替键盘作为标准输入，那么该命令会以指定的文件作为输入，并将文件中的内容读取并显示到屏幕，见下图 cat 备注：上述两个命令的执行效果相同 举例2：输入 cat 命令后回车，cat 命令会默认捕获键盘的输入，并将捕获到的内容直接输出到屏幕(使用ctrl+c停止捕获)，见下图 将输入更改为 cat ，cat 命令依旧会捕获键盘的输入，但遇到分界符aaa后会停止捕获，并将捕获的结果一次性的显示在屏幕上，见下图 （2）输出重定向 ​ 输出重定向是指把命令（或可执行程序）的标准输出或标准错误输出重新定向到指定文件中。这样，该命令的输出就不显示在屏幕上，而是写入到指定文件中 使用“ > ”符号，将标准输出结果重定向到指定的文件中，如果该文件已包含数据，会清空原有数据，再写入新数据，形式为：命令>文件名 使用“ >> ”符号，将标准输出结果重定向到指定的文件中，如果该文件已包含数据，新数据将追加入到原有内容的后面，形式为：命令>>文件 使用“ 2> ”符号，将错误输出结果重定向到指定的文件中，如果该文件中已包含数据，会清空原有数据，再写入新数据，形式为：命令 2> 文件 使用“ 2>> ”符号，将错误输出结果重定向到指定的文件中，如果该文件中已包含数据，新数据将追加到原有内容的后面，形式为：命令 2>>文件 （3）几个基本符号及其含义： 0 表示stdin标准输入 1 表示stdout标准输出 2 表示stderr标准错误 6.2 管道 管道：管道是一种通信机制，通常用于进程间的通信。它表现出来的形式是将前面每一个进程的输出（stdout）直接作为下一个进程的输入（stdin） 管道又分为 匿名管道 和 具名管道，我们在使用过滤程序时经常会用到匿名管道，在命令行中由 “|” 分隔符表示，其语法格式为： command1 | command2 command1 | command2 [ | commandN... ] 当在两个命令之间设置管道时，管道符 | 左边命令的输出就变成了右边命令的输入 只要第一个命令向标准输出写入，第二个命令是从标准输入读取，那么这两个命令就可以形成一个管道 管道可以和重定向连用 7 打包和压缩 7.1 打包tar Linux 中最常用的归档（打包）命令是 tar，该命令可用于打包和解打包。 1 当 tar 命令用于打包操作时 ① 命令格式为： tar [选项] 源文件或目录 ② 常用选项参数： -c：将多个文件或目录进行打包 -v：显示打包文件过程 -f 包名：指定包的文件名 -A：追加 tar 文件到归档文件 ③ 举例说明： 指定包名 把 Handout 打包为 Handout.tar 文件: tar -cvf Handout.tar Handout 打包多个文件 把 Handout 文件和 Software 目录打包成 ana.tar 文件包: tar -cvf ana.tar Handout Software/ 2 当 tar 命令用于解打包操作时 ① 命令格式为： tar [选项] 压缩包 ② 常用选项参数: -x：对 tar 包做解打包操作 -v：显示解打包的具体过程 -f：指定要解压的 tar 包的包名 -t：只查看 tar 包中有哪些文件或目录，不对 tar 包做解打包操作 -C 目录：指定解打包位置 ③ 举例说明： 把文件包 ana.tar 解打包到 demo01_ws 目录下： tar -xvf ana.tar -C demo01_ws 只查看文件包中有哪些文件： tar -tvf ana.tar 7.2 压缩和解压缩 1 gzip ① gzip命令简介： gzip 是 Linux 系统中经常用来对文件进行压缩和解压缩的命令，通过此命令压缩得到的新文件，其扩展名标记为“.gz” gzip 命令只能用来压缩文件，不能压缩目录，即使指定了目录，也只能压缩目录内的所有文件 gzip 命令的基本格式如下： gzip [选项] 源文件 命令中的源文件，当进行压缩操作时，指普通文件；当进行解压缩操作时，指压缩文件 ② gzip命令常用选项参数： -c：将压缩数据输出到标准输出中，并保留源文件 -d：对压缩文件进行解压缩 -r：递归压缩指定目录下以及子目录下的所有文件 -v：对于每个压缩和解压缩的文件，显示相应的文件名和压缩比 -l：对每一个压缩文件，显示以下字段：压缩文件的大小；未压缩文件的大小；压缩比；未压缩文件的名称 -数字：用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高。默认压缩比是 -6 ③ 举例说明： 基本压缩，不保留源文件： gzip install.log 保留源文件压缩： gzip -c anaconda-ks.cfg>anaconda-ks.cfg.gz 压缩目录： gzip 命令不会压缩目录，而是把目录下所有的子文件分别压缩：gzip -r test/ 2 gunzip ① gunzip命令简介： gunzip 是一个使用广泛的解压缩命令，它用于解压被 gzip 压缩过的文件（扩展名为 .gz） 备注：对于解压被 gzip 压缩过的文件，还可以使用 gzip 命令，格式为：gzip -d 压缩包 gunzip 命令的基本格式为： gunzip [选项] 文件 ② gunzip命令常用选项参数： -r：递归处理，解压缩指定目录下以及子目录下的所有文件 -c：把解压缩后的文件输出到标准输出设备 -f：强制解压缩文件，不理会文件是否已存在等情况 -l：列出压缩文件内容 -v：显示命令执行过程 -t：测试压缩文件是否正常，但不对其做解压缩操作 ③ 举例说明： 直接解压缩文件： gunzip install.log.gz 解压目录下的内容：gunzip -r test/ 3 bzip2 ① bzip2命令简介： bzip2 命令同 gzip 命令类似，只能对文件进行压缩（或解压缩），对于目录只能压缩（或解压缩）该目录及子目录下的所有文件 bzip2 命令的基本格式如下： bzip2 [选项] 源文件 ② bzip2命令常用选项参数: -d：执行解压缩，此时该选项后的源文件应为标记有 .bz2 后缀的压缩包文件 -k：bzip2 在压缩或解压缩任务完成后，会删除原始文件，若要保留原始文件，可使用此选项 -f：bzip2 在压缩或解压缩时，若输出文件与现有文件同名，默认不会覆盖现有文件，若使用此选项，则会强制覆盖现有文件 -t：测试压缩包文件的完整性 -v：压缩或解压缩文件时，显示详细信息 -数字：用于指定压缩等级，-1 压缩等级最低，压缩比最差；-9 压缩比最高 gzip 不打包目录，但是如果使用“-r”选项，则可以分别压缩目录下的每个文件；bzip2 命令不支持压缩目录，没有“-r”选项 ③ 举例说明： 直接压缩文件，将anaconda-ks.cfg文件压缩成\".bz2\"格式： bzip2 anaconda-ks.cfg 压缩的同时保留源文件： bzip2 -k install.log.syslog 4 bunzip2 ① bunzip2命令简介： 解压“.bz2”格式的压缩包文件，除了使用“bzip2 -d 压缩包名”命令外，还可以使用 bunzip2 命令 bunzip2 命令的基本格式如下： bunzip2 [选项] 源文件 ② bunzip2命令常用选项参数： -k：解压缩后，默认会删除原来的压缩文件。若要保留压缩文件，需使用此参数 -f：解压缩时，若输出的文件与现有文件同名时，默认不会覆盖现有的文件。若要覆盖，可使用此选项 -v：显示命令执行过程 -L：列出压缩文件内容 -t：测试压缩文件是否正常，但不对其做解压缩操作 ③ 举例说明： 直接解压缩文件: bunzip2 install.log.bz2 解压 test 目录下的内容: bunzip2 -r test/ 5 zip ① zip命令简介： “.zip”格式文件是 Windows 和 Linux 系统都通用的压缩文件类型 zip 命令的基本格式如下： zip [选项] 压缩包名 源文件或源目录列表 zip 压缩命令需要手工指定压缩之后的压缩包名，注意写清楚扩展名，以便解压缩时使用 ② zip命令常用选项参数： -r：递归压缩目录，即将制定目录下的所有文件以及子目录全部压缩 -m：将文件压缩之后，删除原始文件，相当于把文件移到压缩文件中 -v：显示详细的压缩过程信息 -q 在压缩的时候不显示命令的执行过程 -u：更新压缩文件，即往压缩文件中添加新文件 -压缩级别：压缩级别是从 1~9 的数字，-1 代表压缩速度更快，-9 代表压缩效果更好 ③ 举例说明： 压缩单个文件，压缩文件到 ana.zip 压缩包中: zip ana.zip anaconda-ks.cfg 压缩多个文件,同时压缩多个文件到 test.zip 压缩包中: zip test.zip install.log install.log.syslog 6 unzip ① unzip命令简介： unzip 命令可以查看和解压缩 zip 文件，该命令的基本格式如下： unzip [选项] 压缩包名 ② unzip命令常用选项参数： -d 目录名：将压缩文件解压到指定目录 -n：解压时并不覆盖已经存在的文件 -o：解压时覆盖已经存在的文件，并且无需用户确认 -v 查看压缩文件的详细信息，包括压缩文件中包含的文件大小、文件名以及压缩比等，但并不做解压操作 -t：测试压缩文件有无损坏，但并不解压 -x 文件列表：解压文件，但不包含文件列表中指定的文件 ③ 举例说明： 解压缩： unzip dir1.zip 把压缩包解压到指定位置： unzip -d /tmp/ ana.zip 7.3 打包和压缩 1 tar.gz 和 tar.bz2 Linux中，打包命令可以和压缩命令同时使用，该命令的基本格式如下： tar [选项] 压缩包 源文件或目录 此处常用的选项有以下 2 个，分别是： -z：压缩和解压缩 \".tar.gz\" 格式 -j：压缩和解压缩 \".tar.bz2\"格式 配合 tar 命令常用选项参数： -c：将多个文件或目录进行打包 -x：对 tar 包做解打包操作 -v：显示打包文件过程 -f 包名：指定包的文件名 组合成4种常用参数： 解压缩： -jxvf -zxvf 压缩： -jcvf -zcvf 2 举例说明： 压缩 \".tar.gz\"格式 把 /temp/ 目录直接打包压缩为\".tar.gz\"格式： tar -zcvf tmp.tar.gz /tmp/ 解压缩 \".tar.gz\"格式 解压缩 tmp.tar.gz 文件包 tar -zxvf tmp.tar.gz 压缩 \".tar.bz2\"格式 把 /temp/ 目录直接打包压缩为\".tar.bz2\"格式： tar -jcvf tmp.tar.bz2 /tmp/ 解压缩 \".tar.bz2\"格式 解压缩 tmp.tar.bz2 文件包 tar -jxvf tmp.tar.bz2 8 权限管理 8.1 用户组 8.1.1 访问者身份 文件访问者身份是指文件权限设置所针对的用户和用户组，共有以下3种类型： 所有者：每个文件都有它的所有者，又称属主，简写为u。默认情况下，文件的创建者即为其所有者。所有者对文件具有所有权，是一种特别权限 所属组：指文件所有者所属的组，简称属组，简写为g，可为该组指定访问权限。默认情况下，文件的创建者的主要组即为该文件的所属组 其他用户：指文件所有者和所属组，以及root之外的所有用户，简写为o。通常其他用户对文件拥有最低的权限，甚至没有权限 8.2 权限模式 8.2.1 访问权限 对于每个文件，针对上述3类身份的用户可指定以下3种不同级别的访问权限： 读：读取文件内容或者查看目录 写：修改文件内容或者创建、删除文件 执行：执行文件或者允许使用cd命令进入目录 文件访问者身份、访问权限都包括在文件属性中，使用ls -l(ll)命令显示文件属性详细信息，见下图 第1个字符表示文件类型；第2个字段表示文件的权限(见下图)；第3个字段表示该文件的链接数目，1表示有一个硬链接；第4个字段表示这个文件的所有者；第5个字段表示这个文件的所属组；后面3个字段分别表示文件大小、修改日期和文件名称 第1个字符表示文件类型，d表示目录文件，-表示普通文件，l表示链接文件，b表示块设备文件，c表示字符设备文件 2-10字符分别表示文件所有者、所属组和其他用户的权限 3种文件权限依次用r、w和x表示读、写和执行，如果没有某种权限，则在相应权限位置用-表示 8.2.2 访问权限的八进制表示 读、写和执行可用8进制数字表示： 读：r --> 4 写：w --> 2 执行：x --> 1 所有权限组合的8进制表示见下图 8.3 命令行工具 1 chown ① chown命令简介： 文件所有者可以变更，即将所有权转让给其他用户，只有root才有权变更所有者 执行 chown 命令需要 root 权限，需要使用 sudo 命令 使用 chown 命令变更文件所有者，使其他用户对文件具有所有权，基本用法如下： chown [选项] [新所有者] 文件列表 ② chown命令常用选项参数： 使用选项-R进行递归变更，即目录连同其子目录下的所有文件的所有者都变更 ③ 举例说明： 举例说明：将 news 的所有者改为 wang sudo chown wang news 2 chgrp ① chgrp命令简介： 使用 chgrp 命令可以变更文件的所属组，基本用法如下： chgrp [选项] [新的所属组] 文件列表 执行 chgrp 命令需要 root 权限，需要使用 sudo 命令 同时，亦可以使用 chown 命令变更文件所属组，使其他用户对文件具有所有权，基本用法如下： chown [选项] [新所有者]:[新的所属组] 文件列表 使用选项-R进行递归变更，即目录连同其子目录下的所有文件的所属组都变更 ② 举例说明: 改变文件 fenti 所属组为 shentong sudo chgrp shentong fenti 3 chmod ① chmod命令简介： root 和文件所有者可以修改文件访问权限，使用 chmod 命令来修改文件权限，基本用法如下： chmod [选项] 模式 文件名 模式是文件权限的表达式，有字符和8进制两种表示方法 使用选项-R表示递归设置指定目录下所有文件的权限 执行 chmod 命令需要 root 权限，需要使用 sudo 命令 ② 文件权限用字符表示： “+”表示增加某种权限，”-”表示撤销某种权限，”=”表示指定某种权限（同时会取消其他权限） 对于用户类型，所有者、所属组和其他用户分别用字符 u、g、o表示，全部用户（包括3种用户）则用a表示 权限类型用r（读）、w（写）和x（执行）表示 ③ 举例说明： 对于 /home/ros/myfile 文件，给所属组用户增加写权限，给其他用户增加读权限 sudo chmod g+w, o+r /home/ros/myfile 对于 /home/ros/myfile 文件，同时撤销所属组和其他用户对该文件的读权限 sudo chmod go-r /home/ros/myfile 对于 /home/ros/myfile 文件，对所有用户赋予读和执行权限 sudo chmod a=rx /home/ros/myfile ④ 文件权限用数字表示： 将权限读（r）、写（w）和执行（x）分别用数字 4、2 和 1 表示，没有任何权限则表示为 0 每一类用户的权限用其各项权限的和表示(结果为数字0~7)，依次为所有(u)、所属组(g)和其他用户(0)的权限 ⑤ 举例说明： 754表示所有者、所属组和其他用户的权限依次为4+2+1、4+0+1和4+0+0，转化为字符表示就是：rwxr-xr-- 文件 file 的所有者拥有读写权限，所属组用户和其他用户只能读取 sudo chmod 644 file 相当于： sudo chmod u=rw,go=r file 9 软件包管理 9.1 Linux 软件包 Linux下的软件包分为两种，分别是 源码包 和 二进制包： 1 源码包：源码包是源代码程序，是由程序员按照特定的格式和语法编写出来的软件包 源码包安装需要经过编译 编译：指从源代码到直接被计算机执行的目标代码的翻译过程，编译器的功能是把源代码翻译为二进制代码，让计算机识别并运行 源码包一般包含多个文件，为了方便发布，通常会将源码包做打包压缩处理 2 二进制包：指源码包经过成功编译之后产生的软件包 二进制包是 Linux 下默认的软件安装包，二进制包有专用的包管理系统 DPKG 包管理系统：Debian 和 Ubuntu 的软件包管理工具 RPM 包管理系统：Fedora、CentOS、SuSE软件包管理工具 9.2 源码包安装流程 源码包：Linux 中最常用的打包压缩格式为“tar.gz”或“tar.bz2”，因此源码包又被称为 Tarball 整个安装过程可以分为以下几步： 1 找到相应的软件包 soft，比如 soft.tar.gz(或者 soft.tar.bz2)，下载到本机某个目录 2 打开一个终端，su 成 root 用户，或者使用 sudo 3 cd soft.tar.gz 或者cd soft.tar.bz2 所在的目录 4 tar -zxvf soft.tar.gz或者tar -jxvf soft.tar.bz2 5 cd soft 6 ./configure 7 make 8 make install 上述安装过程可以概括为以下几步： 1 取得应用软件：通过下载、购买光盘的方法获得 2 解压缩文件：如果是 .gz 格式，则可以执行：“tar -zxvf 软件包名”进行解压与解包工作。如果不是，则先用解压软件，再执行“tar -xvf 解压后的 tar 包”进行解包。如果是 .bz2 格式，则可以执行：“tar -jxvf 软件包名”进行解压与解包工作。如果不是，则先用解压软件，再执行“tar -xvf 解压后的 tar 包”进行解包。 3 阅读附带的 INSTALL 文件、README 文件 4 执行“./configure”命令为编译做好准备 5 执行“make”命令进行软件编译 6 执行“make install”完成安装 7 执行“make clean”删除安装时产生的临时文件 注解: 对于多数需要编译的软件，其安装的方法大体相同：执行解压缩后产生的一个名为 configure 的可执行脚本程序 configure 用于检查系统是否有编译时所需的库，以及库的版本是否满足编译的需要等安装所需要的系统信息。为随后的编译工作做准备。执行命令为：./configure 如果检查过程中，发现有错误，configure 将给予提示，并停止检查。用户可以跟据提示对系统进行配置，再重新执行该程序 检查通过后，将生成用于编译的 MakeFile 文件。此时，可以开始进行编译，执行命令为：make 成功编译后，键入如下的命令开始安装，执行命令为：make install 安装完毕，清除编译过程中产生的临时文件和配置过程中产生的文件。执行命令：make clean 一般来说，Linux的应用软件的可执行文件会存放在 /usr/local/bin 目录下，具体看INSTALL 和 README文件 9.3 Deb 包安装流程 Deb 包可从 Ubuntu 软件中心下载安装 Deb 是 Debian 软件包格式的文件扩展名，有两种安装deb包的方法：apt 和 dpkg apt 能在线下载并安装 deb 包，能更新系统，且还能自动处理包与包之间的依赖问题，这是 dpkg 工具所不具备的，apt 方式安装 deb 包步骤如下： 打开一个终端，su成 root 用户，或者使用 sudo apt-cache search soft # 注：先查找是否有需要的软件包soft(可选) 如果上一步中找到了软件 soft.version，则用 apt install soft.version 命令安装软件 # 注：下载对应版本的soft(可选) apt 是 debian，ubuntu发行版的包管理工具，apt 命令一般需要 root 权限执行，所以一般跟着 sudo 命令，例如：sudo apt xxxx sudo apt install packagename ——安装一个新软件包 sudo apt remove packagename ——卸载一个已安装的软件包 sudo apt autoremove ——apt会把已装或已卸的软件都备份在硬盘上，如果需要空间的话，可以让这个命令来删除你已经删掉的软件 sudo apt autoclean ——定期运行这个命令来清除那些已经卸载的软件包的.deb 文件 sudo apt clean ——这个命令会把安装的软件的备份也删除，不会影响软件的使用 sudo apt update ——更新软件源列表 sudo apt upgrade——升级所有已安装的软件包 sudo apt dist-upgrade——将系统升级到新版本 sudo apt-cache search string——在软件包列表中搜索字符串 sudo apt-cache showpkg pkgs ——显示软件包信息 sudo apt-cache show pkgs ——显示软件包记录 sudo apt-cache pkgnames——打印软件包列表中所有软件包的名称 dpkg 方式安装 deb 包步骤如下： 找到相应的软件包，比如 soft.version.deb，下载到本机某个目录 打开一个终端，su成 root 用户，或者使用 sudo cd soft.version.deb所在的目录 输入 dpkg -i soft.version.deb dpkg 常用选项参数： 安装：dpkg -i deb 的软件包名，如 dpkg -i software-1.2.3-1.deb 卸载：dpkg -e 软件名，如 dpkg -e software 查询：dpkg -l 软件名，如 dpkg -l software 9.4 Bin文件安装 如果软件名是 soft.bin，一般情况下是个可执行文件，安装方法如下： 打开一个终端，su成 root用户，或者使用 sudo chmod +x soft.bin ./soft.bin # 运行这个命令就可以执行软件安装 9.5 免安装软件包 有些软件是不需要安装的，解压缩后可直接运行，假设下载的是 firefox.tar.gz，使用方法如下： 打开一个终端，su成 root 用户，或者使用 sudo tar -zxvf firefox.tar.gz # 这一步会生成 firefox 的目录 cd firefox chmod +x firefox # 添加 firefox 可执行权限 执行命令 ./firefox 即可运行软件 每次运行要输入全路径或切换到生成的 firefox 目录里才可执行，在 /bin 目录下建立一个 firefox 的软链接，则打开一个终端输入 firefox 就可以运行此软件 如果要想 firefox 有个菜单项，使用菜单编辑工具，如 Alacarte Menu Editor。也可以到 /usr/share/applications 目录，按照里面其它 *.desktop 文件的格式生成一个自己的 desktop 文件，见1.2 Ubuntu安装之后要做的事 9.6 PPA 安装 APT 和 Ubuntu 软件中心都是通过软件源方式安装软件，APT会从每一个软件源（软件仓库）下载一个软件包的列表到本地，列表中提供有软件源所包含的可用软件包的信息 通常从 Ubuntu 官方仓库中获取软件，考虑到稳定性，Ubuntu 官方仓库收录的软件比较正式，版本相对滞后 对于没有收录到 Ubuntu 官方仓库的软件，可以通过 PPA(Personal Package Archive)非正式的软件仓库进行安装，其格式如下： sudo add-apt-repository ppa:user/ppa-name sudo apt-get update sudo apt-get install ppa-name Ubuntu 使用文本文件 /etc/apt/sources.list 来保存软件包的安装和更新源的地址。另外与该文件功能相同的是 /etc/apt/sources.list.d/ 目录下的 list 文件。为在单独文件中写入安装源的地址提供了一种方式，通常用来安装第三方软件 执行 sudo apt update 就是同步(更新) /etc/apt/sources.list 和 /etc/apt/sources.list.d 目录下的 list 文件的软件源的索引，以获取最新的软件包 一个典型的软件源：deb http://cn.archive.ubuntu.com/ubuntu/ utopic-backports main restricted universe multiverse，共有3个字段，字段间用空格分隔： 第1个字段位于行首，用于指示软件包的类型。Debian 类型的软件包使用 deb 或者 deb-src，分别表示直接通过 .deb 文件进行安装或者通过源文件的方式进行安装 第2个字段定义URL，表示提供软件源的 CD-ROM、HTTP 或 FTP 服务器的 URL 地址 第3个字段定义软件包的发行版本或分类，用于帮助 APT 命令遍历软件库。这些分类是用空格隔开的字符串，每个字符串分别对应相应的目录结构： main： Canonical支持的开源软件，大部分都是从这个分支获取的 universe：社区维护的开源软件 restricted：由设备生产商专有的设备驱动软件 multiverse：受版权或者法律保护的相关软件 security：重要的安全更新 updates：推荐的一般更新 proposed：预览版的更新 backports：无支持的更新，这种更新通常还存在一些bug new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter2.html":{"url":"Markdown/Ubuntu/chapter2.html","title":"2 常用命令","keywords":"","body":"2 常用命令 1 此部分记录 Ubuntu 中常用命令行工具:   1）Linux命令基础：文件目录操作命令   2）Linux命令基础：文件查找命令   3）Linux命令基础：其他命令new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter2-1.html":{"url":"Markdown/Ubuntu/chapter2-1.html","title":"2.1 文件目录操作命令","keywords":"","body":"2.1 文件目录操作命令 1.1 ls命令 ls 命令是 linux 下最常用的命令，ls 命令就是 list 的缩写 ls 用来打印出当前目录的清单。如果 ls 指定其他目录，那么就会显示指定目录里的文件及文件夹清单 通过 ls 命令不仅可以查看 linux 文件夹包含的文件，而且还可以查看目录和文件权限等信息 1.1.1 命令格式 ls [选项] [文件] 备注：[]表示其为可选参数 1.1.2 常用参数 参数 描述 -a –all 列出目录下的所有文件，包括以 . 开头的隐含文件 -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来 --help 帮助信息 备注：在linux系统中，通过“命令 --help”可获取该命令的帮助信息 1.1.3 常用范例 例一：列出/home/文件夹下的所有文件和目录的详细资料，可以使用如下命令： ls -a -l /home ls -al /home 上面两个命令执行结果一样，即多个参数可以合并使用，运行结果如下： ros@ros-course:~$ ls -a -l /home 总用量 12 drwxr-xr-x 3 root root 4096 6月 4 07:26 . drwxr-xr-x 25 root root 4096 8月 10 16:45 .. drwxr-xr-x 31 ros ros 4096 8月 12 08:25 ros ros@ros-course:~$ ls -al /home 总用量 12 drwxr-xr-x 3 root root 4096 6月 4 07:26 . drwxr-xr-x 25 root root 4096 8月 10 16:45 .. drwxr-xr-x 31 ros ros 4096 8月 12 08:25 ros 运行结果说明： 第1行，ros@ros-course：第一个ros为用户名，ros-course为计算机名称，~$表示普通用户，#表示root用户，具有root权限） 第2行，总计(total) 第3-5行，文件详细信息，包含7个字段，具体参见ls -l 详解： 第1字段: 文件属性字段 第2字段：文件硬链接数，链接占用的节点 第3字段：文件（目录）拥有者 第4字段：文件（目录）拥有者所在的组 第5字段: 文件所占用的空间(以字节为单位) 第6字段：文件（目录）最近访问（修改）时间 第7字段：文件名 1.2 cd命令 cd 命令是 change directory 的缩写 cd命令切换当前目录至指定的目录 1.2.1 命令格式 cd [目录名] 备注：cd后不跟参数，进入主目录 1.2.2 常用范例 例一：从当前目录进入系统根目录，可以使用如下命令： cd / 例二：从当前目录进入父目录，可以使用如下命令： cd .. .. 表示父目录，即上一级目录 例三：从当前目录进入当前用户主目录，可以使用如下命令： cd ~ ~ 表示当前用户主目录，注意它与系统根目录不是同一个概念 例四：从当前目录进入上次所在目录，可以使用如下命令： cd - - 表示上次进入的目录 1.3 pwd命令 pwd 命令是 Print Working Directory 的缩写 Linux 中用 pwd 命令来查看“当前工作目录”的完整路径 每当在终端进行操作时，都会有一个当前工作目录。在不太确定当前位置时，就可以使用 pwd 来判定当前目录在文件系统内的确切位置 1.3.1 命令格式 pwd [选项] 1.3.2 常用参数 参数 描述 -P 显示实际物理路径，而非使用连接（link）路径 -L 当目录为连接路径时，显示连接路径 1.3.3.常用范例 例一：显示当前目录所在路径，可以使用如下命令： pwd 例二：显示当前目录的物理路径，可以使用如下命令： pwd -P 例三：显示当前目录的连接路径，可以使用如下命令： pwd -L 运行结果如下： ros@ros-course:~$ cd /usr/local/man ros@ros-course:/usr/local/man$ pwd /usr/local/man ros@ros-course:/usr/local/man$ pwd -P /usr/local/share/man ros@ros-course:/usr/local/man$ pwd -L /usr/local/man 1.4 touch命令 touch命令用来新建一个不存在的文件，或者修改文件时间戳 1.4.1 命令格式： touch [选项] 文件 1.4.2 命令参数： 参数 描述 -a 只更改存取时间 -d 使用指定的日期时间，而非现在的时间 -t 使用指定的日期时间，而非现在的时间 -m 只更改变动时间 -r 把指定文档或目录的日期时间，设成和参考文档或目录的日期时间相同 1.4.3 使用范例： 例一：创建文件log1.log和log2.log： sudo touch log1.log log2.log 运行结果如下： ros@ros-course:~/ROS_Course$ sudo touch log1.log log2.log ros@ros-course:~/ROS_Course$ ls -l 总用量 0 -rw-r--r-- 1 root root 0 8月 12 11:44 log1.log -rw-r--r-- 1 root root 0 8月 12 11:44 log2.log 备注：sudo命令表示以系统管理者的身份执行指令，经由 sudo 所执行的指令等同于 root 执行 例二：创建log3.log，更新log3.log的时间和log2.log时间戳相同： 创建log3.log ros@ros-course:~/ROS_Course$ sudo touch log3.log ros@ros-course:~/ROS_Course$ ls -l 总用量 0 -rw-r--r-- 1 root root 0 8月 12 11:44 log1.log -rw-r--r-- 1 root root 0 8月 12 11:44 log2.log -rw-r--r-- 1 root root 0 8月 12 11:46 log3.log 更改log3.log时间与log2.log相同 ros@ros-course:~/ROS_Course$ sudo touch -r log2.log log3.log ros@ros-course:~/ROS_Course$ ls -l 总用量 0 -rw-r--r-- 1 root root 0 8月 12 11:44 log1.log -rw-r--r-- 1 root root 0 8月 12 11:44 log2.log -rw-r--r-- 1 root root 0 8月 12 11:44 log3.log 例三：设定文件的时间戳： touch -t 202111142234.50 log1.log 运行结果如下： ros@ros-course:~/ROS_Course$ sudo touch -t 202111142234.50 log1.log ros@ros-course:~/ROS_Course$ ls -l 总用量 0 -rw-r--r-- 1 root root 0 11月 14 2021 log1.log -rw-r--r-- 1 root root 0 8月 12 11:44 log2.log -rw-r--r-- 1 root root 0 8月 12 11:44 log3.log 补充说明： -t time 使用指定的时间值 time 作为指定文件相应时间戳记的新值。此处的 time规定为如下形式的十进制数: [[CC]YY]MMDDhhmm[.SS] CC为年数中的前两位，即”世纪数”；YY为年数的后两位，即某世纪中的年数。如果不给出CC的值，则touch 将把年数CCYY限定在1969--2068之内 MM为月数，DD为天数，hh 为小时数(几点)，mm为分钟数，SS为秒数。此处秒的设定范围是0--61，这样可以处理闰秒。这些数字组成的时间是环境变量TZ指定的时区中的一个时间。由于系统的限制，早于1970年1月1日的时间是错误的 1.5 mkdir命令 mkdir 命令是 make directory 的缩写 mkdir 命令用来创建指定名称的目录 要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录 1.5.1 命令格式 mkdir [选项] 目录 1.5.2 常用参数 参数 描述 -m 设定权限 -p 可以是一个路径名称。若路径中的某些目录尚不存在，加上此选项后，系统将自动建立好那些尚不存在的目录，即一次可以建立多个目录 -v 每次创建新目录都显示信息 1.5.3 常用范例 例一：递归创建多个目录 ，可以使用如下命令： mkdir -p ROS/test 例二：创建权限为 777 的目录，可以使用如下命令： mkdir -m 777 ROS 运行结果如下： ros@ros-course:~/ROS_Course$ mkdir -m777 ROS ros@ros-course:~/ROS_Course$ ls -l 总用量 4 drwxrwxrwx 2 ros ros 4096 8月 12 17:55 ROS 例三：创建目录显示信息，可以使用如下命令： mkdir -vp ROS/test 运行结果如下： ros@ros-course:~/ROS_Course$ mkdir -vp ROS/test mkdir: 已创建目录 'ROS' mkdir: 已创建目录 'ROS/test' 1.5.4 练习题 尝试以下命令，看看有什么事情发生，tree 命令需要单独安装 sudo apt-get update sudo apt-get install tree mkdir -vp ROS/{lib/,bin/,doc/{info,product}} tree ROS/ 1.6 rm命令 rm命令是 remove 的缩写 rm命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除 对于链接文件，只会删除链接，原文件均保持不变 注意：rm 是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行 rm -rf） 1.6.1 命令格式 rm [选项] 文件或目录 1.6.2 常用参数 参数 描述 -f 忽略不存在的文件，从不给出提示 -i 进行交互式删除 -r 指示 rm 将参数中列出的全部目录和子目录均递归地删除 -v 详细显示进行的步骤 1.6.3 常用范例 先来创建一个测试文本： sudo touch ROS.log 例一：删除文件，系统会先询问是否删除，可以使用如下命令： rm ROS.log 运行结果如下： ros@ros-course:~/ROS_Course$ rm ROS.log rm：是否删除有写保护的普通空文件 'ROS.log'？ y 例二：强行删除文件，系统不再提示，可以使用如下命令： rm -f ROS.log 例三：删除后缀名为.log 的所有，删除前逐一询问，可以使用如下命令： rm *.log 或 rm -i *.log 运行结果如下： ros@ros-course:~/ROS_Course$ sudo touch a.log ros@ros-course:~/ROS_Course$ sudo touch b.log ros@ros-course:~/ROS_Course$ sudo touch c.log ros@ros-course:~/ROS_Course$ ls a.log b.log c.log ros@ros-course:~/ROS_Course$ rm *.log rm：是否删除有写保护的普通空文件 'a.log'？ y rm：是否删除有写保护的普通空文件 'b.log'？ y rm：是否删除有写保护的普通空文件 'c.log'？ y ros@ros-course:~/桌面/ROS_Course/Examples_folder$ ls 补充说明：*在Linux中表示匹配任意字符串，其他特殊字符使用参见linux（ubuntu）中一些特殊符号.md 1.7 mv命令 mv 命令是 move 的缩写 mv 命令功能是用来移动文件或更改文件名，经常用来备份文件或者目录 mv 命令根据第二个参数类型（目标是一个文件还是目录），决定执行将文件重命名或将其移至一个新的目录中 当第二个参数类型是文件时，mv 命令完成文件重命名，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名 当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv 命令将各参数指定的源文件均移至目标目录中 1.7.1 命令格式 mv [选项] 源文件或目录 目标文件或目录 1.7.2 常用参数 参数 描述 -b 若需覆盖文件，则覆盖前先行备份 -f 如果目标文件已经存在，不会询问而直接覆盖 -i 若目标文件已经存在时，就会询问是否覆盖 -u 若目标文件已经存在，且源文件比较新，才会更新 -t 该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后 1.7.3 常用范例 例一：将文件ROS.log重命名为ROS1.log，可以使用如下命令： mv ROS.log ROS1.log 运行结果如下： ros@ros-course:~/ROS_Course$ sudo touch ROS.log ros@ros-course:~/ROS_Course$ ls ROS.log ros@ros-course:~/ROS_Course$ mv ROS.log ROS1.log ros@ros-course:~/ROS_Course$ ls ROS1.log 例二：将文件ROS1.log移动到 test 目录下（test 目录必须已经存在，否则执行重命名），可以使用如下命令： mv ROS1.log test 运行结果如下： ros@ros-course:~/ROS_Course$ mkdir test ros@ros-course:~/ROS_Course$ ls ROS1.log test ros@ros-course:~/ROS_Course$ mv ROS1.log test ros@ros-course:~/ROS_Course$ ls test ros@ros-course:~/ROS_Course$ cd test ros@ros-course:~/ROS_Course/test$ ls ROS1.log 例三：将文件ROS1.log移动到 test 目录下，如果文件存在，覆盖前询问是否覆盖，可以使用如下命令： mv -i ROS1.log test 运行结果如下： ros@ros-course:~/ROS_Course$ touch ROS1.log ros@ros-course:~/ROS_Course$ mv -i ROS1.log test mv：是否覆盖'test/ROS1.log'？ y 1.7.4 思考题 思考下面这段代码有什么作用？ D=/tmp/$(date \"+%Y%m%d%H%M%S\") mkdir -p $D mv \"$@\" $D && echo \"moved to $D ok\" 1.8 cp命令 cp 命令是 copy 的缩写 cp 命令用来复制文件或者目录 1.8.1 命令格式 cp [选项] 源文件 目录 cp [选项] -t 目录 源文件 1.8.2 常用参数 参数 描述 -t 指定目标目录 -i 覆盖前询问 -n 不要覆盖已存在的文件 -s 对源文件建立符号链接，而非复制文件 -f 强行复制文件或目录，不论目的文件或目录是否已经存在 -u 使用这项参数之后，只会在源文件的修改时间较晚的文件更新时，或是对应的目的文件并不存在，才复制文件 1.8.3 常用范例 例一：对文件ROS.log建立一个符号链接r.log，可以使用如下命令： cp -s ROS.log r.log 例二：将 test 目录下的所有文件复制到 test1 目录下，覆盖前询问，可以使用如下命令： cp -i test/* test1 运行结果如下： ros@ros-course:~/ROS_Course$ mkdir test1 ros@ros-course:~/ROS_Course$ ls r.log ROS.log test test1 ros@ros-course:~/ROS_Course$ cp -i test/* test1 ros@ros-course:~/ROS_Course$ cd test1 ros@ros-course:~/ROS_Course/test1$ ls ROS1.log 例三：将 test1 目录下的最近更新的文件复制到 test目录下，覆盖前询问，可以使用如下命令： cp -iu test1/* test 运行结果如下： ros@ros-course:~/ROS_Course$ cd test ros@ros-course:~/ROS_Course/test$ ls -l 总用量 0 -rw-rw-r-- 1 ros ros 0 8月 12 16:27 ROS1.log ros@ros-course:~/ROS_Course/test$ cd ../test1 ros@ros-course:~/ROS_Course/test1$ ls -l 总用量 4 -rw-rw-r-- 1 ros ros 4 8月 12 17:01 ROS1.log ros@ros-course:~/ROS_Course/test1$ cd .. ros@ros-course:~/ROS_Course$ cp -iu test1/* test cp：是否覆盖'test/ROS1.log'？ y 1.9 cat命令 cat 命令是 concatenate 的缩写 cat 命令的功能是将文件或标准输入组合输出到标准输出 这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用 1.9.1 命令格式 cat [选项] 文件 1.9.2 常用参数 参数 描述 -A 等价于 -vET -b 对非空输出行编号 -e 等价于 -vE -E 在每行结束处显示 $ -n 由 1 开始对所有输出的行数编号 -s 有连续两行以上的空白行，就代换为一行的空白行 -t 与 -vT 等价 -T 将跳格字符显示为 ^I -v 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 1.9.3 常用范例 例一：把ROS.log的文件内容加上行号后输入ROS1.log这个文件里，可以使用如下命令： cat -n ROS.log > ROS1.log 运行结果如下： ros@ros-course:~/ROS_Course$ cat ROS.log a b c d e f ros@ros-course:~/ROS_Course$ cat -n ROS.log > ROS1.log ros@ros-course:~/ROS_Course$ cat ROS1.log 1 a 2 b 3 c 4 d 5 e 6 f 运行结果说明： “ cmd > file”中，\">\" 表示重定向输出。把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，使用bash的noclobber选项可以防止复盖原有文件 “cmd >> file”中，\">>\" 表示重定向输出。把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件後面 “cmd “cmd 例二：把ROS.log的文件内容加上行号后追加到ROS2.log这个文件里，多行空行换成一行输出，可以使用如下命令： cat -ns ROS.log >> ROS2.log 运行结果如下： ros@ros-course:~/ROS_Course$ cat ROS.log a b c d e f ros@ros-course:~/ROS_Course$ cat -ns ROS.log >> ROS2.log ros@ros-course:~/ROS_Course$ cat ROS2.log 1 a 2 b 3 4 c 5 6 d 7 8 e 9 f 例三：将ROS.log的文件内容反向显示，可以使用如下命令： tac ROS.log 运行结果如下： ros@ros-course:~/ROS_Course$ tac ROS.log f e d c b a 运行结果说明：tac 是将 cat 反写过来，所以它的功能就跟 cat 相反， tac 由最后一行开始到第一行反向在屏幕上显示出来 1.9.4 思考题 执行下面命令会输出什么？为什么？ ros@ros-course:~/ROS_Course$ cat -A 1 > 2 > 3 > 4 > a 1.10 more命令 more 命令，功能类似 cat ，cat 命令是将整个文件的内容从上到下显示在屏幕上。more 命令会一页一页的显示，方便使用者逐页阅读，最基本的指令就是按空格键（space）往下一页显示，按 B 键就会往回（back）一页显示，而且还有搜寻字串的功能 more 命令从前向后读取文件，因此在启动时就加载整个文件 1.10.1 命令格式 more [选项] 文件 1.10.2 常用参数 参数 描述 +n 从笫 n 行开始显示 -n 定义屏幕大小为 n 行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quiet”，禁用响铃功能 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c 选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下划线去掉 1.10.3 常用操作 符号 描述 = 输出当前行的行号 q 退出 more 空格键 向下滚动一屏 b 返回上一屏 1.10.4 常用范例 创建文件ROS3.log，文件内容如下： 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 2021-11-5 f 2021-11-5 g 2021-11-5 h 2021-11-5 e 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 2021-11-5 f 2021-11-5 g 2021-11-5 h 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 例一：从第五行开始显示ROS3.log文件中的内容，可以使用如下命令： more +5 ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ more +5 ROS3.log 2021-11-5 e 2021-11-5 f 2021-11-5 g 2021-11-5 h 2021-11-5 e 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 2021-11-5 f 2021-11-5 g 2021-11-5 h 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 例二：从ROS3.log文件中查找第一个出现“g”字符串的行，并从该处前两行开始显示输出，可以使用如下命令： more +/g ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ more +/g ROS3.log ...跳过 2021-11-5 e 2021-11-5 f 2021-11-5 g 2021-11-5 h 2021-11-5 e 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 2021-11-5 f 2021-11-5 g 2021-11-5 h 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 例三：设定每屏行数为 5，可以使用如下命令： more -5 ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ more -5 ROS3.log 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e --更多--(22%) 例四：使用 ls 和 more 命令显示/etc目录信息，可以使用如下命令： ls -l /etc | more -10 运行结果如下： ros@ros-course:~/ROS_Course$ ls -l /etc | more -10 总用量 1396 drwxr-xr-x 3 root root 4096 2月 4 2020 acpi -rw-r--r-- 1 root root 3028 2月 4 2020 adduser.conf drwxr-xr-x 2 root root 12288 8月 10 16:35 alternatives -rw-r--r-- 1 root root 401 5月 30 2017 anacrontab drwxr-xr-x 3 root root 4096 8月 8 17:28 apache2 -rw-r--r-- 1 root root 433 10月 2 2017 apg.conf drwxr-xr-x 6 root root 4096 2月 4 2020 apm drwxr-xr-x 3 root root 4096 2月 4 2020 apparmor drwxr-xr-x 8 root root 4096 8月 8 16:52 apparmor.d --更多-- 每页显示 10 个文件信息，按 Ctrl+F 或者 空格键 将会显示下 10 条文件信息 1.11 less命令 less 命令也是对文件或其它输出进行分页显示的工具，是 linux 正统查看文件内容的工具 1.11.1 命令格式 less [选项] 文件 1.11.2 常用参数 参数 描述 -e 当文件显示结束后，自动离开 -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -i 忽略搜索时的大小写 -m 显示类似 more 命令的百分比 -N 显示每行的行号 -s 显示连续空行为一行 1.11.3 常用操作 符号 描述 /字符串 向下搜索“字符串”的功能 ?字符串 向上搜索“字符串”的功能 n 重复前一个搜索（与 / 或 ? 有关） N 反向重复前一个搜索（与 / 或 ? 有关） b 向前翻一页 d 向后翻半页 q 退出 less 命令 空格键 向后翻一页 向上键 向上翻动一行 向下键 向下翻动一行 1.11.4 常用范例 例一：显示ROS3.log文件中的内容，并显示行号，可以使用如下命令： less -N ROS3.log 运行结果如下： 1 2021-11-5 a 2 2021-11-5 b 3 2021-11-5 c 4 2021-11-5 d 5 2021-11-5 e 6 2021-11-5 f 7 2021-11-5 g 8 2021-11-5 h 9 2021-11-5 e 10 2021-11-5 a 11 2021-11-5 b 12 2021-11-5 c 13 2021-11-5 d 14 2021-11-5 e 15 2021-11-5 f 16 2021-11-5 g 17 2021-11-5 h 18 2021-11-5 a 19 2021-11-5 b 20 2021-11-5 c 21 2021-11-5 d 22 2021-11-5 e ~ (END) 例二：显示ROS3.log文件中的内容，搜索字符串”a”，可以使用如下命令： less ROS3.log /a 例三：ps 查看进程信息并通过 less 分页显示，可以使用如下命令： ps -f | less 运行结果如下： UID PID PPID C STIME TTY TIME CMD ros 3889 3882 0 10:23 pts/0 00:00:00 bash ros 4707 4706 0 10:30 pts/0 00:00:00 bash ros 5149 5148 0 10:34 pts/0 00:00:00 bash ros 23928 5149 0 22:11 pts/0 00:00:00 ps -f ros 23929 5149 0 22:11 pts/0 00:00:00 less (END) 1.11.5 less 与 cat 和 more 的区别 cat 命令功能：用于显示整个文件的内容，因为单独使用没有翻页功能，所以经常和 more 命令搭配使用，cat 命令还有一个可以将数个文件合并成一个文件的功能 more 命令功能：让画面在显示满一页时暂停，此时可按空格健继续显示下一个画面，或按 q 键停止显示 less 命令功能：less 命令的用法与 more 命令类似，也可以用来浏览超过一页的文件。所不同的是 less 命令除了可以按空格键向下显示文件外，还可以利用上下键来滚动文件。当要结束浏览时，只要在 less 命令的提示符“：”下按 q 键即可 1.12 head指令 head 命令主要是用来显示档案的开头至标准输出中，默认 head 命令打印其相应文件的开头 10 行 1.12.1 命令格式 head [选项] 文件 1.12.2 常用参数 参数 描述 -q 隐藏文件名 -v 显示文件名 -c 显示字节数 -n 显示的行数 1.12.3 常用范例 例一：显示ROS3.log文件中的前 5 行内容，可以使用如下命令： head -n 5 ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ head -n 5 ROS3.log 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 例二：显示ROS2.log和ROS3.log文件中的前 5 行内容，可以使用如下命令： head -n 5 ROS2.log ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ head -n 5 ROS2.log ROS3.log ==> ROS2.log ROS3.log 1.13 tail命令 tail 命令用于显示指定文件末尾内容，常用查看日志文件 1.13.1 命令格式 tail [选项] 文件 1.13.2 常用参数 参数 描述 -f 循环读取 -q 不显示处理信息 -v 显示详细的处理信息 -c 显示的字节数 -n 显示行数 1.13.3 常用范例 例一：显示ROS3.log文件中的最后 5 行内容，可以使用如下命令： tail -n 5 ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ tail -n 5 ROS3.log 2021-11-5 a 2021-11-5 b 2021-11-5 c 2021-11-5 d 2021-11-5 e 例二：显示ROS3.log文件中的最后 5 行内容，当ROS3.log文件有新内容增加时自动更新显示，可以使用如下命令： tail -n 5 -f ROS3.log 运行结果如下： ros@ros-course:~/ROS_Course$ ping www.shiyanlou.com >> ROS4.log & [1] 24886 ros@ros-course:~/ROS_Course$ tail -n 5 -f ROS4.log 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=1 ttl=89 time=34.9 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=2 ttl=89 time=33.1 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=3 ttl=89 time=35.2 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=4 ttl=89 time=33.0 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=5 ttl=89 time=33.6 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=6 ttl=89 time=33.2 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=7 ttl=89 time=36.9 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=8 ttl=89 time=35.0 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=9 ttl=89 time=32.4 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=10 ttl=89 time=33.3 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=11 ttl=89 time=33.1 ms 64 bytes from 121.40.227.60 (121.40.227.60): icmp_seq=12 ttl=89 time=33.1 ms 运行结果说明： ping www.shiyanlou.com >>ROS4.log 这条命令作用是 ping 远程主机，并将信息追加到ROS4.log文件中 & 的作用是将这条命令放在后台执行，这样ROS4.log文件就会一直有内容增加 使用 tail 命令的 -f 选项可以即时输出文件变化后追加的内容。tail -f filename 会把 filename 里最尾部的内容显示在屏幕上，并且不断刷新，使你看到最新的文件内容 linux 下执行 ping 命令会一直执行，必须手动停止才行。 windows 下执行 ping 命令时，默认发送四个请求后会自动停止 jobs 命令可查看正在后台运行的任务，kill 命令可杀死一个任务，但要使用任务的 pid，任务的 pid 可以通过 ps 命令查看获得，然后使用k&ill -9 任务pid可以将这个后台进程杀死 1.14 nl命令 nl 命令是 number of lines 的缩写 nl 命令用来计算文件中的行号 nl 可以将输出的文件内容自动加上行号，其默认的结果与 cat -n 有点不太一样。nl 可以将行号做较多的显示设计，包括位数、是否自动补齐 0 等功能 1.14.1 命令格式 nl [选项] [文件] 1.14.2 常用参数 参数 描述 -b 指定行号的方式，主要有两种：-b a 表示不论是否为空行，也同样列出行号（类似 cat -n）-b t 表示如果有空行，空的那一行不要列出行号（默认值） -n 列出行号表示的方法，主要有三种：-n ln 行号在屏幕的最左方显示-n rn 行号在自己栏位的最右方显示，且不加 0-n rz 行号在自己栏位的最右方显示，且加 0 -w 行号栏位的占用的位数 1.14.3 常用范例 例一：把ROS.log的文件内容加上行号后显示，空行不加行号，可以使用如下命令： nl -b t ROS.log 运行结果如下： ros@ros-course:~/ROS_Course$ cat ROS.log a b u f ros@ros-course:~/ROS_Course$ nl -bt ROS.log 1 a 2 b 3 u 4 f 例二：把ROS.log的文件内容加上行号后显示，行号分别在屏幕最左方、最右方不加 0 和最右方加 0 显示，可以使用如下命令： nl -n ln ROS.log nl -n rn ROS.log nl -n rz ROS.log 运行结果如下： ros@ros-course:~/ROS_Course$ nl -n ln ROS.log 1 a 2 b 3 u 4 f ros@ros-course:~/ROS_Course$ nl -n rn ROS.log 1 a 2 b 3 u 4 f ros@ros-course:~/ROS_Course$ nl -n rz ROS.log 000001 a 000002 b 000003 u 000004 f 例三：把ROS.log的文件内容加上行号后显示，行号在屏幕最右方加 0 显示，行号栏目占位数为 3，可以使用如下命令： 5nl -n rz -w 3 ROS.log 运行结果如下： ros@ros-course:~/ROS_Course$ nl -n rz -w 3 ROS.log 001 a 002 b 003 u 004 f 1.15 echo命令 echo 命令用来在标准输出中显示输入的字符串 1.15.1 命令格式 echo [选项] 字符串 1.15.2 常用参数 参数 描述 -n 输出字符串不换行 -e 处理转义字符：\\a 发出警告声\\b 删除前一个字符\\c 最后不加上换行符号\\f 换行但光标仍旧停留在原来的位置\\n 换行且光标移至行首\\r 光标移至行首，但不换行\\t 插入tab\\v 与\\f相同\\ 插入\\字符\\0nnn 字节数以八进制数 NNN (1至3位)表示\\xHH 字节数以十六进制数 HH (1至2位)表示 -E 禁用转义解释 1.15.3 常用范例 例一：显示普通字符串： ros@ros-course:~/ROS_Course$ echo \"It is a test\" It is a test 例二：显示转义字符： ros@ros-course:~/ROS_Course$ echo \"\\\"It is a test\\\"\" \"It is a test\" 例三：显示结果定向至文件： echo \"It is a test\" > ROS5.txt 运行结果如下： ros@ros-course:~/ROS_Course$ echo \"It is a test\" > ROS5.txt ros@ros-course:~/ROS_Course$ ls r.log ROS1.log ROS2.log ROS3.log ROS4.log ROS5.txt ROS.log test test1 ros@ros-course:~/ROS_Course$ more ROS5.txt It is a test 例四：显示命令执行结果： echo `date` 运行结果如下： ros@ros-course:~/ROS_Course$ echo `date` 2021年 08月 12日 星期四 23:26:45 CST 注意：这里使用的是反引号 `, 而不是单引号 ' 1.15.4 思考题 输入echo --help会发生什么？echo指令如何查看帮助文档？ 1.16 chmod命令 chmod 命令是 change mode的缩写 chmod命令作用是控制用户对文件的权限的命令 1.16.1 命令格式 chmod [选项] mode 文件/目录 补充说明： Linux 的文件调用权限分为三级 : 文件所有者（Owner）、用户组（Group）、其它用户（Other Users），见下图 只有文件所有者和超级用户可以修改文件或目录的权限。可以使用绝对模式（八进制数字模式），符号模式指定文件的权限 1.16.2 常用参数 参数 描述 -c 若该文件权限确实已经更改，才显示其更改动作 -f 若该文件权限无法被更改也不要显示错误讯息 -v 显示权限变更的详细资料 -R 对目前目录下的所有文件与子目录进行相同的权限变更(即以递归的方式逐个变更) mode 权限设定字串，格式如下 : [ugoa] [+-=] [rwxX] u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是+ 表示增加权限、- 表示取消权限、= 表示将用户类型的所有权限重新设置r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行 1.16.3 八进制语法 chmod命令可以使用八进制数来指定权限 文件或目录的权限位是由9个权限位来控制，每三位为一组，它们分别是文件所有者、用户组以及其它用户（Other）的读、写、执行，见下图 # 权限 rwx 二进制 7 读 + 写 + 执行 rwx 111 6 读 + 写 rw- 110 5 读 + 执行 r-x 101 4 只读 r-- 100 3 写 + 执行 -wx 011 2 只写 -w- 010 1 只执行 --x 001 0 无 --- 000 读权限，表示你可以使用 cat 之类的命令来读取某个文件的内容；写权限，表示你可以编辑和修改某个文件的内容；执行权限，通常指可以运行的二进制程序文件或者脚本文件 一个目录同时具有读权限和执行权限才可以打开并查看内部文件，而一个目录要有写权限才允许在其中创建其它文件 上例中， 765 将这样解释： 所有者的权限用数字表达：属主的那三个权限位的数字加起来的总和。如 rwx ，也就是 4+2+1 ，应该是 7 用户组的权限用数字表达：属组的那个权限位数字的相加的总和。如 rw- ，也就是 4+2+0 ，应该是 6 其它用户的权限数字表达：其它用户权限位的数字相加的总和。如 r-x ，也就是 4+0+1 ，应该是 5 1.16.4 常用范例 例一：将文件 ROS1.txt 设为所有人皆可读取 ： chmod ugo+w ROS1.txt or chmod a+w ROS1.txt g、o 、 u 分别表示 group（用户组）、others（其他用户） 和 user（用户），+ 和 - 分别表示增加和去掉相应的权限 运行结果如下： ros@ros-course:~/ROS_Course$ touch ROS1.txt ros@ros-course:~/ROS_Course$ ls -l ROS1.txt -rw-rw-r-- 1 ros ros 0 8月 13 16:33 ROS1.txt ros@ros-course:~/ROS_Course$ chmod ugo+w ROS1.txt ros@ros-course:~/ROS_Course$ ls -l ROS1.txt -rw-rw-rw- 1 ros ros 0 8月 13 16:33 ROS1.txt 例二：将文件ROS2.txt 与ROS3.txt 设为该文件拥有者、以及其所属同一个群体者只可写入，其他以外的人只执行 ： chmod ug=w,o=r ROS2.txt ROS3.txt 运行结果如下： ros@ros-course:~/ROS_Course$ touch ROS2.txt ROS3.txt ros@ros-course:~/ROS_Course$ ls -l ROS2.txt ROS3.txt -rw-rw-r-- 1 ros ros 0 8月 13 16:41 ROS2.txt -rw-rw-r-- 1 ros ros 0 8月 13 16:41 ROS3.txt ros@ros-course:~/ROS_Course$ chmod ug=w,o=x ROS2.txt ROS3.txt ros@ros-course:~/ROS_Course$ ls -l ROS2.txt ROS3.txt --w--w---x 1 ros ros 0 8月 13 16:41 ROS2.txt --w--w---x 1 ros ros 0 8月 13 16:41 ROS3.txt 例三：将文件ROS4.txt设为该文件拥有者、所属组以及其他人均可读、写、执行： chmod a=rwx ROS4.txt or chmod 777 ROS4.txt 运行结果如下： ros@ros-course:~/ROS_Course$ touch ROS4.txt ros@ros-course:~/ROS_Course$ ls -l ROS4.txt -rw-rw-r-- 1 ros ros 0 8月 13 16:51 ROS4.txt ros@ros-course:~/ROS_Course$ chmod a=rwx ROS4.txt ros@ros-course:~/ROS_Course$ ls -l ROS4.txt -rwxrwxrwx 1 ros ros 0 8月 13 16:51 ROS4.txt ros@ros-course:~/ROS_Course$ rm ROS4.txt && touch ROS4.txt ros@ros-course:~/ROS_Course$ ls -l ROS4.txt -rw-rw-r-- 1 ros ros 0 8月 13 16:54 ROS4.txt ros@ros-course:~/ROS_Course$ chmod 777 ROS4.txt ros@ros-course:~/ROS_Course$ ls -l ROS4.txt -rwxrwxrwx 1 ros ros 0 8月 13 16:54 ROS4.txt 例四：将test目录下的所有文件与子目录皆设为任何人可写入： chmod -R a+w test 当前test及test下ROS1.log文件的权限如下： drwxrwxr-x 2 ros ros 4096 8月 12 16:28 test -rw-rw-r-- 1 ros ros 4 8月 12 17:03 ROS1.log 运行结果如下： drwxrwxrwx 2 ros ros 4096 8月 12 16:28 test -rw-rw-rw- 1 ros ros 4 8月 12 17:03 ROS1.log new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter2-2.html":{"url":"Markdown/Ubuntu/chapter2-2.html","title":"2.2 文件查找命令","keywords":"","body":"2.2 文件查找命令 2.1 which命令 which 命令在 PATH 变量指定的路径中搜索可执行文件的所在位置 which 命令一般用来确认系统中是否安装了指定的软件 2.1.1 命令格式 which 可执行文件名称 2.1.2 常用范例 例一：确认是否安装了 gcc，可以使用如下命令： which gcc 运行结果如下： ros@ros-course:~/ROS_Course$ which gcc /usr/bin/gcc 例二：查看 ls 命令的位置路径，可以使用如下命令： which ls 运行结果如下： ros@ros-course:~/ROS_Course$ which ls /bin/ls 备注：echo $PATH这条指令可以查看PATH路径的内容 补充知识：到底什么是命令？ 命令可以是下面四种形式之一： 是一个可执行程序，就像我们所看到的位于目录/usr/bin中的文件一样。属于这一类的程序，可以编译成二进制文件，诸如用 C 和 C++ 语言写成的程序，也可以是由脚本语言写成的程序，比如说 shell，perl，python，ruby等等 是一个内建于 shell 自身的命令。bash 支持若干命令，内部叫做 shell 内部命令 (builtins)。例如， cd 命令就是一个 shell 内部命令 是一个 shell 函数。这些是小规模的 shell 脚本，它们混合到环境变量中。 比如上面讲到的 cd 命令，在某些环境中就是一个 shell 函数 是一个命令别名。我们可以定义自己的命令，建立在其它命令之上 2.2 whereis 命令 whereis 命令用于定位可执行文件、源代码文件和帮助文件在文件系统中的位置 whereis 命令具有搜索源代码、指定备用搜索路径和搜索不寻常项功能 whereis 命令在数据库（/var/lib/mlocate/mlocate.db）查询，此数据库由 Linux 系统自动创建，包含有本地所有文件的信息，每天通过自动执行 updatedb 命令更新一次，因此whereis 命令查找速度非常快 因为此数据库要每天才更新一次，使得 whereis 命令的搜索结果有时候会不准确，比如刚添加的文件可能搜不到 2.2.1 命令格式 whereis [选项] 文件 2.2.2 常用参数 参数 描述 -b 定位可执行文件 -m 定位帮助文件 -s 定位源代码文件 -u 搜索默认路径下除可执行文件、源代码文件和帮助文件以外的其它文件 -B 指定搜索可执行文件的路径 -M 指定搜索帮助文件的路径 -S 指定搜索源代码文件的路径 2.2.3 常用范例 例一：搜索 gcc 可执行文件的路径，可以使用如下命令： whereis -b gcc 运行结果如下： ros@ros-course:~/ROS_Course$ whereis -b gcc gcc: /usr/bin/gcc /usr/lib/gcc 例二：搜索 gcc 帮助文件的路径，可以使用如下命令： whereis -m gcc 运行结果如下： ros@ros-course:~/ROS_Course$ whereis -m gcc gcc: /usr/share/man/man1/gcc.1.gz 例三：搜索 gcc 源代码的路径，可以使用如下命令： whereis -s gcc 运行结果如下： ros@ros-course:~/ROS_Course$ whereis -s gcc gcc: 运行结果说明：没有找到gcc源代码，输出结果为空 2.3 locate 命令 locate 命令跟 whereis 命令类似，它们使用的是相同的数据库。但 whereis 命令只能搜索可执行文件、帮助文件和源代码文件，locate命令可查找符合搜索字符串条件的文档或目录 locate 命令使用了十分复杂的匹配语法，可以使用特殊字元（如’*’和’?’）来指定需要查找的样本 2.3.1 命令格式 locate [选项] 搜索字符串 常用参数 参数 描述 -q 安静模式，不会显示任何错误讯息 -n 至多显示 n 个输出 -r 使用正则表达式做寻找的条件 -V 显示版本信息 2.3.2 常用范例 例一：搜索 etc 目录下所有以 sh 开头的文件，可以使用如下命令： locate /etc/sh 运行结果如下： ros@ros-course:~/ROS_Course$ locate /etc/sh /etc/shadow /etc/shadow- /etc/shells /snap/core/11420/etc/shadow /snap/core/11420/etc/shells /snap/core/8268/etc/shadow /snap/core/8268/etc/shells /snap/core18/2074/etc/shadow /snap/core18/2074/etc/shells /snap/core18/2128/etc/shadow /snap/core18/2128/etc/shells /snap/core20/1081/etc/shadow /snap/core20/1081/etc/shells 例二：搜索 etc 目录下文件名包含 lou 的文件，可以使用如下命令： locate /etc/*lou* 运行结果如下： ros@ros-course:~/ROS_Course$ locate /etc/*lou* /etc/modprobe.d/libopenni-sensor-pointclouds0.conf /etc/systemd/system/cloud-final.service.wants /etc/systemd/system/cloud-final.service.wants/snapd.seeded.service 例三：搜索 etc 目录下以字串h开头且以字符e结尾的文件，可以使用如下命令： locate /etc/h*e 运行结果如下： ros@ros-course:~/ROS_Course$ locate /etc/h*e /etc/hostname /snap/core/11420/etc/hostname /snap/core/8268/etc/hostname /snap/core18/2074/etc/hostname /snap/core18/2128/etc/hostname /snap/core20/1081/etc/hostname 2.4 find 命令（一） find 命令主要作用是沿着文件层次结构向下遍历，匹配符合条件的文件，并执行相应的操作 2.4.1 命令格式 find [选项] [搜索路径] [表达式] 默认路径是当前目录，默认表达式为 -print 表达式组成：操作符、选项、测试表达式以及动作 2.4.2 常用参数 参数 描述 -print find 命令将匹配的文件输出到标准输出 -exec find 命令对匹配的文件执行该参数所给出的 shell 命令 -name 按照文件名查找文件 -type 查找某一类型的文件 -prune 使用这一选项可以使 find 命令不在当前指定的目录中查找，如果同时使用 -depth 选项，那么 -prune 将被 find 命令忽略 -user 按照文件属主来查找文件 -group 按照文件所属的组来查找文件 -mtime -n +n 按照文件的更改时间来查找文件，-n 表示文件更改时间距现在小于 n 天，+n 表示文件更改时间距现在大于 n 天，find 命令还有 -atime 和 -ctime 选项 备注：其他命令选项及表达式参见find --help 2.4.3 常用范例 例一：打印当前目录下的文件目录列表，可以使用如下命令： find or find . or find . -print 运行结果如下： ros@ros-course:~/ROS_Course$ find . ./ROS5.txt ./r.log ./ROS3.log ./ROS4.log ./ROS1.log ./test1 ./test1/ROS1.log ./test ./test/ROS1.log ./ROS2.log ./ROS.log 运行结果说明： .（点号）表示此目录本身，包含当前目录下所有隐藏目录和隐藏文件夹，一般可以不写，所以cd ~/. 和cd ~ 和cd ~/效果是一样的 .（点号）在文件名头部，代表一个隐藏文件 例二：打印当前目录下所有以.log结尾的文件名，可以使用如下命令： find . -name \"*.log\" 运行结果如下： ros@ros-course:~/ROS_Course$ find . -name \"*.log\" ./r.log ./ROS3.log ./ROS4.log ./ROS1.log ./test1/ROS1.log ./test/ROS1.log ./ROS2.log ./ROS.log 例三：打印当前目录下所有以.txt 或.log 结尾的文件名，可以使用如下命令： find . \\( -name \"*.log\" -or -name \"*.txt\" \\) 运行结果如下： ros@ros-course:~/ROS_Course$ find . \\( -name \"*.log\" -or -name \"*.txt \" \\) ./r.log ./ROS3.log ./ROS4.log ./ROS1.log ./test1/ROS1.log ./test/ROS1.log ./ROS2.log ./ROS.log 补充说明：find 命令可以通过逻辑操作符来创建复杂的逻辑关系，此例中使用了操作符 -or 。find 命令的逻辑操作符见下表： 例四：打印当前目录下所有不以.txt 结尾的文件名，可以使用如下命令： find . ! -name \"*.txt\" 运行结果如下： ros@ros-course:~/ROS_Course$ find . ! -name \"*.txt\" . ./r.log ./ROS3.log ./ROS4.log ./ROS1.log ./test1 ./test1/ROS1.log ./test ./test/ROS1.log ./ROS2.log ./ROS.log 2.5 find 命令（二） 本节将介绍如何根据文件类型、权限、所有者及操作符来查找匹配文件 根据文件类型来查找文件，使用 -type 选项，常见 find 文件类型见下表： 根据文件权限查找文件，使用 -perm 选项，所有者使用 -user 选项 2.5.1 常用范例 例一：打印当前目录下所有以 .txt 结尾的符号链接，可以使用如下命令： find . -type l -name \"*.txt\" -print 补充说明：Linux 软连接与硬连接 对于一个文件来说，有唯一的索引接点与之对应，而对于一个索引接点号，却可以有多个文件名与之对应 因此，在磁盘上的同一个文件可以通过不同的路径去访问该文件，产生了软连接和硬链接 通俗地讲， 硬链接可认为是一个文件拥有两个文件名，而软链接则是系统新建一个链接文件，此文件指向其所要指的文件。软链接可对文件和文件夹，硬链接仅针对文件 软连接(symbolic link)又叫符号连接，符号连接相当于Windows下的快捷方式， 不可以对文件夹建立硬连接 通过 ln [option] source_file dist_file可建立链接文件（source_file是待建立链接文件的文件，dist_file是新创建的链接文件，-s 建立软链接） 建立软连接： 建立a.txt 和 ROS.log 的软连接，可用如下代码： ln -s ROS.log a.txt 运行结果如下： ros@ros-course:~/ROS_Course$ ln -s ROS.log a.txt ros@ros-course:~/ROS_Course$ ls -l a.txt lrwxrwxrwx 1 ros ros 7 8月 13 11:40 a.txt -> ROS.log 打印当前目录下所有以 .txt 结尾的符号链接，运行结果如下： ros@ros-course:~/ROS_Course$ find . -type l -name \"*.txt\" -print ./a.txt 例二：打印当前目录下所有权限为 777 的 log 文件，可以使用如下命令： find . -type f -name \"*.log\" -perm 777 运行结果如下： ros@ros-course:~/ROS_Course$ chmod 777 ROS.log ros@ros-course:~/ROS_Course$ find . -type f -name \"*.log\" -perm 777 ./ROS.log 例三：打印当前目录下 ros 用户拥有的符号文件，可以使用如下命令： find . -type l -user ros 运行结果如下： ros@ros-course:~/ROS_Course$ find . -type l -user ros ./r.log ./a.txt 例四：打印当前目录下权限不是 777 和 664 的所有文件，可以使用如下命令： find . -type f \\( ! -perm 777 -and ! -perm 644 \\) 运行结果如下： ros@ros-course:~/ROS_Course$ find . -type f \\( ! -perm 777 -and ! -perm 644 \\) ./ROS5.txt ./ROS1.txt ./ROS2.txt ./ROS3.log ./ROS3.txt ./ROS4.log ./ROS1.log ./test1/ROS1.log ./test/ROS1.log ./ROS2.log 2.6 find 命令（三） 本节介绍如何使用 find 命令的 -exec 选项来实现对查找到的文件执行指定的动作命令 2.6.1 常用范例 例一：找到当前目录下所有 txt 文件，并显示其详细信息，可以使用如下命令： find . -name \"*.txt\" -exec ls -l {} \\; 运行结果如下： ros@ros-course:~/ROS_Course$ find . -name \"*.txt\" -exec ls -l {} \\; -rw-rw-r-- 1 ros ros 13 8月 12 23:25 ./ROS5.txt -rw-rw-rw- 1 ros ros 0 8月 13 16:33 ./ROS1.txt --w--w---x 1 ros ros 0 8月 13 16:41 ./ROS2.txt --w--w---x 1 ros ros 0 8月 13 16:41 ./ROS3.txt lrwxrwxrwx 1 ros ros 7 8月 13 11:40 ./a.txt -> ROS.log -rwxrwxrwx 1 ros ros 0 8月 13 16:54 ./ROS4.txt 运行结果说明： -exec 是 find 命令对找到的文件执行的动作，上面的命令是ls -l {} 在这里说明一下{}和\\;，{}是一个占位符，在 find 命令的执行过程中会不断地替换成当前找到的文件，相当于”ls -l 找到的文件” \\;是 -exec 命令结束的标记，因为规定 -exec 后面的命令必须以;结束，但;在 shell 中有特殊含义，必须要转义，所以写成\\; 例二：在当前目录中有很多 log 文件，现在想要把所有 log 文件下载下来，如果一个一个的下载很麻烦，我们可以先查找到所有的 log 文件，然后将这些文件内容写入到一个文件中，下载这一个文件就可以了，可以使用如下命令： find . -name \"*.log\" -exec cat {} \\; > all.log 例三：默认下，-exec 后面只能使用单个命令，如果想要多个命令，可以将多个命令写入脚本文件中，然后在 -exec 中使用这个脚本，可以使用如下命令： find . -name \"*.log\" -exec ./command.sh {} \\; 脚本内容： #!/bin/bash ls -l $1 #$1表示第一个参数 cat $1 注意，直接运行上面的代码可能会提示你find './command.sh' : 权限不够，这是因为新建的command.sh没有执行权限，只需要使用chmod +x command.sh给予它可执行权限再执行即可 2.7 xargs 命令 xargs命令是eXtended ARGuments的缩写 xargs一般是和管道一起使用，是给命令传递参数的一个过滤器，也是组合多个命令的一个工具，它能够捕获一个命令的输出，然后传递给另外一个命令 xargs可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据 xargs可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行 2.7.1 命令格式 command | xargs [选项] [command] 备注：xargs 命令应该紧跟在管道操作符之后，因为它以标准输入作为主要的源数据流 2.7.2 常用参数 参数 描述 -n 指定每行最大的参数数量，默认为所有的 -d 指定分隔符 -i 或 -I 将xargs的每项内容，一行一行赋值给 {}，后续使用时可以用 {} 代替 2.7.3 常用范例 例一：将多行输入转换为单行输出，可以使用如下命令： cat b.txt | xargs 运行结果如下： ros@ros-course:~/ROS_Course$ cat b.txt a v b f h d t h y j ros@ros-course:~/ROS_Course$ cat b.txt | xargs a v b f h d t h y j 例二：将单行输入转换为多行输出，可以使用如下命令： echo \"1 2 3 4 5 6 7\" | xargs -n 3 运行结果如下： ros@ros-course:~/ROS_Course$ echo \"1 2 3 4 5 6 7\" | xargs -n 3 1 2 3 4 5 6 7 例三：将单行输入转换为多行输出，指定分隔符为 h，可以使用如下命令： cat b.txt | xargs -d h -n 3 运行结果如下： ros@ros-course:~/ROS_Course$ cat c.txt fdsahfdsjafkludisaohkfdsaj ros@ros-course:~/ROS_Course$ cat c.txt | xargs -d h -n 3 fdsa fdsjafkludisao kfdsaj 例四：查找当前目录下所有 log文件并显示详细信息，可以使用如下命令： find . -type f -name \"*.log\" | xargs ls -l 运行结果如下： ros@ros-course:~/ROS_Course$ find . -type f -name \"*.log\" | xargs ls -l -rw-rw-r-- 1 ros ros 7399 8月 13 17:21 ./all.log -rw-rw-r-- 1 ros ros 44 8月 12 21:42 ./ROS1.log -rw-rw-r-- 1 ros ros 78 8月 12 17:23 ./ROS2.log -rw-rw-r-- 1 ros ros 271 8月 12 22:24 ./ROS3.log -rw-rw-r-- 1 ros ros 6980 8月 12 22:30 ./ROS4.log -rwxrwxrwx 1 ros ros 9 8月 12 18:15 ./ROS.log -rw-rw-r-- 1 ros ros 4 8月 12 17:01 ./test1/ROS1.log -rw-rw-rw- 1 ros ros 4 8月 12 17:03 ./test/ROS1.log 2.7.4 思考题 下列代码表示什么作用？ ls *.log | xargs -n1 -I {} cp {} /data/images find . -type f -name \"*.log\" -print | xargs -0 rm -f 备注：xargs -0 表示将 \\0 作为定界符 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Ubuntu/chapter2-3.html":{"url":"Markdown/Ubuntu/chapter2-3.html","title":"2.3 其他常用命令","keywords":"","body":"2.3 其他常用命令 3.1 wc命令 wc 命令是 word count 的缩写 wc 命令是一个统计的工具，主要用来显示文件所包含的行、字和字节数 如果没有指定文件，或者文件为\"-\"，则从标准输入读取数据 3.1.1 命令格式 wc [选项] [文件] 3.1.2 常用参数 参数 描述 -c 统计字节数 -l 统计行数 -m 统计字符数，这个标志不能与 -c 标志一起使用 -w 统计字数，一个字被定义为由空白、跳格或换行字符分隔的字符串 -L 打印最长行的长度 3.1.3 常用范例 例一：统计文件的字节数、行数和字符数，可以使用如下命令： wc -c c.txt wc -l c.txt wc -m c.txt 运行结果如下： ros@ros-course:~/ROS_Course$ cat ROS5.txt It is a test ros@ros-course:~/ROS_Course$ wc -c ROS5.txt 13 ROS5.txt ros@ros-course:~/ROS_Course$ wc -l ROS5.txt 1 ROS5.txt ros@ros-course:~/ROS_Course$ wc -m ROS5.txt 13 ROS5.txt 注意，每行结尾的换行符也算一个字符，空格也算一个字符。另外，若系统采用 UTF-8 编码，一个汉字为 3 字节 例二：统计文件的字节数、行数和字符数，只打印数字，不打印文件名，可以使用如下命令： cat ROS5.txt | wc -c 运行结果如下： ros@ros-course:~/ROS_Course$ cat ROS5.txt | wc -c 13 例三：统计/bin目录下的命令个数，可以使用如下命令： ls /bin | wc -l 运行结果如下： ros@ros-course:~/ROS_Course$ ls /bin | wc -l 162 3.1.4 思考题 思考下列代码的作用是什么？ find . -type f -name \"*.log\" | xargs wc -l 3.2 grep命令 grep 命令用于查找文件里符合条件的字符串 grep 可接受正则表达式和通配符，可用多个 grep 命令选项来生成不同格式的输出 grep 通过返回一个状态值来说明搜索的状态，如果字符串搜索成功，则返回 0，如果搜索不成功，则返回 1，如果搜索的文件不存在，则返回 2 grep 会把含有所搜索字符串的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为 -，则 grep 指令会从标准输入设备读取数据 3.2.1 命令格式 grep [选项] 搜索字符串 [文件] 3.2.2 常用参数 参数 描述 -c 计算找到‘搜寻字符串’（即 pattern）的次数 -i 忽略大小写的不同 -n 输出行号 -v 反向选择，打印不匹配的行 -r 递归搜索 --color=auto 将找到的关键词部分加上颜色显示 3.2.3 常用范例 例一：将/etc/passwd文件中出现 root 的行取出来，关键词部分加上颜色显示，可以使用如下命令： grep \"root\" /etc/passwd --color=auto cat /etc/passwd | grep \"root\" --color=auto 运行结果如下： ros@ros-course:~/ROS_Course$ grep \"root\" /etc/passwd --color=auto root:x:0:0:root:/root:/bin/bash ros@ros-course:~/ROS_Course$ cat /etc/passwd | grep \"root\" --color=auto root:x:0:0:root:/root:/bin/bash 例二：将/etc/passwd文件中没有出现 root 和 nologin 的行取出来，可以使用如下命令： grep -v \"root\" /etc/passwd | grep -v \"nologin\" 运行结果如下： ros@ros-course:~/ROS_Course$ grep -v \"root\" /etc/passwd | grep -v \"nologin\" sync:x:4:65534:sync:/bin:/bin/sync speech-dispatcher:x:111:29:Speech Dispatcher,,,:/var/run/speech-dispatcher:/bin/false whoopsie:x:112:117::/nonexistent:/bin/false hplip:x:118:7:HPLIP system user,,,:/var/run/hplip:/bin/false gnome-initial-setup:x:120:65534::/run/gnome-initial-setup/:/bin/false gdm:x:121:125:Gnome Display Manager:/var/lib/gdm3:/bin/false ros:x:1000:1000:ROS,,,:/home/ros:/bin/bash 例三：查找/etc/acpi 及其子目录下所有文件中包含字符串\"update\"的文件，并打印出该字符串所在行，以及行的内容，可以使用如下命令： grep -rn \"update\" /etc/acpi 运行结果如下： ros@ros-course:~/ROS_Course$ grep -rn \"update\" /etc/acpi /etc/acpi/events/thinkpad-cmos:7:action=/usr/sbin/thinkpad-keys --update 备注：“update”的双引号，可以使用单引号，也可以省略 3.2.4 补充内容：正则表达式 正则表达式是一种符号表示法，被用来识别文本模式 在某种程度上，它们与匹配文件和路径名的 shell 通配符比较相似，但其规模更大 许多命令行工具和大多数的编程语言都支持正则表达式，以此来帮助解决文本操作问题 正则表达式元字符由以下字符组成： ^ $ . [ ] { } - ? * + ( ) | \\ 常用范例 例一：利用 Linux 系统自带的字典查找一个五个字母的单词，第三个字母为 j,最后一个字母为 r，/usr/share/dict目录下存放字典文件（若没有可手动建立），可以使用如下命令： grep -E '^..j.r$' /usr/share/dict/words 运行结果如下： ros@ros-course:/etc/acpi/events$ grep '^..j.r$' /usr/share/dict/words Major major 例二：验证固定电话，打印符合条件的电话，固定电话格式基本都是带有 0 的区号+连接符“-”+电话号码，另外还有可能有分机号，区号有 3 位、4 位，电话号码有 7 位和 8 位的，可以使用如下命令： grep -E \"^0[0-9]{2,3}-[0-9]{7,8}(-[0-9]{3,4})?$\" telphone.txt 区号：前面一个 0，后面跟 2-3 位数字 0[0-9]{2,3} 电话号码：7-8 位数字 [0-9]{7,8} 分机号：一般都是 3-4 位数字 [0-9]{3,4} 运行结果如下： ros@ros-course:~/ROS_Course$ cat telephone.txt 010-3298643-0983 0953-3026840 0493-7392097-987 0726-38762-0973 ros@ros-course:~/ROS_Course$ grep -E \"^0[0-9]{2,3}-[0-9]{7,8}(-[0-9]{3,4})?$\" telephone.txt 010-3298643-0983 0953-3026840 0493-7392097-987 3.3 cut命令 cut 命令是一个将文本按列进行切分的工具，它可以指定分隔每列的定界符 如果一行数据包含多个字段（多列），想要提取其中的一列或多列，可使用 cut 命令 3.3.1 命令格式 cut [选项] [文件名] 3.3.2 常用参数 参数 描述 -b 以字节为单位进行分割 -c 以字符为单位进行分割 -d 自定义分隔符，默认为制表符 -f 自定义字段 --complement 抽取整个文本行，除了那些由 -c 或 -f 选项指定的文本 3.3.3 常用范例 例一：取出student.txt文件中的第一列和第三列，可以使用如下命令： cut -f 1,3 -d ' ' student.txt 运行结果如下： ros@ros-course:~/ROS_Course$ cat students.txt no name score 1 a 88 2 b 86 3 c 97 4 d 85 5 e 90 ros@ros-course:~/ROS_Course$ cut -f 1,3 -d ' ' students.txt no score 1 88 2 86 3 97 4 85 5 90 例二：取出student.txt文件中的前三列，可以使用如下命令： cut -f 1-3 -d ' ' student.txt 运行结果如下： ros@ros-course:~/ROS_Course$ cut -f 1-3 -d ' ' students.txt no name score 1 a 88 2 b 86 3 c 97 4 d 85 5 e 90 例三：取出student.txt文件中除第一列的其他列，可以使用如下命令： cut -f 1 -d ' ' student.txt --complement 运行结果如下： ros@ros-course:~/ROS_Course$ cut -f 1 -d ' ' students.txt --complement name score a 88 b 86 c 97 d 85 e 90 例四：给任意一字符串 str，取出其最后一个字符，可以使用如下命令： num=$(echo -n $str | wc -c) echo -n $str | cut -b $num #或者可以使用下面这段代码 echo -n $str | cut -b `echo -n $str | wc -c` 3.4 paste命令 paste 命令的功能与 cut 相反。它会添加一个或多个文本列到文件中 paste 命令读取多个文件，然后把每个文件中的字段整合成单个文本流，输入到标准输出 3.4.1 命令格式 paste [选项] [文件名] 3.4.2 常用参数 参数 描述 -s 将每个文件合并成行而不是按行粘贴 -d 自定义分隔符，默认为制表符 3.4.3 常用范例 例一：将students.txt和telephone.txt文件中的内容按列拼接，可以使用如下命令： paste students.txt telephone.txt 运行结果如下： ros@ros-course:~/ROS_Course$ paste students.txt telephone.txt no name score 010-3298643-0983 1 a 88 0953-3026840 2 b 86 0493-7392097-987 3 c 97 0726-38762-0973 4 d 85 5 e 90 例二：将students.txt和telephone.txt文件中的内容按列拼接，指定分隔符为:，可以使用如下命令： paste students.txt telephone.txt -d ':' 运行结果如下： ros@ros-course:~/ROS_Course$ paste students.txt telephone.txt -d ':' no name score:010-3298643-0983 1 a 88:0953-3026840 2 b 86:0493-7392097-987 3 c 97:0726-38762-0973 4 d 85: 5 e 90: 例三：将students.txt和telephone.txt文件中的内容各自拼接成一行，可以使用如下命令： paste -s students.txt telephone.txt 运行结果如下： ros@ros-course:~/ROS_Course$ paste -s students.txt telephone.txt no name score 1 a 88 2 b 86 3 c 97 4 d 85 5 e 90 010-3298643-0983 0953-3026840 0493-7392097-987 0726-38762-0973 3.5 tr命令 tr 是 translate 的缩写 tr 命令被用来更改字符，可以看作是一种基于字符的查找和替换操作 tr 只能通过 stdin（标准输入），而无法通过命令行参数来接受输入 3.5.1 命令格式 tr [选项] SET1 SET2 备注：将来自 stdin 的输入字符从 SET1 映射到 SET2，并将其输出写入 stdout（标准输出）。SET1 和 SET2 是字符类或字符集。如果两个字符集的长度不相等，那么 SET2 会不断重复其最后一个字符，直到长度与 SET1 相同。如果 SET2 的长度大于 SET1，那么在 SET2 中超出 SET1 的那部分字符则全部被忽略 3.5.2 常用参数 参数 描述 -d 删除SET1中匹配的内容，并不作替换 3.5.3 常用范例 例一：将输入的字符大写转换为小写，可以使用如下命令： echo 'THIS IS ROS!' | tr 'A-Z' 'a-z' 运行结果如下： ros@ros-course:~/ROS_Course$ echo 'THIS IS ROS!' | tr 'A-Z' 'a-z' this is ros! 例二：将输入的字符中的数字删除，可以使用如下命令： echo 'THIS 123 IS ROS!' | tr -d '0-9' 运行结果如下： ros@ros-course:~/ROS_Course$ echo 'THIS 123 IS ROS!' | tr -d '0-9' THIS IS ROS! 例三：tr 命令的一个有趣的用法是执行 ROT13 文本编码。ROT13 是一款微不足道的基于一种简易的替换暗码的加密类型。把 ROT13 称为“加密”是不严格的，“文本模糊处理”更准确些。有时候它被用来隐藏文本中潜在的攻击内容。这个方法就是简单地把每个字符在字母表中向前移动 13 位。因为移动的位数是所有 26 个字母的一半，所以对文本再次执行这个算法，就恢复到了它最初的形式。可以使用如下命令： #加密 echo 'ROS Course' | tr 'a-zA-Z' 'n-za-mN-ZA-M' 得到结果：EBF Pbhefr #解密 echo 'EBF Pbhefr' | tr 'a-zA-Z' 'n-za-mN-ZA-M' 得到结果 ROS Course 3.6 sort命令 sort 命令能够帮助我们对文本文件和 stdin 进行排序操作 通常，sort会结合其他命令来生成所需要的输出 3.6.1 命令格式 sort [选项] [文件名] 3.6.2 常用参数 参数 描述 -n 基于字符串的长度来排序，使用此选项允许根据数字值排序，而不是字母值 -k 指定排序关键字 -b 默认情况下，对整行进行排序，从每行的第一个字符开始。这个选项使得sort 程序忽略每行开头的空格，从第一个非空白字符开始排序 -m 只合并多个输入文件 -r 按相反顺序排序，结果按照降序排列 -t 自定义分隔符，默认为制表符 3.6.3 常用范例 例一：列出/usr/share/目录下使用空间最多的前 10 个目录文件，可以使用如下命令： du -s /usr/share/* | sort -nr | head -10 备注：du -s /usr/share/*命令显示/usr/share/目录下所有文件和目录的磁盘使用空间，目录包含目录下的子目录和文件 运行结果如下： ros@ros-course:~/ROS_Course$ du -s /usr/share/* | sort -nr | head -10 423928 /usr/share/fonts 224600 /usr/share/typora 175716 /usr/share/doc 80744 /usr/share/icons 76292 /usr/share/gazebo-9 59544 /usr/share/locale 40940 /usr/share/ibus 38700 /usr/share/man 37360 /usr/share/backgrounds 35460 /usr/share/help 例二：对 ls 命令输出信息中的空间使用大小字段进行排序，可以使用如下命令： ls -l /usr/bin/ | sort -nr -k 5 | head -10 运行结果如下： ros@ros-course:~/ROS_Course$ ls -l /usr/bin/ | sort -nr -k 5 | head -10 -rwxr-xr-x 1 root root 51859776 1月 26 2018 pandoc -rwxr-xr-x 1 root root 19610632 3月 26 23:49 snap -rwxr-xr-x 1 root root 8612088 5月 28 2018 gzclient-9.0.0 -rwxr-xr-x 1 root root 7619056 10月 30 2020 gdb -rwxr-xr-x 1 root root 6518192 4月 4 22:10 ctest -rwxr-xr-x 1 root root 5893648 6月 24 2019 ubuntu-report -rwxr-xr-x 1 root root 5566864 4月 4 22:10 cpack -rwxr-xr-x 1 root root 5325648 4月 4 22:10 cmake -rwxr-xr-x 1 root root 4992936 4月 30 2020 shotwell -rwxr-xr-x 1 root root 4551912 1月 13 2020 gnome-control-center 3.7 uniq 命令 uniq 命令是 unique 的缩写 uniq 命令经常和 sort 命令结合在一起使用。uniq 从标准输入或单个文件名参数接受数据有序列表，默认情况下，从数据列表中删除重复出现的行列 uniq 只能用于排过序的数据输入，因此，uniq 要么使用管道，要么将排过序的文件作为输入，总是以这种方式与 sort 命令结合起来使用 3.7.1 命令格式 uniq [选项] [文件名] 3.7.2 常用参数 参数 描述 -c 在每行前加上表示相应行目出现次数的前缀编号 -d 只输出重复的行 -u 只显示唯一的行 -D 显示所有重复的行 -f 比较时跳过前 n 列 -i 在比较的时候不区分大小写 -s 比较时跳过前 n 个字符 -w 对每行第 n 个字符以后的内容不作对照 3.7.3 常用范例 例一：找出/bin目录和/usr/bin目录下所有相同的命令，可以使用如下命令： ls /bin /usr/bin | sort | uniq -d 运行结果如下： ros@ros-course:~/ROS_Course$ ls /bin /usr/bin | sort | uniq -d chacl dumpkeys getfacl less lessecho lessfile lesskey lesspipe loadkeys setfacl touch which 例二：现有student1.txt文件内容如下，其中第四列第一个字符表示区号，现在要统计出各个区号的总人数 ros@ros-course:~/ROS_Course$ cat student1.txt li 100 89 1-34-56 sun 200 90 2-34-56 wan 321 88 2-34-51 qun 234 92 1-34-56 zhao 452 93 1-23-89 实现思路：首先按区号对每行信息排序，然后使用 uniq 命令对区号进行重复行统计。使用命令如下： sort -k 4.1n student1.txt | uniq -c -f 3 -w 2 运行结果如下： ros@ros-course:~/ROS_Course$ sort -k 4.1n student1.txt | uniq -c -f 3 -w 2 3 li 100 89 1-34-56 2 sun 200 90 2-34-56 运行结果说明： sort -k 4.1n表示对第四个字段的第一个字符按数值排序 uniq -c -f 3 -w 2中 -f 3 表示跳过前三列的比较，那么现在只剩下最后一列，-w 2 表示第 2 个字符后的内容不做比较，为什么是 2 呢，因为跳过前三列时并没有跳过最后一列前面的空格分隔符，区号前都还有一个空格 3.8 join命令 join 命令类似于 paste，它会往文件中添加列 join 命令跟 uniq 命令一样，只能用于排过序的数据 join 命令将两个文件中指定栏位相同的行连接起来 3.8.1 命令格式 join [选项] 文件 1 文件 2 3.8.2 常用参数 参数 描述 -j FIELD 等同于 -1 FIELD -2 FIELD，-j 指定一个域作为匹配字段 -1 FIELD 以 file1 中 FIELD 字段进行匹配 -2 FIELD 以 file2 中 FIELD 字段进行匹配 -t 自定义分隔符，默认为制表符 3.8.3 常用范例 例一：指定两个文件的第三个字段为匹配字段，连接两个文件，可以使用如下命令： join -1 3 -2 3 student1.txt student2.txt 运行结果如下： ros@ros-course:~/ROS_Course$ cat student1.txt wan 321 89 2-34-51 li 100 90 1-34-56 sun 200 91 2-34-56 qun 234 92 1-34-56 zhao 452 93 1-23-89 ros@ros-course:~/ROS_Course$ cat student2.txt zhao 252 89 2-73-69 qun 278 90 3-33-46 wan 322 91 7-31-91 ros@ros-course:~/ROS_Course$ join -1 3 -2 3 student1.txt student2.txt 89 wan 321 2-34-51 zhao 252 2-73-69 90 li 100 1-34-56 qun 278 3-33-46 91 sun 200 2-34-56 wan 322 7-31-91 备注：应用join前要对student1.txt 和 student2.txt 进行排序 3.9 comm命令 comm 命令用于逐行比较已经排序的两个文件 显示结果包括 3 列：第 1 列为只在第一个文件中找到的行，第 2 列为只在第二个文件中找到的行，第 3 列为两个文件的共有行 comm 命令和 join、uniq 命令一样，只能用于已经排过序的数据。 3.9.1 命令格式 comm [选项] 文件 1 文件 2 3.9.2 常用参数 参数 描述 -1 不输出文件 1 特有的行 -2 不输出文件 2 特有的行 -3 不输出两个文件共有的行 3.9.4 常用范例 例一：比较student3.txt和student4.txt两个文件的内容，可以使用如下命令： comm student3.txt student4.txt 运行结果如下： ros@ros-course:~/ROS_Course$ cat student3.txt li 100 90 1-34-56 qun 234 92 1-34-56 sun 200 91 2-34-56 zhao 252 89 2-73-69 zhao 452 93 1-23-89 ros@ros-course:~/ROS_Course$ sort student4.txt qun 234 92 1-34-56 qun 278 90 3-33-46 zhao 252 89 2-73-69 ros@ros-course:~/ROS_Course$ comm student3.txt student4.txt li 100 90 1-34-56 qun 234 92 1-34-56 qun 278 90 3-33-46 sun 200 91 2-34-56 zhao 252 89 2-73-69 zhao 452 93 1-23-89 例二：比较student3.txt和student4.txt两个文件的内容，只显示两个文件共有的内容，可以使用如下命令： comm -12 student3.txt student4.txt 运行结果如下： ros@ros-course:~/ROS_Course$ comm -12 student3.txt student4.txt qun 234 92 1-34-56 zhao 252 89 2-73-69 3.10 diff命令 diff 命令是 differential 的缩写 类似 comm 命令，diff 命令被用来检测文件之间的差异 diff命令一次能处理许多文本文件。软件开发员经常使用 diff 程序来检查不同程序源码版本之间的更改，diff 能够递归地检查源码目录，通常称之为源码树 diff 在命令行中打印每一行的改动，并且 diff 是 svn、cvs、git 等版本控制工具不可或缺的一部分 3.10.1 命令格式 diff [选项] 文件 3.10.2 常用参数 参数 描述 -c 上下文模式，显示全部内文，并标出不同之处 -u 统一模式，以合并的方式来显示文件内容的不同 -a 只会逐行比较文本文件 -N 在比较目录时，若文件 A 仅出现在某个目录中，预设会显示：Only in 目录。若使用 -N 参数，则 diff 会将文件 A 与一个空白的文件比较 -r 递归比较目录下的文件 3.10.3 常用范例 例一：显示student3.txt和student4.txt两个文件的差异，可以使用如下命令： diff file1.txt file2.txt 运行结果如下： ros@ros-course:~/ROS_Course$ cat student3.txt li 100 90 1-34-56 qun 234 92 1-34-56 sun 200 91 2-34-56 zhao 252 89 2-73-69 zhao 452 93 1-23-89 ros@ros-course:~/ROS_Course$ cat student4.txt qun 234 92 1-34-56 qun 278 90 3-33-46 zhao 252 89 2-73-69 ros@ros-course:~/ROS_Course$ diff student3.txt student4.txt 1d0 qun 278 90 3-33-46 5d3 运行结果说明： 上面结果显示中的“1d0”表示student3.txt文件比studengt4.txt文件多了第一行 “3c2”表示student3.txt文件的第三行和student4.txt文件的第二行不同 例二：从上面例一的显示结果可以知道，student3.txt和student4.txt两个文件的差异不易直观看出，这时可以使用上下文模式显示，可以使用如下命令： diff -c student3.txt student4.txt 运行结果如下： *** student3.txt 2021-08-14 15:12:11.352661281 +0800 --- student4.txt 2021-08-14 15:12:25.683063156 +0800 *************** *** 1,5 **** - li 100 90 1-34-56 qun 234 92 1-34-56 ! sun 200 91 2-34-56 zhao 252 89 2-73-69 - zhao 452 93 1-23-89 --- 1,3 ---- qun 234 92 1-34-56 ! qun 278 90 3-33-46 zhao 252 89 2-73-69 运行结果说明： 这个输出结果以两个文件名和它们的时间戳开头 第一个文件用星号做标记，第二个文件用短横线做标记 *** 1,5 *** 表示第一个文件中第一行到第五行的文本行 --- 1,3 --- 表示第二个文件中第一行到第三行的文本行 三种特殊字符： + 添加行，这一行将会出现在第二个文件内，而不是第一个文件内 - 删除行，这一行将会出现在第一个文件中，而不是第二个文件内 ! 更改行，将会显示某个文本行的两个版本，每个版本会出现在更改组的各自部分 这些特殊字符很容易混淆，实际上记住一点就：所有操作目的是将第一个文件变成第二个文件 3.11 patch命令 patch 命令被用来把更改应用到文本文件中。它接受从 diff 程序的输出，并且通常被用来把较老的文件版本转变为较新的文件版本 使用 diff/patch 组合提供了两个重大优点： 与整个源码树的大小相比较而言，一个 diff 文件非常小 一个 diff 文件简洁地显示所做的修改，从而允许程序补丁的审阅者能快速地评估它 GNU 文档建议这样使用 diff/patch 命令： diff -Naur old_file new_file > diff_file old file 和 new file 部分不是单个文件就是包含文件的目录， r 选项支持递归目录树 3.11.1 命令格式 patch [选项] 补丁文件 3.11.2 常用参数 参数 描述 -p num 忽略几层文件夹 -E 如果发现了空文件，就删除它 -R 取消打过的补丁 3.11.3 常用范例 例一：生成student3.txt和student4.txt的 diff 文件，然后应用 patch 命令更新file1.txt文件，可以使用如下命令： diff -Naur file1.txt file2.txt > patchdiff.txt patch 运行结果如下： ros@ros-course:~/ROS_Course$ diff -Naur student3.txt student4.txt > patchdiff.txt ros@ros-course:~/ROS_Course$ cat patchdiff.txt --- student3.txt 2021-08-14 15:12:11.352661281 +0800 +++ student4.txt 2021-08-14 15:12:25.683063156 +0800 @@ -1,5 +1,3 @@ -li 100 90 1-34-56 qun 234 92 1-34-56 -sun 200 91 2-34-56 +qun 278 90 3-33-46 zhao 252 89 2-73-69 -zhao 452 93 1-23-89 3.12 df命令 df 命令是 disk free 的缩写 df 命令用来检查 linux 服务器的文件系统的磁盘空间占用情况。可以利用该命令来获取硬盘被占用了多少空间，目前还剩下多少空间等信息 3.12.1 命令格式 df [选项] 文件 3.12.2 常用参数 参数 描述 -a 全部文件系统列表 -h 方便阅读方式显示 -i 显示 inode 信息 -T 文件系统类型 -t 只显示选定文件系统的磁盘信息 -x 不显示选定文件系统的磁盘信息 3.12.3 常用范例 例一：显示磁盘使用情况，可以使用如下命令： df 例二：以 inode 模式来显示磁盘使用情况，可以使用如下命令： df -i 例三：列出文件系统的类型，可以使用如下命令： df -T 例四：显示指定类型磁盘，可以使用如下命令： df -t ext4 3.13 du命令 du 命令是 disk usage 的缩写 du 命令也是查看使用空间的，但是与 df 命令不同的是 du 命令是对文件和目录磁盘使用的空间的查看 3.13.1 命令格式 du [选项] 文件 3.13.2 常用参数 参数 描述 -a 显示目录中所有文件的大小。 -b 显示目录或文件大小时，以 byte 为单位。 -c 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 -k 以 KB(1024bytes)为单位输出。 -m 以 MB 为单位输出。 -s 仅显示总计，只列出最后加总的值。 -h 以 K，M，G 为单位，提高信息的可读性。 3.13.3 常用范例 例一：显示指定文件所占空间，以方便阅读的格式显示，可以使用如下命令： du -h file1.txt 运行结果如下： ros@ros-course:~/ROS_Course$ du -h student3.txt 4.0K student3.txt 例二：显示指定目录所占空间，以方便阅读的格式显示，可以使用如下命令： du -h ~/ROS_Course 运行结果如下： ros@ros-course:~/ROS_Course$ du -h ~/ROS_Course 8.0K /home/ros/ROS_Course/test1 8.0K /home/ros/ROS_Course/test 104K /home/ros/ROS_Course 例三：按照空间大小逆序排序显示，使用如下命令： du -h | sort -nr | head -10 运行结果如下： ros@ros-course:~/ROS_Course$ du -h | sort -nr | head -10 104K . 8.0K ./test1 8.0K ./test 3.14 time命令 time 命令常用于测量一个命令的运行时间，包括实际使用时间（real time）、用户态使用时间（the process spent in user mode）、内核态使用时间（the process spent in kernel mode） 实际时间: 从 command 命令行开始执行到运行终止的时间 用户态使用时间：命令执行完成花费的用户 CPU 时间，即命令在用户态中执行时间总和 内核态使用时间：命令执行完成花费的系统 CPU 时间，即命令在核心态中执行时间总和 3.14.1 命令格式 time 命令 3.14.2 常用范例 例一：测量 date 命令运行的时间，可以使用如下命令： time date 运行结果如下： ros@ros-course:~/ROS_Course$ time date 2021年 08月 14日 星期六 16:08:08 CST real 0m0.002s user 0m0.000s sys 0m0.001s 从上面的结果可以到：实际运行时间为 0.002s，用户 cpu 时间为 0.000s，系统 cpu 时间为 0.001s 其中，用户 CPU 时间和系统 CPU 时间之和为 CPU 时间，即命令占用 CPU 执行的时间总和 实际时间要大于 CPU 时间，因为 Linux 是多任务操作系统，往往在执行一条命令时，系统还要处理其它任务new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/ROS1/chapter1.html":{"url":"Markdown/ROS1/chapter1.html","title":"1 基础入门","keywords":"","body":"1 讲义 1 此部分为《机器人操作系统》课程ROS基础单元实践教学参考资料 2 讲义参考赵虚左老师资料：赵虚左讲义new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/ROS1/chapter1-1.html":{"url":"Markdown/ROS1/chapter1-1.html","title":"1.1 ROS基础知识","keywords":"","body":"1 ROS基础知识 第1章 ROS概述与环境搭建 1.1 ROS简介 1.1.1 ROS概念 ROS全称Robot Operating System(机器人操作系统) ROS是适用于机器人的开源元操作系统 ROS集成了大量的工具，库，协议，提供类似OS所提供的功能，简化对机器人的控制 还提供了用于在多台计算机上获取，构建，编写和运行代码的工具和库，ROS在某些方面类似于“机器人框架” ROS设计者将ROS表述为“ROS = Plumbing + Tools + Capabilities + Ecosystem”，即ROS是通讯机制、工具软件包、机器人高层技能以及机器人生态系统的集合体 1.1.2 ROS设计目标 机器人开发的分工思想，实现了不同研发团队间的共享和协作，提升了机器人的研发效率，为了服务“ 分工”，ROS主要设计了如下目标： 代码复用:ROS的目标不是成为具有最多功能的框架，ROS的主要目标是支持机器人技术研发中的代码重用。 分布式:ROS是进程（也称为Nodes）的分布式框架,ROS中的进程可分布于不同主机，不同主机协同工作，从而分散计算压力 松耦合:ROS中功能模块封装于独立的功能包或元功能包，便于分享，功能包内的模块以节点为单位运行，以ROS标准的IO作为接口，开发者不需要关注模块内部实现，只要了解接口规则就能实现复用,实现了模块间点对点的松耦合连接 精简：ROS被设计为尽可能精简，以便为ROS编写的代码可以与其他机器人软件框架一起使用。ROS易于与其他机器人软件框架集成：ROS已与OpenRAVE，Orocos和Player集成。 语言独立性：包括Java，C++，Python等。为了支持更多应用开发和移植，ROS设计为一种语言弱相关的框架结构，使用简洁，中立的定义语言描述模块间的消息接口，在编译中再产生所使用语言的目标文件，为消息交互提供支持，同时允许消息接口的嵌套使用。 易于测试：ROS具有称为rostest的内置单元/集成测试框架，可轻松安装和拆卸测试工具。 大型应用：ROS适用于大型运行时系统和大型开发流程。 丰富的组件化工具包：ROS可采用组件化方式集成一些工具和软件到系统中并作为一个组件直接使用，如RVIZ（3D可视化工具），开发者根据ROS定义的接口在其中显示机器人模型等，组件还包括仿真环境和消息查看工具等 免费且开源：开发者众多，功能包多 1.1.3 ROS发展历程 ROS是一个由来已久、贡献者众多的大型软件项目。在ROS诞生之前，很多学者认为，机器人研究需要一个开放式的协作框架，并且已经有不少类似的项目致力于实现这样的框架。在这些工作中，斯坦福大学在2000年年中开展了一系列相关研究项目，如斯坦福人工智能机器人（STandford AI Robot, STAIR）项目、个人机器人（Personal Robots, PR）项目等，在上述项目中，在研究具有代表性、集成式人工智能系统的过程中，创立了用于室内场景的高灵活性、动态软件系统，其可以用于机器人学研究。 2007年，柳树车库（Willow Garage）提供了大量资源，用于将斯坦福大学机器人项目中的软件系统进行扩展与完善，同时，在无数研究人员的共同努力下，ROS的核心思想和基本软件包逐渐得到完善。 ROS的发行版本（ROS distribution）指ROS软件包的版本，其与Linux的发行版本（如Ubuntu）的概念类似。推出ROS发行版本的目的在于使开发人员可以使用相对稳定的代码库，直到其准备好将所有内容进行版本升级为止。因此，每个发行版本推出后，ROS开发者通常仅对这一版本的bug进行修复，同时提供少量针对核心软件包的改进。 版本特点: 按照英文字母顺序命名，ROS 目前已经发布了ROS1 的终极版本: noetic，并建议后期过渡至 ROS2 版本。noetic 版本之前默认使用的是 Python2，noetic 支持 Python3。 1.2 ROS安装 1.2.1 安装ROS ROS Noetic安装教程见《1.2 Ubuntu安装之后要做的事》 1.2.2 测试ROS ROS 内置了一些小程序，可以通过运行这些小程序以检测 ROS 环境是否可以正常运行 首先启动三个命令行(ctrl + alt + T) 命令行1键入:roscore 命令行2键入:rosrun turtlesim turtlesim_node(此时会弹出图形化界面) 命令行3键入:rosrun turtlesim turtle_teleop_key(在3中可以通过上下左右控制2中乌龟的运动) 最终结果如下所示: 1.3 ROS快速体验 1.3.1 HelloWorld实现简介 以HelloWorld程序为例，实现流程大致如下： 先创建一个工作空间； 再创建一个功能包； 编辑源文件； 编辑配置文件； 编译并执行。 1.创建工作空间并初始化 mkdir -p 自定义空间名称/src cd 自定义空间名称 catkin_make 上述命令，首先会创建一个工作空间以及一个 src 子目录，然后再进入工作空间调用 catkin_make 命令编译。 2.进入 src 创建 ros 包并添加依赖 cd src catkin_create_pkg 自定义ROS包名 roscpp rospy std_msgs 上述命令，会在工作空间下生成一个功能包，该功能包依赖于 roscpp、rospy 与 std_msgs，其中 roscpp 是使用 C++ 实现的库，而 rospy 则是使用 python实现的库，std_msgs 是标准消息库，创建ROS功能包时，一般都会依赖这三个库实现。 1.3.2 HelloWorld实现 1.在demo01_ws/src/helloworld目录下 添加 scripts 目录并编辑 python 文件 cd ros包 mkdir scripts 新建 python 文件: helloworld_p.py #! /usr/bin/env python #step.0 指定解释器 #1.导包 import rospy #2.编写主入口 if __name__ == \"__main__\": #3.初始化ros节点 rospy.init_node(\"hello_p\"); #4.输出日志 rospy.loginfo(\"hello world! by python\"); 2.为 python 文件添加可执行权限 chmod +x helloworld_p.py 3.编辑 ros 包下的 CamkeList.txt 文件 catkin_install_python(PROGRAMS scripts/自定义文件名.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) 4.进入工作空间目录并编译 cd demo01_ws catkin_make 5.进入工作空间目录并执行 先启动命令行1： roscore 再启动命令行2： cd demo01_ws source ./devel/setup.bash rosrun 包名 自定义文件名.py 最终结果: 1.4 ROS集成开发环境搭建 1.4.1 安装终端 在 ROS 中，需要频繁的使用到终端，且可能需要同时开启多个窗口，推荐一款较为好用的终端:Terminator。 1.安装 sudo apt install terminator 2.添加到收藏夹 显示应用程序 ---> 搜索 terminator ---> 右击 选择 添加到收藏夹 3.Terminator 常用快捷键 第一部份：关于在同一个标签内的操作 Alt+Up //移动到上面的终端 Alt+Down //移动到下面的终端 Alt+Left //移动到左边的终端 Alt+Right //移动到右边的终端 Ctrl+Shift+O //水平分割终端 Ctrl+Shift+E //垂直分割终端 Ctrl+Shift+Right //在垂直分割的终端中将分割条向右移动 Ctrl+Shift+Left //在垂直分割的终端中将分割条向左移动 Ctrl+Shift+Up //在水平分割的终端中将分割条向上移动 Ctrl+Shift+Down //在水平分割的终端中将分割条向下移动 Ctrl+Shift+S //隐藏/显示滚动条 Ctrl+Shift+F //搜索 Ctrl+Shift+C //复制选中的内容到剪贴板 Ctrl+Shift+V //粘贴剪贴板的内容到此处 Ctrl+Shift+W //关闭当前终端 Ctrl+Shift+Q //退出当前窗口，当前窗口的所有终端都将被关闭 Ctrl+Shift+X //最大化显示当前终端 Ctrl+Shift+Z //最大化显示当前终端并使字体放大 Ctrl+Shift+N or Ctrl+Tab //移动到下一个终端 Ctrl+Shift+P or Ctrl+Shift+Tab //Crtl+Shift+Tab 移动到之前的一个终端 第二部份：有关各个标签之间的操作 F11 //全屏开关 Ctrl+Shift+T //打开一个新的标签 Ctrl+PageDown //移动到下一个标签 Ctrl+PageUp //移动到上一个标签 Ctrl+Shift+PageDown //将当前标签与其后一个标签交换位置 Ctrl+Shift+PageUp //将当前标签与其前一个标签交换位置 Ctrl+Plus (+) //增大字体 Ctrl+Minus (-) //减小字体 Ctrl+Zero (0) //恢复字体到原始大小 Ctrl+Shift+R //重置终端状态 Ctrl+Shift+G //重置终端状态并clear屏幕 Super+g //绑定所有的终端，以便向一个输入能够输入到所有的终端 Super+Shift+G //解除绑定 Super+t //绑定当前标签的所有终端，向一个终端输入的内容会自动输入到其他终端 Super+Shift+T //解除绑定 Ctrl+Shift+I //打开一个窗口，新窗口与原来的窗口使用同一个进程 Super+i //打开一个新窗口，新窗口与原来的窗口使用不同的进程 1.4.2 安装VScode VSCode 全称 Visual Studio Code，是微软出的一款轻量级代码编辑器，免费、开源而且功能强大。它支持几乎所有主流的程序语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，并针对网页开发和云端应用开发做了优化。软件跨平台支持 Win、Mac 以及 Linux。 1.下载 vscode 下载:https://code.visualstudio.com/docs?start=true 历史版本下载链接: https://code.visualstudio.com/updates 2.vscode 安装与卸载 2.1 安装 方式1:双击安装即可(或右击选择安装) 方式2:sudo dpkg -i xxxx.deb 2.2 卸载 sudo dpkg --purge code 3.vscode 集成 ROS 插件 使用 VScode 开发 ROS 程序，需要先安装一些插件 4.vscode 使用_基本配置 4.1 创建 ROS 工作空间 mkdir -p xxx_ws/src(必须得有 src) cd xxx_ws catkin_make 4.2 启动 vscode 进入 xxx_ws 启动 vscode cd xxx_ws code . 4.3 vscode 中编译 ros 快捷键 ctrl + shift + B 调用编译，选择:catkin_make:build 可以点击配置设置为默认，修改.vscode/tasks.json 文件 { // 有关 tasks.json 格式的文档，请参见 // https://go.microsoft.com/fwlink/?LinkId=733558 \"version\": \"2.0.0\", \"tasks\": [ { \"label\": \"catkin_make:debug\", //代表提示的描述性信息 \"type\": \"shell\", //可以选择shell或者process,如果是shell代码是在shell里面运行一个命令，如果是process代表作为一个进程来运行 \"command\": \"catkin_make\",//这个是我们需要运行的命令 \"args\": [],//如果需要在命令后面加一些后缀，可以写在这里，比如-DCATKIN_WHITELIST_PACKAGES=“pac1;pac2” \"group\": {\"kind\":\"build\",\"isDefault\":true}, \"presentation\": { \"reveal\": \"always\"//可选always或者silence，代表是否输出信息 }, \"problemMatcher\": \"$msCompile\" } ] } 4.4 创建 ROS 功能包 选定 src 右击 ---> create catkin package 设置包名 添加依赖 4.5 python 实现 在 功能包 下新建 scripts 文件夹，添加 python 文件，并添加可执行权限 #! /usr/bin/env python \"\"\" Python 版本的 HelloVScode，执行在控制台输出 HelloVScode 实现: 1.导包 2.初始化 ROS 节点 3.日志输出 HelloWorld \"\"\" import rospy # 1.导包 if __name__ == \"__main__\": rospy.init_node(\"Hello_Vscode_p\") # 2.初始化 ROS 节点 rospy.loginfo(\"Hello VScode, 我是 Python ....\") #3.日志输出 HelloWorld 4.6 配置 CMakeLists.txt Python 配置: catkin_install_python(PROGRAMS scripts/自定义文件名.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) 4.7 编译执行 编译: ctrl + shift + B 执行: 和之前一致，只是可以在 VScode 中添加终端，首先执行:source ./devel/setup.bash 1.4.3 launch文件演示 1.需求 一个程序中可能需要启动多个节点，比如:ROS 内置的小乌龟案例，如果要控制乌龟运动，要启动多个窗口，分别启动 roscore、乌龟界面节点、键盘控制节点。如果每次都调用 rosrun 逐一启动，显然效率低下，如何优化? 官方给出的优化策略是使用 launch 文件，可以一次性启动多个 ROS 节点。 2.实现 选定功能包右击 ---> 添加 launch 文件夹 选定 launch 文件夹右击 ---> 添加 launch 文件 编辑 launch 文件内容 --> 运行 launch 文件 roslaunch hello_vscode start_turtle.launch 运行结果: 一次性启动了多个节点 1.5 ROS架构 1.5.1 ROS文件系统 ROS文件系统级指的是在硬盘上ROS源代码的组织形式，其结构大致可以如下图所示： WorkSpace --- 自定义的工作空间 |--- build:编译空间，用于存放CMake和catkin的缓存信息、配置信息和其他中间文件。 |--- devel:开发空间，用于存放编译后生成的目标文件，包括头文件、动态&静态链接库、可执行文件等。 |--- src: 源码 |-- package：功能包(ROS基本单元)包含多个节点、库与配置文件，包名所有字母小写，只能由字母、数字与下划线组成 |-- CMakeLists.txt 配置编译规则，比如源文件、依赖项、目标文件 |-- package.xml 包信息，比如:包名、版本、作者、依赖项...(以前版本是 manifest.xml) |-- scripts 存储python文件 |-- src 存储C++源文件 |-- include 头文件 |-- msg 消息通信格式文件 |-- srv 服务通信格式文件 |-- action 动作格式文件 |-- launch 可一次性运行多个节点 |-- config 配置信息 |-- CMakeLists.txt: 编译的基本配置 ROS 文件系统中部分目录和文件前面编程中已经有所涉及，比如功能包的创建、src目录下cpp文件的编写、scripts目录下python文件的编写、launch目录下launch文件的编写，并且也配置了 package.xml 与 CMakeLists.txt 文件。其他目录下的内容后面教程将会再行介绍，当前我们主要介绍: package.xml 与 CMakeLists.txt 这两个配置文件。 1.package.xml 该文件定义有关软件包的属性，例如软件包名称，版本号，作者，维护者以及对其他catkin软件包的依赖性。请注意，该概念类似于旧版 rosbuild 构建系统中使用的manifest.xml文件。 demo01_hello_vscode 0.0.0 The demo01_hello_vscode package Jane Doe --> xuzuo TODO http://wiki.ros.org/demo01_hello_vscode --> Jane Doe --> roscpp --> roscpp --> roscpp --> message_generation --> message_generation --> catkin --> message_runtime --> gtest --> doxygen --> catkin roscpp rospy std_msgs roscpp rospy std_msgs roscpp rospy std_msgs 2.CMakelists.txt 文件CMakeLists.txt是CMake构建系统的输入，用于构建软件包。任何兼容CMake的软件包都包含一个或多个CMakeLists.txt文件，这些文件描述了如何构建代码以及将代码安装到何处。 cmake_minimum_required(VERSION 3.0.2) #所需 cmake 版本 project(demo01_hello_vscode) #包名称，会被 ${PROJECT_NAME} 的方式调用 ## Compile as C++11, supported in ROS Kinetic and newer # add_compile_options(-std=c++11) ## Find catkin macros and libraries ## if COMPONENTS list like find_package(catkin REQUIRED COMPONENTS xyz) ## is used, also find other catkin packages #设置构建所需要的软件包 find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs ) ## System dependencies are found with CMake's conventions #默认添加系统依赖 # find_package(Boost REQUIRED COMPONENTS system) ## Uncomment this if the package has a setup.py. This macro ensures ## modules and global scripts declared therein get installed ## See http://ros.org/doc/api/catkin/html/user_guide/setup_dot_py.html # 启动 python 模块支持 # catkin_python_setup() ################################################ ## Declare ROS messages, services and actions ## ## 声明 ROS 消息、服务、动作... ## ################################################ ## To declare and build messages, services or actions from within this ## package, follow these steps: ## * Let MSG_DEP_SET be the set of packages whose message types you use in ## your messages/services/actions (e.g. std_msgs, actionlib_msgs, ...). ## * In the file package.xml: ## * add a build_depend tag for \"message_generation\" ## * add a build_depend and a exec_depend tag for each package in MSG_DEP_SET ## * If MSG_DEP_SET isn't empty the following dependency has been pulled in ## but can be declared for certainty nonetheless: ## * add a exec_depend tag for \"message_runtime\" ## * In this file (CMakeLists.txt): ## * add \"message_generation\" and every package in MSG_DEP_SET to ## find_package(catkin REQUIRED COMPONENTS ...) ## * add \"message_runtime\" and every package in MSG_DEP_SET to ## catkin_package(CATKIN_DEPENDS ...) ## * uncomment the add_*_files sections below as needed ## and list every .msg/.srv/.action file to be processed ## * uncomment the generate_messages entry below ## * add every package in MSG_DEP_SET to generate_messages(DEPENDENCIES ...) ## Generate messages in the 'msg' folder # add_message_files( # FILES # Message1.msg # Message2.msg # ) ## Generate services in the 'srv' folder # add_service_files( # FILES # Service1.srv # Service2.srv # ) ## Generate actions in the 'action' folder # add_action_files( # FILES # Action1.action # Action2.action # ) ## Generate added messages and services with any dependencies listed here # 生成消息、服务时的依赖包 # generate_messages( # DEPENDENCIES # std_msgs # ) ################################################ ## Declare ROS dynamic reconfigure parameters ## ## 声明 ROS 动态参数配置 ## ################################################ ## To declare and build dynamic reconfigure parameters within this ## package, follow these steps: ## * In the file package.xml: ## * add a build_depend and a exec_depend tag for \"dynamic_reconfigure\" ## * In this file (CMakeLists.txt): ## * add \"dynamic_reconfigure\" to ## find_package(catkin REQUIRED COMPONENTS ...) ## * uncomment the \"generate_dynamic_reconfigure_options\" section below ## and list every .cfg file to be processed ## Generate dynamic reconfigure parameters in the 'cfg' folder # generate_dynamic_reconfigure_options( # cfg/DynReconf1.cfg # cfg/DynReconf2.cfg # ) ################################### ## catkin specific configuration ## ## catkin 特定配置## ################################### ## The catkin_package macro generates cmake config files for your package ## Declare things to be passed to dependent projects ## INCLUDE_DIRS: uncomment this if your package contains header files ## LIBRARIES: libraries you create in this project that dependent projects also need ## CATKIN_DEPENDS: catkin_packages dependent projects also need ## DEPENDS: system dependencies of this project that dependent projects also need # 运行时依赖 catkin_package( # INCLUDE_DIRS include # LIBRARIES demo01_hello_vscode # CATKIN_DEPENDS roscpp rospy std_msgs # DEPENDS system_lib ) ########### ## Build ## ########### ## Specify additional locations of header files ## Your package locations should be listed before other locations # 添加头文件路径，当前程序包的头文件路径位于其他文件路径之前 include_directories( # include ${catkin_INCLUDE_DIRS} ) ## Declare a C++ library # 声明 C++ 库 # add_library(${PROJECT_NAME} # src/${PROJECT_NAME}/demo01_hello_vscode.cpp # ) ## Add cmake target dependencies of the library ## as an example, code may need to be generated before libraries ## either from message generation or dynamic reconfigure # 添加库的 cmake 目标依赖 # add_dependencies(${PROJECT_NAME} ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) ## Declare a C++ executable ## With catkin_make all packages are built within a single CMake context ## The recommended prefix ensures that target names across packages don't collide # 声明 C++ 可执行文件 add_executable(Hello_VSCode src/Hello_VSCode.cpp) ## Rename C++ executable without prefix ## The above recommended prefix causes long target names, the following renames the ## target back to the shorter version for ease of user use ## e.g. \"rosrun someones_pkg node\" instead of \"rosrun someones_pkg someones_pkg_node\" #重命名c++可执行文件 # set_target_properties(${PROJECT_NAME}_node PROPERTIES OUTPUT_NAME node PREFIX \"\") ## Add cmake target dependencies of the executable ## same as for the library above #添加可执行文件的 cmake 目标依赖 add_dependencies(Hello_VSCode ${${PROJECT_NAME}_EXPORTED_TARGETS} ${catkin_EXPORTED_TARGETS}) ## Specify libraries to link a library or executable target against #指定库、可执行文件的链接库 target_link_libraries(Hello_VSCode ${catkin_LIBRARIES} ) ############# ## Install ## ## 安装 ## ############# # all install targets should use catkin DESTINATION variables # See http://ros.org/doc/api/catkin/html/adv_user_guide/variables.html ## Mark executable scripts (Python etc.) for installation ## in contrast to setup.py, you can choose the destination #设置用于安装的可执行脚本 catkin_install_python(PROGRAMS scripts/Hi.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) ## Mark executables for installation ## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_executables.html # install(TARGETS ${PROJECT_NAME}_node # RUNTIME DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} # ) ## Mark libraries for installation ## See http://docs.ros.org/melodic/api/catkin/html/howto/format1/building_libraries.html # install(TARGETS ${PROJECT_NAME} # ARCHIVE DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION} # LIBRARY DESTINATION ${CATKIN_PACKAGE_LIB_DESTINATION} # RUNTIME DESTINATION ${CATKIN_GLOBAL_BIN_DESTINATION} # ) ## Mark cpp header files for installation # install(DIRECTORY include/${PROJECT_NAME}/ # DESTINATION ${CATKIN_PACKAGE_INCLUDE_DESTINATION} # FILES_MATCHING PATTERN \"*.h\" # PATTERN \".svn\" EXCLUDE # ) ## Mark other files for installation (e.g. launch and bag files, etc.) # install(FILES # # myfile1 # # myfile2 # DESTINATION ${CATKIN_PACKAGE_SHARE_DESTINATION} # ) ############# ## Testing ## ############# ## Add gtest based cpp test target and link libraries # catkin_add_gtest(${PROJECT_NAME}-test test/test_demo01_hello_vscode.cpp) # if(TARGET ${PROJECT_NAME}-test) # target_link_libraries(${PROJECT_NAME}-test ${PROJECT_NAME}) # endif() ## Add folders to be run by python nosetests # catkin_add_nosetests(test) 1.5.2 ROS文件系统相关命令 ROS 的文件系统本质上都还是操作系统文件，我们可以使用Linux命令来操作这些文件，不过，在ROS中为了更好的用户体验，ROS专门提供了一些类似于Linux的命令，这些命令较之于Linux原生命令，更为简介、高效。文件操作，无外乎就是增删改查与执行等操作，接下来，我们就从这五个维度，来介绍ROS文件系统的一些常用命令。 1.增 catkin_create_pkg 自定义包名 依赖包 === 创建新的ROS功能包 sudo apt install xxx === 安装 ROS功能包 2.删 sudo apt purge xxx ==== 删除某个功能包 3.查 rospack list === 列出所有功能包 rospack find 包名 === 查找某个功能包是否存在，如果存在返回安装路径 roscd 包名 === 进入某个功能包 rosls 包名 === 列出某个包下的文件 apt search xxx === 搜索某个功能包 4.改 rosed 包名 文件名 === 修改功能包文件 需要安装 vim 比如:rosed turtlesim Color.msg 5.执行 5.1 roscore roscore === 是 ROS 的系统先决条件节点和程序的集合， 必须运行 roscore 才能使 ROS 节点进行通信。 roscore 将启动: ros master ros 参数服务器 rosout 日志节点 用法: roscore 或(指定端口号) roscore -p xxxx 5.2 rosrun rosrun 包名 可执行文件名 === 运行指定的ROS节点 rosrun turtlesim turtlesim_node 5.3 roslaunch roslaunch 包名 launch文件名 === 执行某个包下的 launch 文件 1.5.3 ROS计算图 1.计算图简介 前面介绍的是ROS文件结构，是磁盘上 ROS 程序的存储结构，是静态的，而 ros 程序运行之后，不同的节点之间是错综复杂的，ROS 中提供了一个实用的工具:rqt_graph。 rqt_graph能够创建一个显示当前系统运行情况的动态图形。ROS 分布式系统中不同进程需要进行数据交互，计算图可以以点对点的网络形式表现数据交互过程。rqt_graph是rqt程序包中的一部分。 2.计算图安装 如果前期把所有的功能包（package）都已经安装完成，则直接在终端窗口中输入 rosrun rqt_graph rqt_graph 如果未安装则在终端（terminal）中输入 $ sudo apt install ros-noetic-rqt $ sudo apt install ros-noetic-rqt-common-plugins 3.计算图演示 接下来以 ROS 内置的小乌龟案例来演示计算图 首先，按照前面所示，运行案例 然后，启动新终端，键入: rqt_graph 或 rosrun rqt_graph rqt_graph，可以看到网络拓扑图，该图可以显示不同节点之间的关系。 1.6 本章小结 第2章 ROS通信机制 2.1 话题通信 2.1.1 话题通信理论模型 话题通信实现模型是比较复杂的，该模型如下图所示,该模型中涉及到三个角色: ROS Master (管理者) Talker (发布者) Listener (订阅者) ROS Master 负责保管 Talker 和 Listener 注册的信息，并匹配话题相同的 Talker 与 Listener，帮助 Talker 与 Listener 建立连接，连接建立后，Talker 可以发布消息，且发布的消息会被 Listener 订阅。 整个流程由以下步骤实现: 0.Talker注册 Talker启动后，会通过RPC在 ROS Master 中注册自身信息，其中包含所发布消息的话题名称。ROS Master 会将节点的注册信息加入到注册表中。 1.Listener注册 Listener启动后，也会通过RPC在 ROS Master 中注册自身信息，包含需要订阅消息的话题名。ROS Master 会将节点的注册信息加入到注册表中。 2.ROS Master实现信息匹配 ROS Master 会根据注册表中的信息匹配Talker 和 Listener，并通过 RPC 向 Listener 发送 Talker 的 RPC 地址信息。 3.Listener向Talker发送请求 Listener 根据接收到的 RPC 地址，通过 RPC 向 Talker 发送连接请求，传输订阅的话题名称、消息类型以及通信协议(TCP/UDP)。 4.Talker确认请求 Talker 接收到 Listener 的请求后，也是通过 RPC 向 Listener 确认连接信息，并发送自身的 TCP 地址信息。 5.Listener与Talker件里连接 Listener 根据步骤4 返回的消息使用 TCP 与 Talker 建立网络连接。 6.Talker向Listener发送消息 2.1.2 话题通信基本操作 在plumbing_pub_sub功能包中创建scripts文件夹 在scripts文件夹中创建python文件demo01_pub_p.py，demo02_sub_p.py 添加可执行权限chmod +x *.py 在CMakeLists中修改文件名称，放开注释 编译 启动roscore 运行ros节点rosrun plumbing_pub_sub demo01_pub_p.py 运行ros节点rosrun plumbing_pub_sub demo02_sub_p.py 发布方 #! /usr/bin/env python #指定解释器 import rospy #导包 from std_msgs.msg import String #发布消息的类型 \"\"\" 使用python实现消息发布 1.导包 2.初始化ros节点 3.创建发布者对象 4.编写发布逻辑并发布数据 \"\"\" if __name__ == \"__main__\": #2.初始化ros节点，调用rospy中的函数 rospy.init_node(\"sanDai\") #传入节点名称name #init_node函数定义 #def init_node(name,argv=None,anonymous=False,log_level=None, #disable_rostime=False,disable_rosout=False,disable_signals=False,xmlrpc_port=0,tcpros_port=0): #3.创建发布者对象 pub = rospy.Publisher(\"che\",String,queue_size =10) #括号内给定Publishier函数的参数，其中queue_size为消息堆叠容量是10,\"che\"为话题名称 #4.编写发布逻辑并发布数据 #创建数据 msg = String() #指定发布频率 rate = rospy.Rate(1) #设置计数器 count = 0 #使用循环发布数据 rospy.sleep(3) while not rospy.is_shutdown(): #如果节点关闭自增1 count += 1 msg.data = \"hello\" + str(count) #发布数据 pub.publish(msg) rospy.loginfo(\"发布的数据:%s\",msg.data) #日志输出 rate.sleep() #休眠 订阅方 #! /usr/bin/env python #指定解释器 import rospy #导包 from std_msgs.msg import String #导包 \"\"\" 订阅实现流程： 1.导包 2.初始化ros节点 3.创建订阅者对象 4.回调函数处理数据 5.spin() \"\"\" #创建回调函数 def doMsg(msg): rospy.loginfo(\"我订阅的数据:%s\",msg.data) #日志输出 if __name__ ==\"__main__\": #2.初始化ros节点 rospy.init_node(\"huahua\") #3.创建订阅者对象 sub = rospy.Subscriber(\"che\",String,doMsg,queue_size = 10)#传入参数name，指定订阅消息类型data_class，回调函数callback，消息堆叠数queue_size #4.回调函数处理数据 #5.spin()，回调函数需要循环执行时加 rospy.spin() 2.1.3 话题通信自定义msg 在 ROS 通信协议中，数据载体是一个较为重要组成部分，ROS 中通过 std_msgs 封装了一些原生的数据类型,比如:String、Int32、Int64、Char、Bool、Empty.... 但是，这些数据一般只包含一个 data 字段，结构的单一意味着功能上的局限性，当传输一些复杂的数据，比如: 激光雷达的信息... std_msgs 由于描述性较差而显得力不从心，这种场景下可以使用自定义的消息类型 msgs只是简单的文本文件，每行具有字段类型和字段名称，可以使用的字段类型有： int8, int16, int32, int64 (或者无符号类型: uint*) float32, float64 string time, duration other msg files variable-length array[] and fixed-length array[C] 创建自定义消息，该消息包含人的信息:姓名、身高、年龄等流程： 按照固定格式创建 msg 文件 编辑配置文件 编译生成可以被 Python 调用的中间文件 具体步骤： 定义msg文件 在功能包下创建msg文件夹，添加文件Person.msg，在文件中编写以下内容 string name uint16 age float64 height 编辑配置文件 package.xml中添加编译依赖与执行依赖: message_generation message_runtime CMakeLists.txt编辑 msg 相关配置: find_package(catkin REQUIRED COMPONENTS roscpp rospy std_msgs message_generation ) 需要加入 message_generation,必须有 std_msgs 配置msg源文件 add_message_files( FILES Person.msg ) 生成消息时依赖于 std_msgs generate_messages( DEPENDENCIES std_msgs ) 执行时依赖 #执行时依赖,添加message_runtime catkin_package( # INCLUDE_DIRS include # LIBRARIES demo02_talker_listener CATKIN_DEPENDS roscpp rospy std_msgs message_runtime # DEPENDS system_lib ) 编译 2.1.4 话题通信自定义msg调用 需求: 编写发布订阅实现，要求发布方以1HZ(每秒1次)的频率发布自定义消息，订阅方订阅自定义消息并将消息内容打印输出。 分析: 在模型实现中，ROS master 不需要实现，而连接的建立也已经被封装了，需要关注的关键点有三个: 发布方 接收方 数据 0.vscode配置 为了方便代码提示以及误抛异常，需要先配置 vscode，将前面生成的 python 文件路径配置进 settings.json，在终端中通过pwd获取路径，将路径粘贴到settings.json文件中 { \"python.autoComplete.extraPaths\": [ \"/opt/ros/noetic/lib/python3/dist-packages\", \"/home/jayson/demo/demo03_ws/devel/lib/python3/dist-packages/plumbing_pub_sub/msg\" ], \"python.analysis.extraPaths\": [ \"/opt/ros/noetic/lib/python3/dist-packages\" ] } 其中\"/home/jayson/demo/demo03_ws/devel/lib/python3/dist-packages/plumbing_pub_sub/msg\"为粘贴的文件路径 发布方 #! /usr/bin/env python import rospy from plumbing_pub_sub.msg import Person \"\"\" 发布方：发布人的消息 1.导包 2.初始化ros节点 3.创建发布者对象 4.组织发布逻辑并发布数据 \"\"\" if __name__ == \"__main__\": #2.初始化ros节点 rospy.init_node(\"daMa\") #3.创建发布者对象 pub = rospy.Publisher(\"jiaoSheTou\",Person,queue_size=10) #4.组织发布逻辑并发布数据 #4-1创建Person数据 p =Person() p.name = \"奥特曼\" p.age = 8 p.height = 1.85 #4-2创建Rate对象 rate = rospy.Rate(1) #4-3循环发布数据 while not rospy.is_shutdown(): pub.publish(p) rospy.loginfo(\"发布的消息:%s,%d,%.2f\",p.name,p.age,p.height) rate.sleep() 订阅方 #! /usr/bin/env python import rospy from plumbing_pub_sub.msg import Person \"\"\" 订阅方：订阅人的消息 1.导包 2.初始化ros节点 3.创建订阅者对象 4.通过回调函数处理订阅数据 5.spin() \"\"\" def doPerson(p): rospy.loginfo(\"小伙子的数据:%s,%d,%.2f\",p.name,p.age,p.height) if __name__ == \"__main__\": #2.初始化ros节点 rospy.init_node(\"daYe\") #3.创建订阅者对象 sub = rospy.Subscriber(\"jiaoSheTou\",Person,doPerson) #4.通过回调函数处理订阅数据 #5.spin() rospy.spin() 权限设置 终端下进入 scripts 执行:chmod +x *.py 配置 CMakeLists.txt catkin_install_python(PROGRAMS scripts/demo01_pub_p.py scripts/demo_02_sub_p.py scripts/demo03_pub_person_p.py scripts/demo04_sub_person_p.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) 执行 启动 roscore; 启动发布节点; 启动订阅节点。 2.2 服务通信 2.2.1 服务通信理论模型 服务通信较之于话题通信更简单些，理论模型如下图所示，该模型中涉及到三个角色: ROS master(管理者) Server(服务端) Client(客户端) ROS Master 负责保管 Server 和 Client 注册的信息，并匹配话题相同的 Server 与 Client ，帮助 Server 与 Client 建立连接，连接建立后，Client 发送请求信息，Server 返回响应信息。 整个流程由以下步骤实现: 0.Server注册 Server 启动后，会通过RPC在 ROS Master 中注册自身信息，其中包含提供的服务的名称。ROS Master 会将节点的注册信息加入到注册表中。 1.Client注册 Client 启动后，也会通过RPC在 ROS Master 中注册自身信息，包含需要请求的服务的名称。ROS Master 会将节点的注册信息加入到注册表中。 2.ROS Master实现信息匹配 ROS Master 会根据注册表中的信息匹配Server和 Client，并通过 RPC 向 Client 发送 Server 的 TCP 地址信息。 3.Client发送请求 Client 根据步骤2 响应的信息，使用 TCP 与 Server 建立网络连接，并发送请求数据。 4.Server发送响应 Server 接收、解析请求的数据，并产生响应结果返回给 Client。 2.2.2 服务通信自定义srv 需求: 服务通信中，客户端提交两个整数至服务端，服务端求和并响应结果到客户端，请创建服务器与客户端通信的数据载体。 流程: srv 文件内的可用数据类型与 msg 文件一致，且定义 srv 实现流程与自定义 msg 实现流程类似: 按照固定格式创建srv文件 编辑配置文件 编译生成中间文件 具体步骤： 在工作空间中创建srv文件夹，定义srv文件AddInts.srv int32 num1 int32 num2 --- int32 sum 编辑配置文件 package.xml中添加编译依赖与执行依赖message_generation message_runtime CMakeLists.txt编辑 srv 相关配置add_service_files( FILES AddInts.srv ) 其中部分配置在话题通信中已完成。 编译 2.2.3 服务通信自定义srv调用 需求:编写服务通信，客户端提交两个整数至服务端，服务端求和并响应结果到客户端。 分析: 在模型实现中，ROS master 不需要实现，而连接的建立也已经被封装了，需要关注的关键点有三个: 服务端 客户端 数据 流程： 编写服务端实现； 编写客户端实现； 为python文件添加可执行权限 编辑配置文件 编译并执行 具体步骤： vscode配置 配置settings.json文件，复制dist-packages的绝对路径到settings.json文件中 \"python.autoComplete.extraPaths\": [ \"/opt/ros/noetic/lib/python3/dist-packages\", \"/home/jayson/demo/demo03_ws/devel/lib/python3/dist-packages\" ] 服务端 #! /usr/bin/env python import rospy #导包 from plumbing_server_client.srv import AddInts,AddIntsRequest,AddIntsResponse #from plumbing_server_client.srv import * 两种不同的导包方式 \"\"\" 服务端：解析客户端请求，产生响应。 1.导包 2.初始化ros节点 3.创建服务端对象 4.编写处理逻辑（回调函数） 5.spin() \"\"\" #参数：封装了请求数据 #返回值：响应数据 def doNum(request): #1.解析提交的两个整数 num1 = request.num1 num2 = request.num2 #2.求和 sum = num1 +num2 #3.将结果sum封装进响应 response = AddIntsResponse() response.sum = sum rospy.loginfo(\"服务器解析的数据num1 = %d, num2 = %d, 响应的结果: sum = %d\",num1,num2,sum) return response if __name__ == \"__main__\": #2.初始化ros节点 rospy.init_node(\"heishui\") #3.创建服务端对象 server = rospy.Service(\"addInts\",AddInts,doNum) #三个参数分别为：话题名称，消息对应的类型，回调函数 rospy.loginfo(\"服务器已经启动了\") #输出日志 #4.编写处理逻辑（回调函数） #5.spin() rospy.spin() 客户端 #! /usr/bin/env python import rospy from plumbing_server_client.srv import AddInts,AddIntsRequest,AddIntsResponse import sys #“sys”即“system”，“系统”之意。该模块提供了一些接口，用于访问 Python 解释器自身使用和维护的变量，同时模块中还提供了一部分函数，可以与解释器进行比较深度的交互。 \"\"\" 客户端：组织并提交请求，处理服务端响应 1.导包 2.初始化ros节点 3.创建客户端对象 4.组织请求数据，并发送请求 5.处理响应 优化实现： 可以在执行节点时，动态传入参数 问题： 客户端先于服务端启动，会抛出异常 需要： 客户端先于服务员启动，不抛出异常而是挂起，等待服务启动后，再次发送请求 实现： ROS中内置了相关函数,这些函数可以判断服务器状态,如果服务没有启动,那么就可以让客户端挂起 方案1: client.wais_for_service() 方案2: rospy.wait_for_service(\"话题名称\") \"\"\" if __name__ == \"__main__\": #判断参数长度 if len(sys.argv) != 3: #“argv”即“argument value”的简写，是一个列表对象，其中存储的是在命令行调用 Python 脚本时提供的“命令行参数”。 #这个列表中的第一个参数是被调用的脚本名称，包含传入的两个参数，正常情况下共有三个参数。 rospy.logerr(\"传入的参数个数不对。\") sys.exit(1) #有错误退出 #sys.exit()会引发一个异常：SystemExit，如果这个异常没有被捕获，那么python解释器将会退出。如果有捕获此异常的代码，那么这些代码还是会执行。捕获这个异常可以做一些额外的清理工作。0为正常退出，其他数值（1-127）为不正常，可抛异常事件供捕获。 #2.初始化ros节点 rospy.init_node(\"erHei\") #3.创建客户端对象 client = rospy.ServiceProxy(\"addInts\",AddInts) #两个参数分别为：话题名称，消息类型 rospy.loginfo(\"客户端对象创建\") #4.组织请求数据，并发送请求 #解析传入的参数 num1 = int(sys.argv[1]) num2 = int(sys.argv[2]) #等待服务器启动,第一种实现策略： #client.wait_for_service() #第二种实现策略 rospy.wait_for_service(\"addInts\") response = client.call(num1,num2) #5.处理响应 rospy.loginfo(\"响应的数据:%d\",response.sum) 设置权限 终端下进入 scripts 执行:chmod +x *.py 配置CMakeLists.txt catkin_install_python(PROGRAMS scripts/demo01_server_p.py scripts/demo02_client_p.py DESTINATION ${CATKIN_PACKAGE_BIN_DESTINATION} ) 执行 流程: 需要先启动服务:rosrun 包名 服务 rosrun plumbing_server_client demo01_server_p.py 然后再调用客户端 :rosrun 包名 客户端 参数1 参数2 rosrun plumbing_server_client demo02_client_p.py 12 34 结果: 会根据提交的数据响应相加后的结果。 2.3 参数服务器 2.3.1 参数服务器理论模型 参数服务器实现是最为简单的，该模型如下图所示,该模型中涉及到三个角色: ROS Master (管理者) Talker (参数设置者) Listener (参数调用者) ROS Master 作为一个公共容器保存参数，Talker 可以向容器中设置参数，Listener 可以获取参数。 整个流程由以下步骤实现: Talker 设置参数 Talker 通过 RPC 向参数服务器发送参数(包括参数名与参数值)，ROS Master 将参数保存到参数列表中。 Listener 获取参数 Listener 通过 RPC 向参数服务器发送参数查找请求，请求中包含要查找的参数名。 ROS Master 向 Listener 发送参数值 ROS Master 根据步骤2请求提供的参数名查找参数值，并将查询结果通过 RPC 发送给 Listener。 2.3.2 参数操作 需求:实现参数服务器参数的增删改查操作。 参数服务器新增(修改)参数 #! /usr/bin/env python import rospy \"\"\" 演示参数的新增与修改 需求：在参数服务器中设置机器人属性，型号，半径 实现： rospy.set_param() \"\"\" if __name__ == \"__main__\": #初始化ros节点 rospy.init_node(\"param_set_p\") #新增参数 rospy.set_param(\"type_p\",\"xiaoHuangChe\") rospy.set_param(\"radius_p\",0.15) #修改参数 rospy.set_param(\"radius_p\",0.2) #两个语句键一样，后面语句将前面语句的值覆盖 参数服务器获取参数 #! /usr/bin/env python import rospy \"\"\" 演示参数查询 get_param(键,默认值) 当键存在时，返回对应的值，如果不存在返回默认值 get_param_cached 和get_param 使用一致，只是效率高 get_param_names 获取所有的参数的键的集合 has_param 判断是否包含某个键 search_param 查找某个键，并返回完整的键名 \"\"\" if __name__ == \"__main__\": rospy.init_node(\"get_param_p\") #1.get_param radius = rospy.get_param(\"radius_p\",0.5) radius2 = rospy.get_param(\"radius_p_xxx\",0.5) rospy.loginfo(\"radius= %.2f\",radius) rospy.loginfo(\"radius2= %.2f\",radius2) #2.get_param_cached radius3 = rospy.get_param_cached(\"radius_p\",0.5) radius4 = rospy.get_param_cached(\"radius_p_xxx\",0.5) rospy.loginfo(\"radius3= %.2f\",radius3) rospy.loginfo(\"radius4= %.2f\",radius4) #3.get_param_names names = rospy.get_param_names() for name in names: rospy.loginfo(\"name = %s\",name) #4.has_param flag1 = rospy.has_param(\"radius_p\") if flag1: rospy.loginfo(\"radius_p 存在\") else: rospy.loginfo(\"radius_p 不存在\") flag2 = rospy.has_param(\"radius_p_xxx\") if flag2: rospy.loginfo(\"radius_p_xxx 存在\") else: rospy.loginfo(\"radius_p_xxx 不存在\") #5.search_param key = rospy.search_param(\"radius_p\") rospy.loginfo(\"key = %s\",key) 参数服务器删除参数 #! usr/bin/env python import rospy \"\"\" 演示参数删除： delete_param() \"\"\" if __name__ ==\"__main__\": rospy.init_node(\"del_param_p\") try: #用于优化，捕获异常给出提示 #删除参数 rospy.delete_param(\"radius_p\") except Exception as e: rospy.loginfo(\"被删除的参数不存在\") 2.4 常用命令 2.4.1 rosnode rosnode 是用于获取节点信息的命令 rosnode ping 测试到节点的连接状态 rosnode list 列出活动节点 rosnode info 打印节点信息 rosnode machine 列出指定设备上节点 rosnode kill 杀死某个节点 rosnode cleanup 清除不可连接的节点 rosnode ping 测试节点的连接状态 rosnode list 列出活动节点 rosnode info 打印节点信息 rosnode machine 列出指定设备上的节点 rosnode kill 杀死某个正在运行的节点 rosnode cleanup 清除无用节点，启动乌龟节点，然后 ctrl + c 关闭，该节点并没被彻底清除，通过rosnode list仍可列出被关闭的节点，可以使用 cleanup 清除节点 2.4.2 rostopic rostopic包含rostopic命令行工具，用于显示有关ROS 主题的调试信息，包括发布者，订阅者，发布频率和ROS消息。它还包含一个实验性Python库，用于动态获取有关主题的信息并与之交互。 rostopic bw 显示主题使用的带宽 rostopic delay 显示带有 header 的主题延迟 rostopic echo 打印消息到屏幕 rostopic find 根据类型查找主题 rostopic hz 显示主题的发布频率 rostopic info 显示主题相关信息 rostopic list 显示所有活动状态下的主题 rostopic pub 将数据发布到主题 rostopic type 打印主题类型 rostopic list 显示当前正在活跃的话题 rostopic echo 获取指定话题当前发布的消息 rostopic pub 可以直接调用命令向订阅者发布消息 rostopic info 获取当前话题的相关信息 rostopic type 列出话题的消息类型 rostopic find 消息类型 根据消息类型查找话题 rostopic hz 列出消息发布频率 rostopic bw 列出消息发布带宽 2.4.3 rosmsg rosmsg是用于显示有关 ROS消息类型的 信息的命令行工具。 rosmsg show 显示消息描述 rosmsg info 显示消息信息 rosmsg list 列出所有消息 rosmsg md5 显示 md5 加密后的消息 rosmsg package 显示某个功能包下的所有消息 rosmsg packages 列出包含消息的功能包 rosmsg list 列出当前 ROS 中的所有 msg rosmsg packages 列出包含消息的所有包 rosmsg show 显示消息描述 rosmsg info 作用与 rosmsg show 一样 2.4.4 rosservice rosservice包含用于列出和查询ROSServices的rosservice命令行工具。 调用部分服务时，如果对相关工作空间没有配置 path，需要进入工作空间调用 source ./devel/setup.bash rosservice args 打印服务参数 rosservice call 使用提供的参数调用服务 rosservice find 按照服务类型查找服务 rosservice info 打印有关服务的信息 rosservice list 列出所有活动的服务 rosservice type 打印服务类型 rosservice uri 打印服务的 ROSRPC uri rosservice list 列出所有活动的服务 rosservice args 打印服务参数 rosservice call 扮演客户端角色，可以向服务器发请求，调用服务 rosservice find 根据消息类型获取话题 rosservice info 获取服务话题详情 rosservice type 获取消息类型 2.4.5 rossrv rossrv是用于显示有关ROS服务类型的信息的命令行工具，与 rosmsg 使用语法高度雷同。 rossrv show 显示服务消息详情 rossrv info 显示服务消息相关信息 rossrv list 列出所有服务信息 rossrv md5 显示 md5 加密后的服务消息 rossrv package 显示某个包下所有服务消息 rossrv packages 显示包含服务消息的所有包 rossrv list 列出当前 ROS 中的所有 srv 消息 rossrv packages 列出包含服务消息的所有包 rossrv show 显示消息描述 rossrv info 作用与 rossrv show 一致 2.4.6 rosparam rosparam包含rosparam命令行工具，用于使用YAML编码文件在参数服务器上获取和设置ROS参数。 rosparam set 设置参数 rosparam get 获取参数 rosparam load 从外部文件加载参数 rosparam dump 将参数写出到外部文件 rosparam delete 删除参数 rosparam list 列出所有参数 rosparam list 列出所有参数 rosparam set 设置参数 rosparam get 获取参数 rosparam delete 删除参数 2.5 通信机制实操 2.5.1 话题发布 运行乌龟案例后 使用rqt_graph获取乌龟案例不同节点之间的话题，为 /turtle1/cmd_vel 使用rostopic info /turtle1/cmd_vel获取指定话题的信息，得到消息类型为 geometry_msgs/Twist 使用rosmsg info geometry_msgs/Twist获取消息格式为 geometry_msgs/Vector3 linear #线速度 float64 x float64 y float64 z geometry_msgs/Vector3 angular #角速度 float64 x float64 y float64 z 使用rostopic echo turtle1/cmd_vel可以获取乌龟运动时的线速度和角速度的值 使用rostopic pub命令可让乌龟实现圆周运动 rostopic pub -r 10 /turtle1/cmd_vel geometry_msgs/Twist \"linear: x: 1.0 y: 0.0 z: 0.0 angular: x: 0.0 y: 0.0 z: 1.0\" python实现代码： #! /usr/bin/env python import rospy from geometry_msgs.msg import Twist \"\"\" 发布方：发布速度消息 话题名称：/turtle1/cmd_vel 消息类型:geometry_msgs/Twist 1.导包 2.初始化ros节点 3.创建发布者对象 4.组织数据并发布数据 \"\"\" if __name__ == \"__main__\": #2.初始化ros节点 rospy.init_node(\"my_control_p\") #3.创建发布者对象 pub = rospy.Publisher(\"/turtle1/cmd_vel\",Twist,queue_size=10) #4.组织数据并发布数据 #设置发布频率 rate = rospy.Rate(10) #创建速度消息 twist = Twist() twist.linear.x = 1.0 twist.linear.y = 0.0 twist.linear.z = 0.0 twist.angular.x = 0.0 twist.angular.y = 0.0 twist.angular.z = 1.0 #循环发布 while not rospy.is_shutdown(): pub.publish(twist) rate.sleep() 2.5.2 话题订阅 在功能包中创建launch文件夹，并在文件夹中创建start_turtle.launch文件 编写好代码后 使用rostopic list获取位姿话题为/turtle1/pose 使用rostopic info /turtle1/pose获取消息类型为turtlesim/Pose 使用rosmsg info turtlesim/Pose获取消息格式为 float32 x float32 y float32 theta float32 linear_velocity float32 angular_velocity 实时获取乌龟位姿信息python代码 #! /usr/bin/env python import rospy from turtlesim.msg import Pose \"\"\" 需求：订阅并输出乌龟位姿信息 1.导包 2.初始化ros节点 3.创建订阅者对象 4.使用回调函数处理订阅到的消息 5.spin() \"\"\" def doPose(pose): rospy.loginfo(\"P->乌龟位姿信息:左边(%.2f,%.2f),朝向:%.2f,线速度:%.2f, 角速度:%.2f\",pose.x,pose.y,pose.theta,pose.linear_velocity,pose.angular_velocity) if __name__ == \"__main__\": #2.初始化ros节点 rospy.init_node(\"sub_pose_p\") #3.创建订阅者对象 sub = rospy.Subscriber(\"/turtle1/pose\",Pose,doPose,queue_size= 100) #4.使用回调函数处理订阅到的消息 #5.spin() rospy.spin() 2.5.3 服务调用 启动launch文件，使用rosservice list查询存在的服务 通过命令形式调用服务并给定相应参数，生成乌龟 rosservice call /spawn \"x: 1.0 y: 4.0 theta: 1.57 name: 'turtle2'\" python代码： #! /usr/bin/env python import rospy from turtlesim.srv import Spawn,SpawnRequest,SpawnResponse \"\"\" 需求：向服务器发送请求，生成一只乌龟 话题：/spawn 消息:turtlesim/Spawn 1.导包 2.初始化ros节点 3.创建服务的客户端对象 4.组织数据并发送请求 5.处理响应结果 \"\"\" if __name__ == \"__main__\": #2.初始化ros节点 rospy.init_node(\"service_call_p\") #3.创建服务的客户端对象 client = rospy.ServiceProxy(\"/spawn\",Spawn) #4.组织数据并发送请求 #4-1组织数据 request = SpawnRequest() request.x = 4.5 request.y = 2.0 request.theta = -3 request.name = \"turtle3\" #4-2判断服务器状态并发送 client.wait_for_service() try: response = client.call(request) #5.处理响应结果 rospy.loginfo(\"生成乌龟的名字叫:%s\",response.name) except Exception as e: rospy.logerr(\"请求处理异常\") 2.5.4 参数设置 通过命令修改乌龟背景颜色参数 rosparam set /turtlesim/background_r 255 rosparam set /turtlesim/background_g 0 rosparam set /turtlesim/background_b 0 python代码实现： #! /usr/bin/env python import rospy \"\"\" 需求:修改乌龟GUI的背景色 1.初始化ros节点 2.设置参数 \"\"\" if __name__ == \"__main__\": rospy.init_node(\"change_bgColor_p\") #修改背景色 rospy.set_param(\"/turtlesim/background_r\",100) rospy.set_param(\"/turtlesim/background_r\",50) rospy.set_param(\"/turtlesim/background_r\",200) 2.6 通信机制比较 三种通信机制中，参数服务器是一种数据共享机制，可以在不同的节点之间共享数据，话题通信与服务通信是在不同的节点之间传递数据的，三者是ROS中最基础也是应用最为广泛的通信机制。 这其中，话题通信和服务通信有一定的相似性也有本质上的差异，在此将二者做一下简单比较: 二者的实现流程是比较相似的，都是涉及到四个要素: 要素1: 消息的发布方/客户端(Publisher/Client) 要素2: 消息的订阅方/服务端(Subscriber/Server) 要素3: 话题名称(Topic/Service) 要素4: 数据载体(msg/srv) 可以概括为: 两个节点通过话题关联到一起，并使用某种类型的数据载体实现数据传输。 二者的实现也是有本质差异的，具体比较如下: 同步性: 服务通信，由客户端发送请求给服务端，服务端处理完成后再响应给客户端；客户端再发送请求，服务端处理并响应，按照顺序依次执行。 话题通信,发布方发布消息后不用管订阅方是否处理完数据，为异步。 不同通信机制有一定的互补性，都有各自适应的应用场景。尤其是话题与服务通信，需要结合具体的应用场景与二者的差异，选择合适的通信机制。 2.7 本章小结 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/ROS1/chapter2.html":{"url":"Markdown/ROS1/chapter2.html","title":"2 实践探索","keywords":"","body":"2 实践 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/OpenCV/chapter1.html":{"url":"Markdown/OpenCV/chapter1.html","title":"1 基础入门","keywords":"","body":"1 基础入门 本教程摘录自CodecWang的opencv-python-tutorial仓库，对局部内容做了补充和调整 教程配套代码及练习代码见链接。其中，OpenCV入门+基础-配套代码.zip为本教程配套代码；OpenCV图像处理实战-代码.zip为《OpenCV图像处理实战》书籍配套代码，与本教程内容非常相似，作为练习代码 若使用Vscode出现无法找到运行文件的错误，在配置中勾选Python>Terminal:Execute In File Dir选项，见下图 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/OpenCV/chapter1-1.html":{"url":"Markdown/OpenCV/chapter1-1.html","title":"1.1 OpenCV入门","keywords":"","body":"1.1 OpenCV入门 教程使用说明参见：基础入门 1 简介与安装 相信大部分人知道的 OpenCV 都是用 C++ 来开发的，那为什么笔者推荐使用 Python 呢？ [!TIP] 本教程基础内容来自 OpenCV 官方英文教程，按照使用度和难易度翻译，重新编写了大量原创内容，将不常用和较难的部分写成番外篇，浅显易懂，很 easy 的辣。 1.1 Python 照样快！ 众所周知，虽然 Python 语法简洁、编写高效，但相比 C/C++运行慢很多。然而 Python 还有个重要的特性：它是一门胶水语言！Python 可以很容易地扩展 C/C++。OpenCV-Python 就是用 Python 包装了 C++ 的实现，背后实际就是 C++ 的代码在跑，运行速度非常接近原生。 比如笔者分别用 Python 和 C++实现读入图片和调整图片的亮度对比度，结果如下： 可以看到某些情况下 Python 的运行速度甚至好于 C++，代码行数也直接少一半多！ 另外，图像是矩阵数据，OpenCV-Python 原生支持 Numpy，相当于 Python 中的 Matlab，为矩阵运算、科学计算提供了极大的便利性。 1.2 人工智能浪潮 近些年，人工智能 AI 相关技术的快速发展大家有目共睹。在编程语言方面，更多人希望的是具备高效开发效率、跨平台、高度扩展性的语言，尤其是一些 AI 巨头优先推出支持 Python 语言的深度学习框架，如 Facebook 的PyTorch、Google 的Tensorflow等，可以说 Python 是名副其实的“网红语言”了。 从TIOBE 编程语言排行榜也可以看到，Python 发展迅猛，已经逼近 C++的份额。这个排行榜每月更新，就不截图了，笔者编写时的 TOP5：Java/C/C++/Python/C#。 1.3 人生苦短，笔者用 Python 如果你搞科研用，果断放弃 C++（Matlab？出门左拐） 如果你是快速原型开发，验证方案，果断放弃 C++ 如果你懒的配置 OpenCV 环境，果断放弃 C++ 如果你的程序是在支持 Python 的较高硬件环境下运行，果断放弃 C++ 如果你担心 Python 写不了界面，那是你的问题 o_o .... 除非你的程序是 MFC 或已经用 C++编写其他模块或是嵌入式设备，那就用 C++吧 \"人生苦短，我用 Python！！！\" 1.4 安装 本教程编写时使用的相关版本是：OpenCV 4.x，Python 3.x。 1.4.1 opencv-python 只需终端下的一条指令： pip install opencv-python pip 是 Python 的包管理器，如果你还没安装 Python，强烈推荐安装Anaconda，它包含了大量的科学计算包，不用后期一个个安装。 1.4.2 Anaconda 安装 进入 Anaconda官网，下载最新版本的安装文件，速度比较慢的话，可以去清华开源镜像站。 Windows 版是 exe 文件，双击直接安装，安装时记得勾选 Add Anaconda to my PATH environment variable，添加到环境变量。 Linux 版是 sh 文件，执行bash Anaconda3-xx.sh，Linux 版也会提示添加到环境变量，记得输 yes 就行。 MAC 版是 pkg 文件，同样直接双击安装即可。 Anaconda和Pip换源，可参考1.2 Ubuntu安装之后需要做的事 1.4.3 安装测试 Python 的版本可以在终端中输入python --version来查看。对于 OpenCV，打开 Python 的开发环境，输入import cv2，运行没有报错说明一切正常。要查看 OpenCV 的版本，可以： import cv2 print(cv2.__version__) 编辑器笔者习惯用 Visual Studio Code，也可以用 PyCharm/Atom/Jupyter Notebook(Anaconda 自带)。 1.4.4 常见问题 pip 识别不了：pip 的目录没有添加到环境变量中，添加到用户(或系统) 变量的 path 中。 下载速度很慢：可到此处下载离线版，完成后在终端输入pip install 文件名安装。 1.5 学习软件 为了便于学习 OpenCV，笔者编写了一款 Windows 平台的教学软件LearnOpenCVEdu，目前只开发了一部分功能，欢迎 Star 支持:smiley:。 [!TIP] 虽然笔者推荐大家使用 OpenCV-Python 进行图像处理，但想要深入理解 OpenCV，C++是必须的，尤其是OpenCV 源码！ 1.6 引用 Github源码 1.7 网络资料 OpenCV Docs 官方文档 OpenCV 源码 LearnOpenCV、LearnOpenCV Github OpenCV 中文教程 OpenCV 中文文档 1.8 书籍 Programming Computer Vision with Python、中文书 Practical Python and OpenCV 1.9 名校视觉研究所/课程 卡内基梅隆大学 多伦多大学 2 基本元素 - 图片 学习如何加载图片，显示并保存图片。 2.1 目标 加载图片，显示图片，保存图片 OpenCV 函数：cv2.imread(), cv2.imshow(), cv2.imwrite() 2.2 教程 大部分人可能都知道电脑上的彩色图是以 RGB(Red/Green/Blue: 红/绿/蓝) 颜色模式显示的，但 OpenCV 中彩色图是以 BGR 通道顺序存储的，灰度图只有一个通道。 图像坐标的起始点是在左上角，所以行对应的是 y，列对应的是 x： 2.2.1 加载图片 使用cv2.imread()来读入一张图片： import cv2 # 加载灰度图 img = cv2.imread('lena.jpg', 0) 参数 1：图片的文件名 如果图片放在当前文件夹下，直接写文件名就行，如'lena.jpg' 否则需要给出绝对路径，如'D:\\OpenCVSamples\\lena.jpg' 参数 2：读入方式，省略即采用默认值 cv2.IMREAD_COLOR：彩色图，默认值 (1) cv2.IMREAD_GRAYSCALE：灰度图 (0) cv2.IMREAD_UNCHANGED：包含透明通道的彩色图 (-1) [!TIP] 路径中不能有中文噢，并且没有加载成功的话是不会报错的，print(img)的结果为 None，后面处理才会报错，算是个小坑。 2.2.2 显示图片 使用cv2.imshow()显示图片，窗口会自适应图片的大小： cv2.imshow('lena', img) cv2.waitKey(0) 参数 1 是窗口的名字，参数 2 是要显示的图片。不同窗口之间用窗口名区分，所以窗口名相同就表示是同一个窗口，显示结果如下： cv2.waitKey()是让程序暂停的意思，参数是等待时间，单位毫秒 ms。时间一到，会继续执行接下来的程序，传入 0 的话表示一直等待。等待期间也可以获取用户的按键输入：k = cv2.waitKey(0)（练习）。 我们也可以先用cv2.namedWindow()创建一个窗口，之后再显示图片： # 先定义窗口，后显示图片 cv2.namedWindow('lena2', cv2.WINDOW_NORMAL) cv2.imshow('lena2', img) cv2.waitKey(0) 参数 1 依旧是窗口的名字，参数 2 默认是cv2.WINDOW_AUTOSIZE，表示窗口大小自适应图片，也可以设置为cv2.WINDOW_NORMAL，表示窗口大小可调整。图片比较大的时候，可以考虑用后者。 2.2.3 保存图片 使用cv2.imwrite()保存图片，参数 1 是包含后缀名的文件名： cv2.imwrite('lena_gray.jpg', img) Nice，是不是很简单呐，再接再厉噢(●'◡'●) 2.3 小结 cv2.imread()读入图片、cv2.imshow()显示图片、cv2.imwrite()保存图片。 2.4 练习 打开 lena.jpg 并显示，如果按下's'，就保存图片为'lena_save.bmp'，否则就结束程序。 Matplotlib 是 Python 中常用的一个绘图库，请学习2 番外篇：无损保存和 Matplotlib 使用。 2.5 接口文档 Mat Object cv2.imread() cv2.imshow() cv2.imwrite() cv.namedWindow() 3 打开摄像头 学习打开摄像头捕获照片、播放本地视频、录制视频等。 3.1 目标 打开摄像头并捕获照片 播放本地视频，录制视频 OpenCV 函数：cv2.VideoCapture(), cv2.VideoWriter() 3.2 教程 3.2.1 打开摄像头 要使用摄像头，需要使用cv2.VideoCapture(0)创建 VideoCapture 对象，参数 0 指的是摄像头的编号，如果你电脑上有两个摄像头的话，访问第 2 个摄像头就可以传入 1，依此类推。 # 打开摄像头并灰度化显示 import cv2 capture = cv2.VideoCapture(0) while(True): # 获取一帧 ret, frame = capture.read() # 将这帧转换为灰度图 gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) cv2.imshow('frame', gray) if cv2.waitKey(1) == ord('q'): break capture.read()函数返回的第 1 个参数 ret(return value) 是一个布尔值，表示当前这一帧是否获取正确。cv2.cvtColor()用来转换颜色，这里将彩色图转成灰度图。 另外，通过cap.get(propId)可以获取摄像头的一些属性，比如捕获的分辨率，亮度和对比度等。propId 是从 0~18 的数字，代表不同的属性，完整的属性列表可以参考：VideoCaptureProperties。也可以使用cap.set(propId,value)来修改属性值。比如说，我们在 while 之前添加下面的代码： # 获取捕获的分辨率 # propId 可以直接写数字，也可以用 OpenCV 的符号表示 width, height = capture.get(3), capture.get(4) print(width, height) # 以原分辨率的一倍来捕获 capture.set(cv2.CAP_PROP_FRAME_WIDTH, width * 2) capture.set(cv2.CAP_PROP_FRAME_HEIGHT, height * 2) [!TIP] 某些摄像头设定分辨率等参数时会无效，因为它有固定的分辨率大小支持，一般可在摄像头的资料页中找到。 3.2.2 播放本地视频 跟打开摄像头一样，如果把摄像头的编号换成视频的路径就可以播放本地视频了。回想一下cv2.waitKey()，它的参数表示暂停时间，所以这个值越大，视频播放速度越慢，反之，播放速度越快，通常设置为 25 或 30。 # 播放本地视频 capture = cv2.VideoCapture('demo_video.mp4') while(capture.isOpened()): ret, frame = capture.read() gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY) cv2.imshow('frame', gray) if cv2.waitKey(30) == ord('q'): break 3.2.3 录制视频 之前我们保存图片用的是cv2.imwrite()，要保存视频，我们需要创建一个VideoWriter的对象，需要给它传入四个参数： 输出的文件名，如'output.avi' 编码方式 FourCC 码 帧率 FPS 要保存的分辨率大小 FourCC 是用来指定视频编码方式的四字节码，所有的编码可参考Video Codecs。如 MJPG 编码可以这样写： cv2.VideoWriter_fourcc(*'MJPG')或cv2.VideoWriter_fourcc('M','J','P','G') capture = cv2.VideoCapture(0) # 定义编码方式并创建 VideoWriter 对象 fourcc = cv2.VideoWriter_fourcc(*'MJPG') outfile = cv2.VideoWriter('output.avi', fourcc, 25., (640, 480)) while(capture.isOpened()): ret, frame = capture.read() if ret: outfile.write(frame) # 写入文件 cv2.imshow('frame', frame) if cv2.waitKey(1) == ord('q'): break else: break 3.3 小结 使用cv2.VideoCapture()创建视频对象，然后在循环中一帧帧显示图像。参数传入数字时，代表打开摄像头，传入本地视频路径时，表示播放本地视频。 cap.get(propId)获取视频属性，cap.set(propId,value)设置视频属性。 cv2.VideoWriter()创建视频写入对象，用来录制/保存视频。 3.4 练习 请先阅读3 番外篇：滑动条，然后实现一个可以拖动滑块播放视频的功能。（提示：需要用到 cv2.CAP_PROP_FRAME_COUNT和cv2.CAP_PROP_POS_FRAMES两个属性）。 3.5 接口文档 VideoCapture Object VideoWriter Object cv2.cvtColor() 3.6 引用 Video Codecs by FOURCC 4 图像基本操作 学习获取和修改像素点的值，ROI 感兴趣区域，通道分离合并等基本操作。 4.1 目标 访问和修改图片像素点的值 获取图片的宽、高、通道数等属性 了解感兴趣区域 ROI 分离和合并图像通道 4.2 教程 4.2.1 获取和修改像素点值 我们先读入一张图片： import cv2 img = cv2.imread('lena.jpg') 通过行列的坐标来获取某像素点的值，对于彩色图，结果是 B,G,R 三个值的列表，对于灰度图或单通道图，只有一个值： px = img[100, 90] print(px) # [103 98 197] # 只获取蓝色 blue 通道的值 px_blue = img[100, 90, 0] print(px_blue) # 103 还记得吗？行对应 y，列对应 x，所以其实是img[y, x]，需要注意噢(●ˇ∀ˇ●)。容易混淆的话，可以只记行和列，行在前，列在后。 修改像素的值也是同样的方式： img[100, 90] = [255, 255, 255] print(img[100, 90]) # [255 255 255] [!TIP] 还有一种性能更好的方式，获取：img.item(100,100,0)，修改：img.itemset((100,100,0),255)，但这种方式只能 B,G,R 逐一进行。 注意：这步操作只是内存中的 img 像素点值变了，因为没有保存，所以原图并没有更改。 4.2.2 图片属性 img.shape获取图像的形状，图片是彩色的话，返回一个包含行数（高度）、列数（宽度）和通道数的元组，灰度图只返回行数和列数： print(img.shape) # (263, 263, 3) # 形状中包括行数、列数和通道数 height, width, channels = img.shape # img 是灰度图的话：height, width = img.shape img.dtype获取图像数据类型： print(img.dtype) # uint8 [!TIP] 多数错误是因为数据类型不对导致的，所以健壮的代码应该对这个属性加以判断。 img.size获取图像总像素数： print(img.size) # 263*263*3=207507 4.2.3 ROI ROI：Region of Interest，感兴趣区域。什么意思呢？比如我们要检测眼睛，因为眼睛肯定在脸上，所以我们感兴趣的只有脸这部分，其他都不 care，所以可以单独把脸截取出来，这样就可以大大节省计算量，提高运行速度。 截取 ROI 非常简单，指定图片的范围即可（后面我们学了特征后，就可以自动截取辣，(ง •_•)ง）： # 截取脸部 ROI face = img[100:200, 115:188] cv2.imshow('face', face) cv2.waitKey(0) 4.2.4 通道分割与合并 彩色图的 BGR 三个通道是可以分开单独访问的，也可以将单独的三个通道合并成一副图像。分别使用cv2.split()和cv2.merge()： b, g, r = cv2.split(img) img = cv2.merge((b, g, r)) split()函数比较耗时，更高效的方式是用 numpy 中的索引，如提取 B 通道： b = img[:, :, 0] cv2.imshow('blue', b) cv2.waitKey(0) 4.3 小结 img[y,x]获取/设置像素点值，img.shape：图片的形状（行数、列数、通道数）,img.dtype：图像的数据类型。 img[y1:y2,x1:x2]进行 ROI 截取，cv2.split()/cv2.merge()通道分割/合并。更推荐的获取单通道方式：b = img[:, :, 0]。 4.4 练习 打开 lena.jpg，将帽子部分（高：25-120，宽：50-220）的红色通道截取出来并显示。 4.5 接口文档 cv2.split() cv2.merge() 5 颜色空间转换 学习如何进行图片的颜色空间转换，视频中追踪特定颜色的物体。 5.1 目标 颜色空间转换，如 BGR↔Gray，BGR↔HSV 等 追踪视频中特定颜色的物体 OpenCV 函数：cv2.cvtColor(), cv2.inRange() 5.2 教程 5.2.1 颜色空间转换 import cv2 img = cv2.imread('lena.jpg') # 转换为灰度图 img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) cv2.imshow('img', img) cv2.imshow('gray', img_gray) cv2.waitKey(0) cv2.cvtColor()用来进行颜色模型转换，参数 1 是要转换的图片，参数 2 是转换模式， COLOR_BGR2GRAY表示 BGR→Gray，可用下面的代码显示所有的转换模式： flags = [i for i in dir(cv2) if i.startswith('COLOR_')] print(flags) [!TIP] 颜色转换其实是数学运算，如灰度化最常用的是：gray=R*0.299+G*0.587+B*0.114。 5.2.2 视频中特定颜色物体追踪 HSV是一个常用于颜色识别的模型，相比 BGR 更易区分颜色，转换模式用COLOR_BGR2HSV表示。 [!TIP] OpenCV 中色调 H 范围为[0,179]，饱和度 S 是[0,255]，明度 V 是[0,255]。虽然 H 的理论数值是 0°~360°，但 8 位图像像素点的最大值是 255，所以 OpenCV 中除以了 2，某些软件可能使用不同的尺度表示，所以同其他软件混用时，记得归一化。 现在，我们实现一个使用 HSV 来只显示视频中蓝色物体的例子，步骤如下： 捕获视频中的一帧 从 BGR 转换到 HSV 提取蓝色范围的物体 只显示蓝色物体 import cv2 import numpy as np capture = cv2.VideoCapture(0) # 蓝色的HSV范围，不同光照条件下不一样，可灵活调整 lower_blue = np.array([100, 110, 110]) upper_blue = np.array([130, 255, 255]) while(True): # 1.捕获视频中的一帧 ret, frame = capture.read() # 2.从 BGR 转换到 HSV hsv = cv2.cvtColor(frame, cv2.COLOR_BGR2HSV) # 3.inRange()：介于 lower/upper 之间的为白色，其余黑色 mask = cv2.inRange(hsv, lower_blue, upper_blue) # 4.只保留原图中的蓝色部分 res = cv2.bitwise_and(frame, frame, mask=mask) cv2.imshow('frame', frame) cv2.imshow('mask', mask) cv2.imshow('res', res) if cv2.waitKey(1) == ord('q'): break 其中，bitwise_and()函数暂时不用管，后面会讲到。那蓝色的 HSV 值的上下限 lower 和 upper 范围是怎么得到的呢？其实很简单，我们先把标准蓝色的 BGR 值用cvtColor()转换下： blue = np.uint8([[[255, 0, 0]]]) hsv_blue = cv2.cvtColor(blue, cv2.COLOR_BGR2HSV) print(hsv_blue) # [[[120 255 255]]] 结果是[120, 255, 255]，所以，我们把蓝色的范围调整成了上面代码那样。 [!TIP] Lab 颜色空间也经常用来做颜色识别，有兴趣的同学可以了解下。 5.3 小结 cv2.cvtColor()函数用来进行颜色空间转换，常用 BGR↔Gray，BGR↔HSV。 HSV 颜色模型常用于颜色识别。要想知道某种颜色在 HSV 下的值，可以将它的 BGR 值用cvtColor()转换得到。 5.4 练习 尝试在视频中同时提取红色、蓝色、绿色的物体。（效果如下） 5.5 接口文档 cv2.cvtColor() cv2.inRange() cv2.bitwise_and() 6 阈值分割 学习使用不同的阈值方法\"二值化\"图像。 6.1 目标 使用固定阈值、自适应阈值和 Otsu 阈值法\"二值化\"图像 OpenCV 函数：cv2.threshold(), cv2.adaptiveThreshold() 6.2 教程 6.2.1 固定阈值分割 固定阈值分割很直接，一句话说就是像素点值大于阈值变成一类值，小于阈值变成另一类值。 import cv2 # 灰度图读入 img = cv2.imread('gradient.jpg', 0) # 阈值分割 ret, th = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY) cv2.imshow('thresh', th) cv2.waitKey(0) cv2.threshold()用来实现阈值分割，ret 代表当前的阈值，暂时不用理会。函数有 4 个参数： 参数 1：要处理的原图，一般是灰度图 参数 2：设定的阈值 参数 3：对于THRESH_BINARY、THRESH_BINARY_INV阈值方法所选用的最大阈值，一般为 255 参数 4：阈值的方式，主要有 5 种，详情：ThresholdTypes 下面结合代码理解下这 5 种阈值方式： import cv2 import matplotlib.pyplot as plt img = cv2.imread('gradient.jpg', 0) # 应用 5 种不同的阈值方法 ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY) ret, th2 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY_INV) ret, th3 = cv2.threshold(img, 127, 255, cv2.THRESH_TRUNC) ret, th4 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO) ret, th5 = cv2.threshold(img, 127, 255, cv2.THRESH_TOZERO_INV) titles = ['Original', 'BINARY', 'BINARY_INV', 'TRUNC', 'TOZERO', 'TOZERO_INV'] images = [img, th1, th2, th3, th4, th5] # 使用 Matplotlib 显示 for i in range(6): plt.subplot(2, 3, i + 1) plt.imshow(images[i], 'gray') plt.title(titles[i], fontsize=8) plt.xticks([]), plt.yticks([]) # 隐藏坐标轴 plt.show() [!TIP] 很多人误以为阈值分割就是 二值化。从上图中可以发现，两者并不等同，阈值分割结果是两类值，而不是两个值，所以教程开头笔者把二值化加了引号。 6.2.2 自适应阈值 看得出来固定阈值是在整幅图片上应用一个阈值进行分割，它并不适用于明暗分布不均的图片。 cv2.adaptiveThreshold()自适应阈值会每次取图片的一小部分计算阈值，这样图片不同区域的阈值就不尽相同。它有 5 个参数，其实很好理解，先看下效果： import cv2 import matplotlib.pyplot as plt # 自适应阈值对比固定阈值 img = cv2.imread('sudoku.jpg', 0) # 固定阈值 ret, th1 = cv2.threshold(img, 127, 255, cv2.THRESH_BINARY) # 自适应阈值 th2 = cv2.adaptiveThreshold( img, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 4) th3 = cv2.adaptiveThreshold( img, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 17, 6) titles = ['Original', 'Global(v = 127)', 'Adaptive Mean', 'Adaptive Gaussian'] images = [img, th1, th2, th3] for i in range(4): plt.subplot(2, 2, i + 1), plt.imshow(images[i], 'gray') plt.title(titles[i], fontsize=8) plt.xticks([]), plt.yticks([]) plt.show() 参数 1：要处理的原图 参数 2：最大阈值，一般为 255 参数 3：小区域阈值的计算方式 ADAPTIVE_THRESH_MEAN_C：小区域内取均值 ADAPTIVE_THRESH_GAUSSIAN_C：小区域内加权求和，权重是个高斯核 参数 4：阈值方法，只能使用THRESH_BINARY、THRESH_BINARY_INV，具体见前面所讲的阈值方法 参数 5：小区域的面积，如 11 就是 11*11 的小块 参数 6：最终阈值等于小区域计算出的阈值再减去此值 如果你没看懂上面的参数也不要紧，暂时会用就行，当然建议你调整下参数看看不同的结果。 6.2.3 Otsu 阈值 在前面固定阈值中，我们是随便选了一个阈值如 127，那如何知道我们选的这个阈值效果好不好呢？答案是：不断尝试，所以这种方法在很多文献中都被称为经验阈值。Otsu 阈值法就提供了一种自动高效的二值化方法，不过我们直方图还没学，这里暂时略过。 好吧，我知道我激起了你的兴趣，~ o(￣ ▽ ￣)o，有能力的童鞋可以看下练习题。 6.3 小结 cv2.threshold()用来进行固定阈值分割。固定阈值不适用于光线不均匀的图片，所以用 cv2.adaptiveThreshold()进行自适应阈值分割。 二值化跟阈值分割并不等同。针对不同的图片，可以采用不同的阈值方法。 6.4 练习 Otsu 阈值是一种高效的二值化算法，请阅读4 番外篇：Otsu 阈值法。 6.5 接口文档 cv2.threshold() cv2.adaptiveThreshold() cv2.ThresholdTypes() 7 图像几何变换 学习如何旋转、平移、缩放和翻转图片。 7.1 目标 实现旋转、平移和缩放图片 OpenCV 函数：cv2.resize(), cv2.flip(), cv2.warpAffine() 7.2 教程 [!TIP] 图像的几何变换从原理上看主要包括两种：基于 2×3 矩阵的仿射变换（平移、缩放、旋转和翻转等）、基于 3×3 矩阵的透视变换，感兴趣的小伙伴可参考5 番外篇：仿射变换与透视变换。 7.2.1 缩放图片 缩放就是调整图片的大小，使用cv2.resize()函数实现缩放。可以按照比例缩放，也可以按照指定的大小缩放： import cv2 img = cv2.imread('drawing.jpg') # 按照指定的宽度、高度缩放图片 res = cv2.resize(img, (132, 150)) # 按照比例缩放，如 x,y 轴均放大一倍 res2 = cv2.resize(img, None, fx=2, fy=2, interpolation=cv2.INTER_LINEAR) cv2.imshow('shrink', res), cv2.imshow('zoom', res2) cv2.waitKey(0) 我们也可以指定缩放方法interpolation，更专业点叫插值方法，默认是INTER_LINEAR，全部可以参考：InterpolationFlags 7.2.2 翻转图片 镜像翻转图片，可以用cv2.flip()函数： dst = cv2.flip(img, 1) 其中，参数 2 = 0：垂直翻转 (沿 x 轴)，参数 2 > 0: 水平翻转 (沿 y 轴)，参数 2 7.2.3 平移图片 要平移图片，我们需要定义下面这样一个矩阵，tx,ty 是向 x 和 y 方向平移的距离： 平移是用仿射变换函数cv2.warpAffine()实现的： # 平移图片 import cv2 import numpy as np img = cv2.imread('drawing.jpg') rows, cols = img.shape[:2] # 定义平移矩阵，需要是 numpy 的 float32 类型 # x 轴平移 100，y 轴平移 50 M = np.float32([[1, 0, 100], [0, 1, 50]]) # 用仿射变换实现平移 dst = cv2.warpAffine(img, M, (cols, rows)) cv2.imshow('shift', dst) cv2.waitKey(0) 7.2.4 旋转图片 旋转同平移一样，也是用仿射变换实现的，因此也需要定义一个变换矩阵。OpenCV 直接提供了 cv2.getRotationMatrix2D()函数来生成这个矩阵，该函数有三个参数： 参数 1：图片的旋转中心 参数 2：旋转角度 (正：逆时针，负：顺时针) 参数 3：缩放比例，0.5 表示缩小一半 # 45°旋转图片并缩小一半 M = cv2.getRotationMatrix2D((cols / 2, rows / 2), 45, 0.5) # (cols, rows)表示输出图片的大小 dst = cv2.warpAffine(img, M, (cols, rows)) cv2.imshow('rotation', dst) cv2.waitKey(0) 7.3 小结 cv2.resize()缩放图片，可以按指定大小缩放，也可以按比例缩放。 cv2.flip()翻转图片，可以指定水平/垂直/水平垂直翻转三种方式。 平移/旋转是靠仿射变换cv2.warpAffine()实现的。 7.4 接口文档 cv2.resize() cv2.filp() cv2.warpAffine() cv2.getRotationMatrix2D() 8 绘图功能 学习画线、圆和矩形等多种几何形状，给图片添加文字。 8.1 目标 绘制各种几何形状、添加文字 OpenCV 函数：cv2.line(), cv2.circle(), cv2.rectangle(), cv2.ellipse(), cv2.putText() 8.2 教程 8.2.1 参数说明 绘制形状的函数有一些共同的参数，提前在此说明一下： img：要绘制形状的图片 color：绘制的颜色 彩色图就传入 BGR 的一组值，如蓝色就是 (255, 0, 0) 灰度图，传入一个灰度值就行 thickness：线宽，默认为 1；对于矩形/圆之类的封闭形状而言，传入 -1 表示填充形状 需要导入的模块和显示图片的通用代码： import cv2 import numpy as np import matplotlib.pyplot as plt cv2.imshow('img', img) cv2.waitKey(0) 上图就是本教程绘制的最终效果，下面一步步来看： 8.2.2 画线 画直线只需指定起点和终点的坐标就行： # 创建一副黑色的图片 img = np.zeros((512, 512, 3), np.uint8) # 画一条线宽为 5 的蓝色直线，参数 2：起点，参数 3：终点 cv2.line(img, (0, 0), (512, 512), (255, 0, 0), 5) [!TIP] 所有绘图函数均会直接影响原图片，这点要注意。 8.2.3 画矩形 画矩形需要知道左上角和右下角的坐标： # 画一个绿色边框的矩形，参数 2：左上角坐标，参数 3：右下角坐标 cv2.rectangle(img, (384, 0), (510, 128), (0, 255, 0), 3) 8.2.4 画圆 画圆需要指定圆心和半径，注意下面的例子中线宽=-1 代表填充： # 画一个填充红色的圆，参数 2：圆心坐标，参数 3：半径 cv2.circle(img, (447, 63), 63, (0, 0, 255), -1) 8.2.5 画椭圆 画椭圆需要的参数比较多，请对照后面的代码理解这几个参数： 参数 2：椭圆中心 (x,y) 参数 3：x/y 轴的长度 参数 4：angle - 椭圆的旋转角度 参数 5：startAngle - 椭圆的起始角度 参数 6：endAngle - 椭圆的结束角度 [!TIP] OpenCV 中原点在左上角，所以这里的角度是以顺时针方向计算的。 # 在图中心画一个填充的半圆 cv2.ellipse(img, (256, 256), (100, 50), 0, 0, 180, (255, 0, 0), -1) 8.2.6 画多边形 画多边形需要指定一系列多边形的顶点坐标，相当于从第一个点到第二个点画直线，再从第二个点到第三个点画直线.... OpenCV 中需要先将多边形的顶点坐标变成顶点数 ×1×2 维的矩阵，再来绘制： # 定义四个顶点坐标 pts = np.array([[10, 5], [50, 10], [70, 20], [20, 30]], np.int32) # 顶点个数：4，矩阵变成 4*1*2 维 pts = pts.reshape((-1, 1, 2)) cv2.polylines(img, [pts], True, (0, 255, 255)) cv2.polylines()的参数 3 如果是 False 的话，多边形就不闭合。 [!TIP] 如果需要绘制多条直线，使用 cv2.polylines() 要比 cv2.line() 高效很多，例如： # 使用 cv2.polylines() 画多条直线 line1 = np.array([[100, 20], [300, 20]], np.int32).reshape((-1, 1, 2)) line2 = np.array([[100, 60], [300, 60]], np.int32).reshape((-1, 1, 2)) line3 = np.array([[100, 100], [300, 100]], np.int32).reshape((-1, 1, 2)) cv2.polylines(img, [line1, line2, line3], True, (0, 255, 255)) 8.2.7 添加文字 使用cv2.putText()添加文字，它的参数也比较多，同样请对照后面的代码理解这几个参数： 参数 2：要添加的文本 参数 3：文字的起始坐标（左下角为起点） 参数 4：字体 参数 5：文字大小（缩放比例） # 添加文字 font = cv2.FONT_HERSHEY_SIMPLEX cv2.putText(img, 'ex2tron', (10, 500), font, 4, (255, 255, 255), 2, lineType=cv2.LINE_AA) 字体可参考：HersheyFonts。另外，这里有个线型 lineType 参数，LINE_AA 表示抗锯齿线型，具体可见LineTypes 8.3 小结 cv2.line()画直线，cv2.circle()画圆，cv2.rectangle()画矩形，cv2.ellipse()画椭圆，cv2.polylines()画多边形，cv2.putText()添加文字。 画多条直线时，cv2.polylines()要比cv2.line()高效很多。 8.4 练习 你能用已学的绘图功能画出 OpenCV 的 logo 吗？(提示：椭圆和圆) 8.5 接口文档 cv2.line() cv2.circle() cv2.rectangle() cv2.ellipse() cv2.putText() cv2.polylines() 1 番外篇：代码性能优化 学习如何评估和优化代码性能。 完成一项任务很重要，高效地完成更重要。图像处理是对矩阵的操作，数据量巨大。如果代码写的不好，性能差距将很大，所以这节我们来了解下如何评估和提升代码性能。 1.1 评估代码运行时间 import cv2 start = cv2.getTickCount() # 这里写测试代码... end = cv2.getTickCount() print((end - start) / cv2.getTickFrequency()) 这段代码就是用来测量程序运行时间的（单位：s），其中cv2.getTickCount()函数得到电脑启动以来的时钟周期数，cv2.getTickFrequency()返回你电脑的主频，前后相减再除以主频就是你代码的运行时间（这样解释并不完全准确，但能理解就行）。另外，也可以用 Python 中的 time 模块计时： import time # Python Version >= 3.8 start = time.perf_counter() # 这里写测试代码... end = time.perf_counter() print(end - start) [!TIP] 如果你使用的是 IPython 或 Jupyter Notebook 开发环境，性能分析将会非常方便，详情请参考：Timing and Profiling in IPython 1.2 优化原则 数据元素少时用 Python 语法，数据元素多时用 Numpy： x = 10 z = np.uint8([10]) # 尝试比较下面三句话各自的运行时间 y = x * x * x # (1.6410249677846285e-06) y = x**3 # (2.461537451676943e-06) y = z * z * z # 最慢 (3.1179474387907945e-05) 所以 Numpy 的运行速度并不一定比 Python 本身语法快，元素数量较少时，请用 Python 本身格式。 尽量避免使用循环，尤其嵌套循环，因为极其慢！！！ 优先使用 OpenCV/Numpy 中封装好的函数 尽量将数据向量化，变成 Numpy 的数据格式 尽量避免数组的复制操作 1.3 接口文档 cv2.getTickCount() cv2.getTickFrequency() 1.4 引用 Python Optimization Techniques Timing and Profiling in IPython Advanced Numpy 2 番外篇：无损保存和 Matplotlib 了解常用图片格式和 OpenCV 高质量保存图片的方式，学习如何使用 Matplotlib 显示 OpenCV 图像。 2.1 无损保存 事实上，我们日常看到的大部分图片都是压缩过的，那么都有哪些常见的图片格式呢？ 2.1.1 常用图片格式 bmp 全称：Bitmap 不压缩 jpg 全称：Joint Photographic Experts Group 有损压缩方式 png 全称：Portable Network Graphics 无损压缩方式 简单来说，同一个文件保存成不同的格式后，文件大小上 bmp 肯定是最大的，而 png 和 jpg，不同的压缩比结果会有所不同。可以用画图工具新建一副 100×100 的图像，分别保存成这三种格式来验证： 2.1.2 高质量保存 用 cv2.imwrite() 保存图片时，可以传入第三个参数，用于控制保存质量： cv2.IMWRITE_JPEG_QUALITY：jpg 质量控制，取值 0~100，值越大，质量越好，默认为 95 cv2.IMWRITE_PNG_COMPRESSION：png 质量控制，取值 0~9，值越大，压缩比越高，默认为 1 还有诸如CV_IMWRITE_WEBP_QUALITY的参量，不常用，请参考：ImwriteFlags。 举例来说，原图 lena.jpg 的分辨率是 350×350，大小 49.7KB。我们把它转成不同格式看下： import cv2 new_img = cv2.imread('lena.jpg') # bmp cv2.imwrite('img_bmp.bmp',new_img) # 文件大小：359KB # jpg 默认 95% 质量 cv2.imwrite('img_jpg95.jpg',new_img) # 文件大小：52.3KB # jpg 20% 质量 cv2.imwrite('img_jpg20.jpg',new_img,[int(cv2.IMWRITE_JPEG_QUALITY),20]) # 文件大小：8.01KB # jpg 100% 质量 cv2.imwrite('img_jpg100.jpg',new_img,[int(cv2.IMWRITE_JPEG_QUALITY),100]) # 文件大小：82.5KB # png 默认 1 压缩比 cv2.imwrite('img_png1.png',new_img) # 文件大小：240KB # png 9 压缩比 cv2.imwrite('img_png9.png',new_img,[int(cv2.IMWRITE_PNG_COMPRESSION),9]) # 文件大小：207KB 可以看到： bmp 文件是最大的，没有任何压缩（1 个像素点 1byte，3 通道的彩色图总大小：350×350×3/1024 ≈ 359 KB） jpg/png 本身就有压缩的，所以就算是 100% 的质量保存，体积也比 bmp 小很多 jpg 的容量优势很明显，这也是它为什么如此流行的原因 思考：为什么原图 49.7KB，保存成 bmp 或其他格式反而大了呢？ 这是个很有趣的问题，很多童鞋都问过笔者。这里需要明确的是保存新格式时，容量大小跟原图的容量没有直接关系，而是取决于原图的分辨率大小和原图本身的内容（压缩方式）。所以 lena.jpg 保存成不压缩的 bmp 格式时，容量大小就是固定的 350×350×3/1024 ≈ 359 KB；另外，容量变大不代表画质提升噢，不然就逆天了~~~ 2.2 Matplotlib Matplotlib 是 Python 的一个很常用的绘图库，有兴趣的可以去官网学习更多内容。 2.2.1 显示灰度图 import cv2 import matplotlib.pyplot as plt img = cv2.imread('lena.jpg', 0) # 灰度图显示，cmap(color map) 设置为 gray plt.imshow(img, cmap='gray') plt.show() 结果如下： 2.2.2 显示彩色图 OpenCV 中的图像是以 BGR 的通道顺序存储的，但 Matplotlib 是以 RGB 模式显示的，所以直接在 Matplotlib 中显示 OpenCV 图像会出现问题，因此需要转换一下： import cv2 import matplotlib.pyplot as plt img = cv2.imread('lena.jpg') img2 = img[:, :, ::-1] # 或使用 # img2 = cv2.cvtColor(img, cv2.COLOR_BGR2RGB) # 显示不正确的图 plt.subplot(121),plt.imshow(img) # 显示正确的图 plt.subplot(122) plt.xticks([]), plt.yticks([]) # 隐藏 x 和 y 轴 plt.imshow(img2) plt.show() [!TIP] img[:,:,0]表示图片的蓝色通道，img[:,:,::-1]就表示 BGR 翻转，变成 RGB，说明一下 熟悉 Python 的童鞋应该知道，对一个字符串 s 翻转可以这样写：s[::-1]，'abc'变成'cba'，-1 表示逆序。图片是二维的，所以完整地复制一副图像就是： img2 = img[:,:] # 写全就是：img2 = img[0:height,0:width] 而图片是有三个通道，相当于一个长度为 3 的字符串，所以通道翻转与图片复制组合起来便是img[:,:,::-1]。 结果如下： 2.2.3 加载和保存图片 不使用 OpenCV，Matplotlib 也可以加载和保存图片： import matplotlib.image as pli import matplotlib.pyplot as plt img = pli.imread('lena.jpg') plt.imshow(img) # 保存图片，需放在 show() 函数之前 plt.savefig('lena2.jpg') plt.show() 2.3 接口文档 cv2.imwrite() ImwriteFlags 2.4 引用 聊一聊几种常用 web 图片格式 Matplotlib 官网 3 番外篇：滑动条 学习使用滑动条动态调整参数。 3.1 滑动条的使用 首先我们需要创建一个滑动条，如cv2.createTrackbar('R','image',0,255,call_back)，其中 参数 1：滑动条的名称 参数 2：所在窗口的名称 参数 3：当前的值 参数 4：最大值 参数 5：回调函数名称，回调函数默认有一个表示当前值的参数 创建好之后，可以在回调函数中获取滑动条的值，也可以用：cv2.getTrackbarPos()得到，其中，参数 1 是滑动条的名称，参数 2 是窗口的名称。 3.2 RGB 调色板 下面我们实现一个 RGB 的调色板，理解下滑动条的用法： import cv2 import numpy as np # 回调函数，x 表示滑块的位置，本例暂不使用 def nothing(x): pass img = np.zeros((300, 512, 3), np.uint8) cv2.namedWindow('image') # 创建 RGB 三个滑动条 cv2.createTrackbar('R', 'image', 0, 255, nothing) cv2.createTrackbar('G', 'image', 0, 255, nothing) cv2.createTrackbar('B', 'image', 0, 255, nothing) while(True): cv2.imshow('image', img) if cv2.waitKey(1) == 27: break # 获取滑块的值 r = cv2.getTrackbarPos('R', 'image') g = cv2.getTrackbarPos('G', 'image') b = cv2.getTrackbarPos('B', 'image') # 设定 img 的颜色 img[:] = [b, g, r] 3.3 小结 cv2.createTrackbar()用来创建滑动条，可以在回调函数中或使用cv2.getTrackbarPos()得到滑块的位置 3.4 接口文档 cv2.createTrackbar() cv2.getTrackbarPos() 4 番外篇：Otsu 阈值法 大部分图像处理任务都需要先进行二值化操作，阈值的选取很关键，Otsu 阈值法会自动计算阈值。 Otsu 阈值法（日本人大津展之提出的，也可称大津算法）非常适用于双峰图片，啥意思呢？ Otsu N. A threshold selection method from gray-level histograms[J]. IEEE transactions on systems, man, and cybernetics, 1979, 9(1): 62-66. 4.1 什么是双峰图片？ 双峰图片就是指图片的灰度直方图上有两个峰值，直方图就是每个值（0~255）的像素点个数统计，后面会详细介绍。 Otsu 算法假设这副图片由前景色和背景色组成，通过统计学方法（最大类间方差）选取一个阈值，将前景和背景尽可能分开，我们先来看下代码，然后详细说明下算法原理。 4.2 代码示例 下面这段代码对比了使用固定阈值和 Otsu 阈值后的不同结果： 另外，对含噪点的图像，先进行滤波操作效果会更好。 import cv2 from matplotlib import pyplot as plt img = cv2.imread('noisy.jpg', 0) # 固定阈值法 ret1, th1 = cv2.threshold(img, 100, 255, cv2.THRESH_BINARY) # Otsu 阈值法 ret2, th2 = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU) # 先进行高斯滤波，再使用 Otsu 阈值法 blur = cv2.GaussianBlur(img, (5, 5), 0) ret3, th3 = cv2.threshold(blur, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU) 下面我们用 Matplotlib 把原图、直方图和阈值图都显示出来： images = [img, 0, th1, img, 0, th2, blur, 0, th3] titles = ['Original', 'Histogram', 'Global(v=100)', 'Original', 'Histogram', \"Otsu's\", 'Gaussian filtered Image', 'Histogram', \"Otsu's\"] for i in range(3): # 绘制原图 plt.subplot(3, 3, i * 3 + 1) plt.imshow(images[i * 3], 'gray') plt.title(titles[i * 3], fontsize=8) plt.xticks([]), plt.yticks([]) # 绘制直方图 plt.hist，ravel 函数将数组降成一维 plt.subplot(3, 3, i * 3 + 2) plt.hist(images[i * 3].ravel(), 256) plt.title(titles[i * 3 + 1], fontsize=8) plt.xticks([]), plt.yticks([]) # 绘制阈值图 plt.subplot(3, 3, i * 3 + 3) plt.imshow(images[i * 3 + 2], 'gray') plt.title(titles[i * 3 + 2], fontsize=8) plt.xticks([]), plt.yticks([]) plt.show() 可以看到，Otsu 阈值明显优于固定阈值，省去了不断尝试阈值判断效果好坏的过程。其中，绘制直方图时，使用了 numpy 中的ravel()函数，它会将原矩阵压缩成一维数组，便于画直方图。 4.3 Otsu 算法详解 Otsu 阈值法将整幅图分为前景（目标）和背景，以下是一些符号规定： T：分割阈值 N0：前景像素点数 N1：背景像素点数 w0：前景的像素点数占整幅图像的比例 w1：背景的像素点数占整幅图像的比例 u0：前景的平均像素值 u1：背景的平均像素值 u：整幅图的平均像素值 rows × cols：图像的行数和列数 结合下图会更容易理解一些，有一副大小为 4×4 的图片，假设阈值 T 为 1，那么： 其实很好理解，N0+N1就是总的像素点个数，也就是行数乘列数： w0和w1是前/背景所占的比例，也就是： 整幅图的平均像素值就是： 此时，我们定义一个前景u0与背景u1的方差g： 将前述的3个公式整合在一起，便是： g就是前景与背景两类之间的方差，这个值越大，说明前景和背景的差别也就越大，效果越好。Otsu 算法便是遍历阈值 T，使得g最大，所以又称为最大类间方差法。基本上双峰图片的阈值 T 在两峰之间的谷底。 4.4 接口文档 cv2.ThresholdTypes cv2.GaussianBlur() 4.5 引用 numpy.ravel Otsu's Method(wikipedia) 一维 OTSU 法、最小交叉熵法、二维 OTSU 法及 C++源码 Otsu N. A threshold selection method from gray-level histograms[J]. IEEE transactions on systems, man, and cybernetics, 1979, 9(1): 62-66. 5 番外篇：仿射变换与透视变换 常见的 2D 图像变换从原理上讲主要包括基于 2×3 矩阵的仿射变换和基于 3×3 矩阵透视变换。 5.1 仿射变换 基本的图像变换就是二维坐标的变换：从一种二维坐标(x,y) 到另一种二维坐标(u,v) 的线性变换： 如果写成矩阵的形式，就是： 作如下定义： 矩阵 T(2×3) 就称为仿射变换的变换矩阵，R 为线性变换矩阵，t 为平移矩阵，简单来说，仿射变换就是线性变换 + 平移。变换后直线依然是直线，平行线依然是平行线，直线间的相对位置关系不变，因此非共线的三个对应点便可确定唯一的一个仿射变换。线性变换 4 个自由度 + 平移 2 个自由度 →仿射变换自由度为 6。 来看下 OpenCV 中如何实现仿射变换： import cv2 import numpy as np import matplotlib.pyplot as plt img = cv2.imread('drawing.jpg') rows, cols = img.shape[:2] # 变换前的三个点 pts1 = np.float32([[50, 65], [150, 65], [210, 210]]) # 变换后的三个点 pts2 = np.float32([[50, 100], [150, 65], [100, 250]]) # 生成变换矩阵 M = cv2.getAffineTransform(pts1, pts2) dst = cv2.warpAffine(img, M, (cols, rows)) plt.subplot(121), plt.imshow(img), plt.title('input') plt.subplot(122), plt.imshow(dst), plt.title('output') plt.show() 三个点笔者已经在图中标记了出来。用cv2.getAffineTransform()生成变换矩阵，接下来再用cv2.warpAffine()实现变换。 思考：三个点笔者标记的是红色，为什么 Matplotlib 显示出来是下面这种颜色？ 其实平移、旋转、缩放和翻转等变换就是对应了不同的仿射变换矩阵，下面分别来看下。 5.1.1 平移 平移就是 x 和 y 方向上的直接移动，可以上下/左右移动，自由度为 2，变换矩阵可以表示为： 5.1.2 旋转 旋转是坐标轴方向饶原点旋转一定的角度 θ，自由度为 1，不包含平移，如顺时针旋转可以表示为： 思考：如果不是绕原点，而是可变点，自由度是多少呢？（请看下文刚体变换） 5.1.3 翻转 翻转是 x 或 y 某个方向或全部方向上取反，自由度为 2，比如这里以垂直翻转为例： 5.1.4 刚体变换 旋转 + 平移也称刚体变换（Rigid Transform），就是说如果图像变换前后两点间的距离仍然保持不变，那么这种变化就称为刚体变换。刚体变换包括了平移、旋转和翻转，自由度为 3。变换矩阵可以表示为： 由于只是旋转和平移，刚体变换保持了直线间的长度不变，所以也称欧式变换（变化前后保持欧氏距离）。 5.1.5 缩放 缩放是 x 和 y 方向的尺度（倍数）变换，在有些资料上非等比例的缩放也称为拉伸/挤压，等比例缩放自由度为 1，非等比例缩放自由度为 2，矩阵可以表示为： 5.1.6 相似变换 相似变换又称缩放旋转，相似变换包含了旋转、等比例缩放和平移等变换，自由度为 4。在 OpenCV 中，旋转就是用相似变换实现的： 若缩放比例为 scale，旋转角度为 θ，旋转中心是$(center_x,center_y)$，则仿射变换可以表示为： 其中， 相似变换相比刚体变换加了缩放，所以并不会保持欧氏距离不变，但直线间的夹角依然不变。 [!TIP] OpenCV 中默认按照逆时针旋转噢~ 总结一下 变换 矩阵 自由度 保持性质 平移 [I, t]（2×3） 2 方向/长度/夹角/平行性/直线性 刚体 [R, t]（2×3） 3 长度/夹角/平行性/直线性 相似 [sR, t]（2×3） 4 夹角/平行性/直线性 仿射 [T]（2×3） 6 平行性/直线性 透视 [T]（3×3） 8 直线性 5.2 透视变换 前面仿射变换后依然是平行四边形，并不能做到任意的变换。 透视变换（Perspective Transformation）是将二维的图片投影到一个三维视平面上，然后再转换到二维坐标下，所以也称为投影映射（Projective Mapping）。简单来说就是二维 → 三维 → 二维的一个过程。 写成齐次矩阵的形式： 其中，[[a1 b1] [a2 b2]]表示线性变换，[a3 b3]产生透视变换，其余表示平移变换，因此仿射变换是透视变换的子集。接下来再通过除以 Z 轴转换成二维坐标： 透视变换相比仿射变换更加灵活，变换后会产生一个新的四边形，但不一定是平行四边形，所以需要非共线的四个点才能唯一确定，原图中的直线变换后依然是直线。因为四边形包括了所有的平行四边形，所以透视变换包括了所有的仿射变换。 OpenCV 中首先根据变换前后的四个点用cv2.getPerspectiveTransform()生成 3×3 的变换矩阵，然后再用cv2.warpPerspective()进行透视变换。实战演练一下： import cv2 import numpy as np import matplotlib.pyplot as plt img = cv2.imread('card.jpg') # 原图中卡片的四个角点 pts1 = np.float32([[148, 80], [437, 114], [94, 247], [423, 288]]) # 变换后分别在左上、右上、左下、右下四个点 pts2 = np.float32([[0, 0], [320, 0], [0, 178], [320, 178]]) # 生成透视变换矩阵 M = cv2.getPerspectiveTransform(pts1, pts2) # 进行透视变换，参数 3 是目标图像大小 dst = cv2.warpPerspective(img, M, (320, 178)) plt.subplot(121), plt.imshow(img[:, :, ::-1]), plt.title('input') plt.subplot(122), plt.imshow(dst[:, :, ::-1]), plt.title('output') plt.show() 代码中有个img[:, :, ::-1]还记得吗？忘记的话，请看 练习。 当然，我们后面学习了特征提取之后，就可以自动识别角点了。透视变换是一项很酷的功能。比如我们经常会用手机去拍身份证和文件，无论你怎么拍，貌似都拍不正或者有边框。如果你使用过手机上面一些扫描类软件，比如\"扫描全能王\"，\"Office Lens\"，它们能很好地矫正图片，这些软件就是应用透视变换实现的。 5.3 练习 请复习：2 番外篇：无损保存和 Matplotlib。 5.4 引用 维基百科：仿射变换 如何通俗地讲解「仿射变换」这个概念？ 6 番外篇：鼠标绘图 学习如何用鼠标实时绘图。 6.1 目标 捕获鼠标事件 OpenCV 函数：cv2.setMouseCallback() 6.2 教程 6.2.1 知道鼠标在哪儿 OpenCV 中，我们需要创建一个鼠标的回调函数来获取鼠标当前的位置、当前的事件如左键按下/左键释放或是右键单击等等，然后执行相应的功能。 使用cv2.setMouseCallback()来创建鼠标的回调函数，比如我们在左键单击的时候，打印出当前鼠标的位置： import cv2 import numpy as np # 鼠标的回调函数 def mouse_event(event, x, y, flags, param): # 通过 event 判断具体是什么事件，这里是左键按下 if event == cv2.EVENT_LBUTTONDOWN: print((x, y)) img = np.zeros((512, 512, 3), np.uint8) cv2.namedWindow('image') # 定义鼠标的回调函数 cv2.setMouseCallback('image', mouse_event) while(True): cv2.imshow('image', img) # 按下 ESC 键退出 if cv2.waitKey(20) == 27: break 上面的代码先定义鼠标的回调函数mouse_event()，然后在回调函数中判断是否是左键单击事件 EVENT_LBUTTONDOWN，是的话就打印出坐标。需要注意的是，回调函数的参数格式是固定的，不要随意更改。 那除了左键单击之外，还有哪些事件呢？可以用下面的代码打印出来： # 获取所有的事件 events = [i for i in dir(cv2) if 'EVENT' in i] print(events) 6.2.2 综合实例 现在我们来实现一个综合的例子，这个实例会帮助你理解图像交互的一些思想： 在图像上用鼠标画图，可以画圆或矩形，按 m 键在两种模式下切换。左键按下时开始画图，移动到哪儿画到哪儿，左键释放时结束画图。听上去很复杂，是吗？一步步来看： 用鼠标画图：需要定义鼠标的回调函数 mouse_event 画圆或矩形：需要定义一个画图的模式 mode 左键单击、移动、释放：需要捕获三个不同的事件 开始画图，结束画图：需要定义一个画图的标记位 drawing 好，开始 coding 吧： import cv2 import numpy as np drawing = False # 是否开始画图 mode = True # True：画矩形，False：画圆 start = (-1, -1) def mouse_event(event, x, y, flags, param): global start, drawing, mode # 左键按下：开始画图 if event == cv2.EVENT_LBUTTONDOWN: drawing = True start = (x, y) # 鼠标移动，画图 elif event == cv2.EVENT_MOUSEMOVE: if drawing: if mode: cv2.rectangle(img, start, (x, y), (0, 255, 0), 1) else: cv2.circle(img, (x, y), 5, (0, 0, 255), -1) # 左键释放：结束画图 elif event == cv2.EVENT_LBUTTONUP: drawing = False if mode: cv2.rectangle(img, start, (x, y), (0, 255, 0), 1) else: cv2.circle(img, (x, y), 5, (0, 0, 255), -1) img = np.zeros((512, 512, 3), np.uint8) cv2.namedWindow('image') cv2.setMouseCallback('image', mouse_event) while(True): cv2.imshow('image', img) # 按下 m 切换模式 if cv2.waitKey(1) == ord('m'): mode = not mode elif cv2.waitKey(1) == 27: break 效果应该如下图所示： 6.3 小结 要用鼠标绘图，需要用cv2.setMouseCallback()定义回调函数，然后在回调函数中根据不同的 event 事件，执行不同的功能。 6.4 练习 1.（选做）实现用鼠标画矩形，跟实例差不多，但只实时画一个，类似下面动图： 2.（选做）做一个在白色面板上绘图的简单程序，可用滑动条调整颜色和笔刷大小。 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/OpenCV/chapter1-2.html":{"url":"Markdown/OpenCV/chapter1-2.html","title":"1.2 OpenCV基础","keywords":"","body":"1.2 OpenCV基础 教程使用说明参见：基础入门 9 图像混合 学习图片间的数学运算，图像混合。 9.1 目标 图片间的数学运算，如相加、按位运算等 OpenCV 函数：cv2.add(), cv2.addWeighted(), cv2.bitwise_and() 9.2 教程 首先恭喜你已经完成了入门篇的学习噢，接下来我们学习一些 OpenCV 的基础内容，加油(ง •_•)ง 9.2.1 图片相加 要叠加两张图片，可以用cv2.add()函数，相加两幅图片的形状（高度/宽度/通道数）必须相同。numpy 中可以直接用 res = img + img1 相加，但这两者的结果并不相同： import cv2 import numpy as np x = np.uint8([250]) y = np.uint8([10]) print(cv2.add(x, y)) # 250+10 = 260 => 255, 大于 255 取 255 print(x + y) # 250+10 = 260 % 256 = 4, 大于 255 取 255 的余数 如果是二值化图片（只有 0 和 255 两种值），两者结果是一样的（用 numpy 的方式更简便一些）。 9.2.2 图像混合 图像混合cv2.addWeighted()也是一种图片相加的操作，只不过两幅图片的权重不一样，γ 相当于一个修正值： import cv2 img1 = cv2.imread('lena_small.jpg') img2 = cv2.imread('opencv-logo-white.png') res = cv2.addWeighted(img1, 0.6, img2, 0.4, 0) cv2.imshow(\"imgMix\", res) [!TIP] α 和 β 都等于 1 时，就相当于图片相加。 9.2.3 按位操作 按位操作包括按位与/或/非/异或操作，有什么用途呢？比如说我们要实现下图的效果： 如果将两幅图片直接相加会改变图片的颜色，如果用图像混合，则会改变图片的透明度，所以我们需要用按位操作。首先来了解一下掩膜（mask）的概念：掩膜是用一副二值化图片对另外一幅图片进行局部的遮挡，看下图就一目了然了： 所以我们的思路就是把原图中要放 logo 的区域抠出来，再把 logo 放进去就行了： import cv2 img1 = cv2.imread('lena.jpg') img2 = cv2.imread('opencv-logo-white.png') # 把 logo 放在左上角，所以我们只关心这一块区域 rows, cols = img2.shape[:2] roi = img1[:rows, :cols] # 创建掩膜 img2gray = cv2.cvtColor(img2, cv2.COLOR_BGR2GRAY) ret, mask = cv2.threshold(img2gray, 10, 255, cv2.THRESH_BINARY) mask_inv = cv2.bitwise_not(mask) # 保留除 logo 外的背景 img1_bg = cv2.bitwise_and(roi, roi, mask=mask_inv) dst = cv2.add(img1_bg, img2) # 进行融合 img1[:rows, :cols] = dst # 融合后放在原图上 cv2.imshow('img1', img1) cv2.waitKey(0) [!TIP] 掩膜的概念在图像混合/叠加的场景下使用较多，可以多多练习噢！ 9.3 小结 cv2.add()用来叠加两幅图片，cv2.addWeighted()也是叠加两幅图片，但两幅图片的权重不一样。 cv2.bitwise_and(), cv2.bitwise_not(), cv2.bitwise_or(), cv2.bitwise_xor()分别执行按位与/或/非/异或运算。掩膜就是用来对图片进行全局或局部的遮挡。 9.4 接口文档 cv2.add() cv2.addWeighted() cv2.bitwise_and() cv2.bitwise_not() 9.5 引用 掩膜 10 平滑图像 学习模糊/平滑图像，消除噪点。 10.1 目标 模糊/平滑图片来消除图片噪声 OpenCV 函数：cv2.blur(), cv2.GaussianBlur(), cv2.medianBlur(), cv2.bilateralFilter() 10.2 教程 10.2.1 滤波与模糊 推荐大家先阅读：8 番外篇：卷积基础 (图片边框)，有助于理解卷积和滤波的概念。 关于滤波和模糊，很多人分不清，笔者来给大家理理（虽说如此，笔者后面也会混着用，,ԾㅂԾ,,）： 它们都属于卷积，不同滤波方法之间只是卷积核不同（对线性滤波而言） 低通滤波器是模糊，高通滤波器是锐化 低通滤波器就是允许低频信号通过，在图像中边缘和噪点都相当于高频部分，所以低通滤波器用于去除噪点、平滑和模糊图像。高通滤波器则反之，用来增强图像边缘，进行锐化处理。 常见噪声有 椒盐噪声 和 高斯噪声，椒盐噪声可以理解为斑点，随机出现在图像中的黑点或白点；高斯噪声可以理解为拍摄图片时由于光照等原因造成的噪声。 10.2.2 均值滤波 均值滤波是一种最简单的滤波处理，它取的是卷积核区域内元素的均值，用cv2.blur()实现，如 3×3 的卷积核： img = cv2.imread('lena.jpg') blur = cv2.blur(img, (3, 3)) # 均值模糊 所有的滤波函数都有一个可选参数 borderType，这个参数就是 8 番外篇：卷积基础 (图片边框) 中所说的边框填充方式。 10.2.3 方框滤波 方框滤波跟均值滤波很像，如 3×3 的滤波核如下： 用cv2.boxFilter()函数实现，当可选参数 normalize 为 True 的时候，方框滤波就是均值滤波，上式中的 a 就等于 1/9；normalize 为 False 的时候，a=1，相当于求区域内的像素和。 # 前面的均值滤波也可以用方框滤波实现：normalize=True # img: 表示输入的图像，即要进行滤波处理的图像。 # -1: 表示输出图像的深度。如果为-1，表示输出图像的深度将与输入图像的深度相同。 # (3, 3): 卷积核（kernel）的大小。 # normalize=True: 这是一个布尔值，用于指定是否对卷积结果进行归一化。如果设置为True，将对卷积结果进行归一化，否则不进行归一化 blur = cv2.boxFilter(img, -1, (2, 2), normalize=False) 10.2.4 高斯滤波 前面两种滤波方式，卷积核内的每个值都一样，也就是说图像区域中每个像素的权重也就一样。高斯滤波的卷积核权重并不相同：中间像素点权重最高，越远离中心的像素权重越小。来，数学时间( ╯□╰ )，还记得标准正态分布的曲线吗？ 显然这种处理元素间权值的方式更加合理一些。图像是 2 维的，所以我们需要使用2 维的高斯函数。比如 OpenCV 中默认的 3×3 的高斯卷积核（具体原理和卷积核生成方式请参考文末的番外小篇）： OpenCV 中对应函数为cv2.GaussianBlur(src,ksize,sigmaX)： img = cv2.imread('gaussian_noise.bmp') # 均值滤波 vs 高斯滤波 blur = cv2.blur(img, (5, 5)) # 均值滤波 gaussian = cv2.GaussianBlur(img, (5, 5), 1) # 高斯滤波 参数 3 sigmax 值越大，模糊效果越明显。高斯滤波相比均值滤波效率要慢，但可以有效消除高斯噪声，能保留更多的图像细节，所以经常被称为最有用的滤波器。均值滤波与高斯滤波的对比结果如下（均值滤波丢失的细节更多）： 10.2.5 中值滤波 中值又叫中位数，是所有数排序后取中间的值。中值滤波就是用区域内的中值来代替本像素值。所以那种孤立的斑点，如 0 或 255 很容易消除掉，适用于去除椒盐噪声和斑点噪声。中值是一种非线性操作，效率相比前面几种线性滤波要慢。 比如下面这张斑点噪声图，用中值滤波显然更好： img = cv2.imread('salt_noise.bmp', 0) # 均值滤波 vs 中值滤波 blur = cv2.blur(img, (5, 5)) # 均值滤波 median = cv2.medianBlur(img, 5) # 中值滤波 # img: 表示输入的图像，即要进行中值滤波处理的图像。 # 5: 表示在中值滤波过程中使用的核大小，核的大小决定了对每个像素周围的邻域进行排序并取中值的范围。 10.2.6 双边滤波 模糊操作基本都会损失掉图像细节信息，尤其前面介绍的线性滤波器，图像的边缘信息很难保留下来。然而，边缘（edge）信息是图像中很重要的一个特征，所以这才有了双边滤波。用cv2.bilateralFilter()函数实现： img = cv2.imread('lena.jpg') # 双边滤波 vs 高斯滤波 gau = cv2.GaussianBlur(img, (5, 5), 0) # 高斯滤波 blur = cv2.bilateralFilter(img, 9, 75, 75) # 双边滤波 # img: 表示输入的图像，即要进行双边滤波处理的图像。 # 9: 表示在双边滤波中考虑的邻域直径。这是一个正整数，控制了在滤波过程中考虑的像素的范围。 # 75: 表示空间高斯函数的标准差，控制了像素在空间上的权重。较大的值意味着更远的像素将被考虑在内。 # 75: 表示灰度值相似性高斯函数的标准差，控制了像素值相似性的权重。较大的值表示更广泛的灰度范围将被考虑在内。 可以看到，双边滤波明显保留了更多边缘信息。 在图像处理中，边缘信息通常指的是图像中明显变化的区域，即像素值发生显著变化的地方。这些变化可能表示物体之间的边界或不同区域之间的过渡。边缘通常对于理解图像的结构和特征非常重要。 在图像中，边缘可以由以下几种情况引起： 颜色或灰度的跳变： 当图像中相邻区域的像素值发生显著变化时，这可能表示物体的边界。例如，在一张黑白图像中，物体与背景之间的灰度变化就可能形成边缘。 纹理变化： 图像中的纹理变化也可能导致边缘的出现。如果一个区域具有不同的纹理特征，与相邻区域相比，这也可能被认为是一个边缘。 深度或阴影变化： 在包含光照和阴影的图像中，深度变化或阴影的出现也可能导致边缘。 边缘信息对于许多图像处理任务非常重要，例如物体检测、分割、识别等。保留图像中的边缘信息可以帮助算法更好地理解图像内容，并提高对图像特征的提取和识别能力。在滤波操作中，双边滤波是一种能够平滑图像同时保留边缘信息的技术。 10.3 番外小篇：高斯滤波卷积核 要解释高斯滤波卷积核是如何生成的，需要先复习下概率论的知识（What？？又是数学( ╯□╰ )） 一维的高斯函数/正态分布X~N(u,σ2)： 当u=0,σ2=1时，称为标准正态分布X~N(0,1)： 二维 X/Y 相互独立的高斯函数： 由上可知，二维高斯函数具有可分离性。所以 OpenCV 分两步计算二维高斯卷积，先水平再垂直，每个方向上都是一维的卷积。OpenCV 中这个一维卷积的计算公式类似于上面的一维高斯函数： 其中 i=0…ksize-1，α 是一个常数，也称为缩放因子，它使得(ΣG(i)=1) 比如我们可以用cv2.getGaussianKernel(ksize,sigma)来生成一维卷积核： sigmasigma=0.3*((ksize-1)*0.5 - 1) + 0.8 sigma>0 时，sigma=sigma print(cv2.getGaussianKernel(3, 0)) # 结果：[[0.25][0.5][0.25]] 生成之后，先进行三次的水平卷积： 然后再进行垂直的三次卷积： 这就是 OpenCV 中高斯卷积核的生成方式。其实，OpenCV 源码中对小于 7×7 的核是直接计算好放在数组里面的，这样计算速度会快一点，感兴趣的可以看下源码：getGaussianKernel() 上面矩阵也可以写成： 10.4 小结 在不知道用什么滤波器好的时候，优先高斯滤波cv2.GaussianBlur()，然后均值滤波cv2.blur()。 斑点和椒盐噪声优先使用中值滤波cv2.medianBlur()。 要去除噪点的同时尽可能保留更多的边缘信息，使用双边滤波cv2.bilateralFilter()。 线性滤波方式：均值滤波、方框滤波、高斯滤波（速度相对快）。 非线性滤波方式：中值滤波、双边滤波（速度相对慢）。 10.5 接口文档 cv2.blur() cv2.boxFilter() cv2.GaussianBlur() cv2.getGaussianKernel() cv2.medianBlur() cv2.bilateralFilter() 10.6 引用 图像平滑处理 11 边缘检测 学习使用 Canny 获取图像的边缘。 Canny J . A Computational Approach To Edge Detection[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 1986, PAMI-8(6):679-698. 11.1 目标 Canny 边缘检测的简单概念 OpenCV 函数：cv2.Canny() 11.2 教程 Canny 边缘检测方法常被誉为边缘检测的最优方法，废话不多说，先看个例子： import cv2 import numpy as np img = cv2.imread('handwriting.jpg', 0) edges = cv2.Canny(img, 30, 70) # canny 边缘检测 cv2.imshow('Img->Canny', np.hstack((img, edges))) cv2.waitKey(0) cv2.Canny()进行边缘检测，参数 2、3 表示最低、高阈值，下面来解释下具体原理。 [!TIP] 之前我们用低通滤波的方式模糊了图片，那反过来，想得到物体的边缘，就需要用到高通滤波。推荐先阅读：9 番外篇：图像梯度。 11.2.1 Canny 边缘检测 Canny 边缘提取的具体步骤如下： 1 使用 5×5 高斯滤波消除噪声： 边缘检测本身属于锐化操作，对噪点比较敏感，所以需要进行平滑处理。高斯滤波的具体内容参考前一篇：10 平滑图像 2 计算图像梯度的方向： 首先使用 Sobel 算子计算两个方向上的梯度Gx和Gy，然后算出梯度的方向： 保留这四个方向的梯度：0°/45°/90°/135°，有什么用呢？我们接着看。 3 取局部极大值： 梯度其实已经表示了轮廓，但为了进一步筛选，可以在上面的四个角度方向上再取局部极大值： 比如，A 点在 45° 方向上大于 B/C 点，那就保留它，把 B/C 设置为 0。 4 滞后阈值： 经过前面三步，就只剩下 0 和可能的边缘梯度值了，为了最终确定下来，需要设定高低阈值： 像素点的值大于最高阈值，那肯定是边缘（上图 A） 同理像素值小于最低阈值，那肯定不是边缘 像素值介于两者之间，如果与高于最高阈值的点连接，也算边缘，所以上图中 C 算，B 不算 Canny 推荐的高低阈值比在 2:1 到 3:1 之间。 11.2.2 先阈值分割后检测 其实很多情况下，阈值分割后再检测边缘，效果会更好： import cv2 import numpy as np img = cv2.imread('handwriting.jpg', 0) _, thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU) edges = cv2.Canny(thresh, 30, 70) cv2.imshow('Img->Threshold->Canny', np.hstack((img, thresh, edges))) cv2.waitKey(0) 代码中笔者用了4 番外篇：Otsu 阈值法中的自动阈值分割。如果你不太了解，大可以使用传统的方法，不过如果是下面这种图片，推荐用 Otsu 阈值法。另外 Python 中某个值不用的话，就写个下划线'_'。 11.3 练习 （选做）如果你不太理解高低阈值的效果，创建两个滑动条来调节它们的值看看： 11.4 小结 Canny 是用的最多的边缘检测算法，用cv2.Canny()实现。 11.5 接口文档 cv2.Canny() 11.6 引用 Canny 边缘检测 Canny J . A Computational Approach To Edge Detection[J]. IEEE Transactions on Pattern Analysis and Machine Intelligence, 1986, PAMI-8(6):679-698. 12 腐蚀与膨胀 学习常用形态学操作：腐蚀膨胀，开运算和闭运算。 12.1 目标 了解形态学操作的概念 学习膨胀、腐蚀、开运算和闭运算等形态学操作 OpenCV 函数：cv2.erode(), cv2.dilate(), cv2.morphologyEx() 12.2 教程 12.2.1 啥叫形态学操作 形态学操作其实就是改变物体的形状，比如腐蚀就是\"变瘦\"，膨胀就是\"变胖\"，看下图就明白了： [!TIP] 形态学操作一般作用于二值化图，来连接相邻的元素或分离成独立的元素。腐蚀和膨胀是针对图片中的白色部分！ 12.2.2 腐蚀 腐蚀的效果是把图片\"变瘦\"，其原理是在原图的小区域内取局部最小值。因为是二值化图，只有 0 和 255，所以小区域内有一个是 0 该像素点就为 0： 这样原图中边缘地方就会变成 0，达到了瘦身目的（小胖福利(●ˇ∀ˇ●)） OpenCV 中用cv2.erode()函数进行腐蚀，只需要指定核的大小就行： import cv2 import numpy as np img = cv2.imread('j.bmp', 0) kernel = np.ones((5, 5), np.uint8) erosion = cv2.erode(img, kernel) # 腐蚀 cv2.imshow('Img->Erosion', np.hstack((img, erosion))) cv2.waitKey(0) cv2.destroyAllWindows() 这个核也叫结构元素，因为形态学操作其实也是应用卷积来实现的。结构元素可以是矩形/椭圆/十字形，可以用cv2.getStructuringElement()来生成不同形状的结构元素，比如： kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5)) # 矩形结构 kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (5, 5)) # 椭圆结构 kernel = cv2.getStructuringElement(cv2.MORPH_CROSS, (5, 5)) # 十字形结构 12.2.3 膨胀 膨胀与腐蚀相反，取的是局部最大值，效果是把图片\"变胖\"： dilation = cv2.dilate(img, kernel) # 膨胀 12.2.4 开/闭运算 先腐蚀后膨胀叫开运算（因为先腐蚀会分开物体，这样容易记住），其作用是：分离物体，消除小区域。这类形态学操作用cv2.morphologyEx()函数实现： kernel = cv2.getStructuringElement(cv2.MORPH_RECT, (5, 5)) # 定义结构元素 img = cv2.imread('j_noise_out.bmp', 0) opening = cv2.morphologyEx(img, cv2.MORPH_OPEN, kernel) # 开运算 闭运算则相反：先膨胀后腐蚀（先膨胀会使白色的部分扩张，以至于消除\"闭合\"物体里面的小黑洞，所以叫闭运算） img = cv2.imread('j_noise_in.bmp', 0) closing = cv2.morphologyEx(img, cv2.MORPH_CLOSE, kernel) # 闭运算 [!TIP] 很多人对开闭运算的作用不是很清楚（好吧，其实是比较容易混 ◑﹏◐）。且看上图 ↑：如果我们的目标物体外面有很多无关的小区域，就用开运算去除掉；如果物体内部有很多小黑洞，就用闭运算填充掉。 接下来的 3 种形态学操作并不常用，大家有兴趣可以看看（因为较短，没有做成番外篇）： 12.2.5 其他形态学操作 形态学梯度：膨胀图减去腐蚀图，dilation - erosion，这样会得到物体的轮廓： img = cv2.imread('school.bmp', 0) gradient = cv2.morphologyEx(img, cv2.MORPH_GRADIENT, kernel) 顶帽：原图减去开运算后的图：src - opening tophat = cv2.morphologyEx(img, cv2.MORPH_TOPHAT, kernel) 黑帽：闭运算后的图减去原图：closing - src blackhat = cv2.morphologyEx(img, cv2.MORPH_BLACKHAT, kernel) 12.3 小结 形态学操作就是改变物体的形状，如腐蚀使物体\"变瘦\"，膨胀使物体\"变胖\"。 先腐蚀后膨胀会分离物体，所以叫开运算，常用来去除小区域物体。 先膨胀后腐蚀会消除物体内的小洞，所以叫闭运算。开/闭理解了之后很容易记忆噢(⊙o⊙)。 12.4 接口文档 cv2.erode() cv2.getStructuringElement() cv2.dilate() cv2.MorphShapes cv2.morphologyEx() cv2.MorphTypes 12.5 引用 Morphological Operations Computer Vision: Algorithms and Applications 13 轮廓 学习如何寻找并绘制轮廓。 13.1 目标 了解轮廓概念 寻找并绘制轮廓 OpenCV 函数：cv2.findContours(), cv2.drawContours() 13.2 教程 13.2.1 啥叫轮廓 轮廓是一系列相连的点组成的曲线，代表了物体的基本外形。 谈起轮廓不免想到边缘，它们确实很像。简单的说，轮廓是连续的，边缘并不全都连续（下图）。其实边缘主要是作为图像的特征使用，比如可以用边缘特征区分脸和手，而轮廓主要用来分析物体的形态，比如物体的周长和面积等，可以说边缘包括轮廓。 寻找轮廓的操作一般用于二值化图，所以通常会使用阈值分割或 Canny 边缘检测先得到二值图。 [!TIP] 寻找轮廓是针对白色物体的，一定要保证物体是白色，而背景是黑色，不然很多人在寻找轮廓时会找到图片最外面的一个框。 13.2.2 寻找轮廓 使用cv2.findContours()寻找轮廓： import cv2 img = cv2.imread('handwriting.jpg') img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) ret, thresh = cv2.threshold(img_gray, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU) # 寻找二值化图中的轮廓 contours, hierarchy = cv2.findContours( thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE) print(len(contours)) # 结果为 2 参数 2：轮廓的查找方式，一般使用 cv2.RETR_TREE，表示提取所有的轮廓并建立轮廓间的层级。更多请参考：RetrievalModes 参数 3：轮廓的近似方法。比如对于一条直线，我们可以存储该直线的所有像素点，也可以只存储起点和终点。使用 cv2.CHAIN_APPROX_SIMPLE 就表示用尽可能少的像素点表示轮廓。更多请参考：ContourApproximationModes 简便起见，这两个参数也可以直接用真值 3 和 2 表示。 函数有 2 个返回值，hierarchy 是轮廓间的层级关系（轮廓层级参看10 番外篇：轮廓层级），这两个暂时不用理会。我们主要看 contours，它就是找到的轮廓了，以数组形式存储，记录了每条轮廓的所有像素点的坐标(x,y)。 13.2.3 绘制轮廓 轮廓找出来后，为了方便观看，可以像前面图中那样用红色画出来：cv2.drawContours() cv2.drawContours(img, contours, -1, (0, 0, 255), 2) 其中参数 2 就是得到的 contours，参数 3 表示要绘制哪一条轮廓，-1 表示绘制所有轮廓，参数 4 是颜色（B/G/R 通道，所以(0,0,255) 表示红色），参数 5 是线宽，之前在绘制图形中介绍过。 [!TIP] 很多人画图时明明用了彩色，但没有效果，请检查你是在哪个图上画，画在灰度图和二值图上显然是没有彩色的(⊙o⊙)。 一般情况下，我们会首先获得要操作的轮廓，再进行轮廓绘制及分析： cnt = contours[1] cv2.drawContours(img, [cnt], 0, (0, 0, 255), 2) 13.3 小结 轮廓特征非常有用，使用cv2.findContours()寻找轮廓，cv2.drawContours()绘制轮廓。 13.4 接口文档 cv2.findContours() cv2.RetrievalModes cv2.ContourApproximationModes cv2.drawContours() 14 轮廓特征 学习计算轮廓特征，如面积、周长、最小外接矩形等。 14.1 目标 计算物体的周长、面积、质心、最小外接矩形等 OpenCV 函数：cv2.contourArea(), cv2.arcLength(), cv2.approxPolyDP() 等 14.2 教程 在计算轮廓特征之前，我们先用上一节的代码把轮廓找到： import cv2 import numpy as np img = cv2.imread('handwriting.jpg', 0) _, thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU) contours, hierarchy = cv2.findContours(thresh, 3, 2) # 以数字 3 的轮廓为例 cnt = contours[0] 为了便于绘制，我们创建出两幅彩色图，并把轮廓画在第一幅图上： img_color1 = cv2.cvtColor(image, cv2.COLOR_GRAY2BGR) img_color2 = np.copy(img_color1) cv2.drawContours(img_color1, [cnt], 0, (0, 0, 255), 2) 14.2.1 轮廓面积 area = cv2.contourArea(cnt) 注意轮廓特征计算的结果并不等同于像素点的个数，而是根据几何方法算出来的，所以有小数。 如果统计二值图中像素点个数，应尽量避免循环，可以使用cv2.countNonZero()，更加高效。 14.2.2 轮廓周长 perimeter = cv2.arcLength(cnt, True) 参数 2 表示轮廓是否封闭，显然我们的轮廓是封闭的，所以是 True。 14.2.3 图像矩 矩可以理解为图像的各类几何特征，详情请参考：Image Moments M = cv2.moments(cnt) M 中包含了很多轮廓的特征信息，比如 M['m00'] 表示轮廓面积，与前面cv2.contourArea()计算结果是一样的。质心也可以用它来算： cx, cy = M['m10'] / M['m00'], M['m01'] / M['m00'] 14.2.4 外接矩形 形状的外接矩形有两种，如下图。绿色的叫外接矩形，表示不考虑旋转并且能包含整个轮廓的矩形。蓝色的叫最小外接矩，考虑了旋转： x, y, w, h = cv2.boundingRect(cnt) # 外接矩形 cv2.rectangle(img_color1, (x, y), (x + w, y + h), (0, 255, 0), 2) rect = cv2.minAreaRect(cnt) # 最小外接矩形 box = np.intp(cv2.boxPoints(rect)) # 矩形的四个角点取整 cv2.drawContours(img_color1, [box], 0, (255, 0, 0), 2) 其中 np.intp(x) 是把 x 取整的操作，比如 377.93 就会变成 377，也可以用 x.astype(np.int)。 14.2.5 最小外接圆 外接圆跟外接矩形一样，找到一个能包围物体的最小圆： (x, y), radius = cv2.minEnclosingCircle(cnt) (x, y, radius) = np.intp((x, y, radius)) # 圆心和半径取整 cv2.circle(img_color2, (x, y), radius, (0, 0, 255), 2) 14.2.6 拟合椭圆 我们可以用得到的轮廓拟合出一个椭圆： ellipse = cv2.fitEllipse(cnt) cv2.ellipse(img_color2, ellipse, (255, 255, 0), 2) 14.2.7 形状匹配 cv2.matchShapes()可以检测两个形状之间的相似度，返回值越小，越相似。先读入下面这张图片： img = cv2.imread('shapes.jpg', 0) _, thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU) contours, hierarchy = cv2.findContours(thresh, 3, 2) img_color = cv2.cvtColor(thresh, cv2.COLOR_GRAY2BGR) # 用于绘制的彩色图 图中有 3 条轮廓，我们用 A/B/C 表示： cnt_a, cnt_b, cnt_c = contours[0], contours[1], contours[2] print(cv2.matchShapes(cnt_b, cnt_b, 1, 0.0)) # 0.0 print(cv2.matchShapes(cnt_b, cnt_c, 1, 0.0)) # 2.17e-05 print(cv2.matchShapes(cnt_b, cnt_a, 1, 0.0)) # 0.418 可以看到 BC 相似程度比 AB 高很多，并且图形的旋转或缩放并没有影响。其中，参数 3 是匹配方法，详情可参考：ShapeMatchModes，参数 4 是 OpenCV 的预留参数，暂时没有实现，可以不用理会。 形状匹配是通过图像的 Hu 矩来实现的(cv2.HuMoments())，大家如果感兴趣，可以参考：Hu-Moments 14.3 练习 前面我们是对图片中的数字 3 进行轮廓特征计算的，大家换成数字 1 看看。 （选做）用形状匹配比较两个字母或数字（这相当于很简单的一个OCR噢）。 14.4 小结 常用的轮廓特征： cv2.contourArea()算面积，cv2.arcLength()算周长，cv2.boundingRect()算外接矩。 cv2.minAreaRect()算最小外接矩，cv2.minEnclosingCircle()算最小外接圆。 cv2.matchShapes()进行形状匹配。 14.5 接口文档 cv2.contourArea() cv2.arcLength() cv2.moments() cv2.boundingRect() cv2.minAreaRect() cv2.minEnclosingCircle() cv2.fitEllipse() cv2.matchShapes() cv2.ShapeMatchModes 15 直方图 学习计算并绘制直方图，直方图均衡化等。 15.1 目标 计算并绘制直方图 （自适应）直方图均衡化 OpenCV 函数：cv2.calcHist(), cv2.equalizeHist() 15.2 教程 15.2.1 啥叫直方图 简单来说，直方图就是图像中每个像素值的个数统计，比如说一副灰度图中像素值为 0 的有多少个，1 的有多少个…… 在计算直方图之前，有几个术语先来了解一下： dims: 要计算的通道数，对于灰度图 dims=1，普通彩色图 dims=3 range: 要计算的像素值范围，一般为[0,256) bins: 子区段数目，如果我们统计 0~255 每个像素值，bins=256；如果划分区间，比如 0~15, 16~31 … 240~255 这样 16 个区间，bins=16 15.2.2 计算直方图 OpenCV 和 Numpy 中都提供了计算直方图的函数，我们对比下它们的性能。 15.2.2.1 OpenCV 中直方图计算 使用cv2.calcHist(images, channels, mask, histSize, ranges)计算，其中： 参数 1：要计算的原图，以方括号的传入，如：[img] 参数 2：类似前面提到的 dims，灰度图写[0] 就行，彩色图 B/G/R 分别传入[0]/[1]/[2] 参数 3：要计算的区域，计算整幅图的话，写 None 参数 4：前面提到的 bins 参数 5：前面提到的 range import cv2 import numpy as np import matplotlib.pyplot as plt img = cv2.imread('hist.jpg', 0) hist = cv2.calcHist([img], [0], None, [256], [0, 256]) # 性能：0.025288 s 15.2.2.2 Numpy 中直方图计算 也可用 Numpy 的函数计算，其中ravel()函数将二维矩阵展平变成一维数组，之前有提到过： hist, bins = np.histogram(img.ravel(), 256, [0, 256]) # 性能：0.020628 s [!TIP] Numpy 中还有一种更高效的方式：(还记得怎么评估性能吗：1 番外篇：代码性能优化) hist = np.bincount(img.ravel(), minlength=256) # 性能：0.003163 s 计算出直方图之后，怎么把它画出来呢？ 15.2.3 绘制直方图 其实 Matplotlib 自带了一个计算并绘制直方图的功能，不需要用到上面的函数： plt.hist(img.ravel(), 256, [0, 256]) plt.show() 当然，也可以用前面计算出来的结果绘制： plt.plot(hist) plt.show() 从直方图上可以看到图片的大部分区域集中在 150 偏白的附近，这其实并不是很好的效果，下面我们来看看如何改善它。 使用 OpenCV 的画线功能也可以画直方图，不过太麻烦了，有兴趣的可以看下官方示例：hist.py。 15.2.4 直方图均衡化 一副效果好的图像通常在直方图上的分布比较均匀，直方图均衡化就是用来改善图像的全局亮度和对比度。其实从观感上就可以发现，前面那幅图对比度不高，偏灰白。对均衡化算法感兴趣的同学可参考：维基百科：直方图均衡化 equ = cv2.equalizeHist(img) OpenCV 中用cv2.equalizeHist()实现均衡化。我们把两张图片并排显示，对比一下： cv2.imshow('equalization', np.hstack((img, equ))) # 并排显示 cv2.waitKey(0) 可以看到均衡化后图片的亮度和对比度效果明显好于原图。 15.2.5 自适应均衡化 不难看出来，直方图均衡化是应用于整幅图片的，会有什么问题呢？看下图： 很明显，因为全局调整亮度和对比度的原因，脸部太亮，大部分细节都丢失了。 自适应均衡化就是用来解决这一问题的：它在每一个小区域内（默认 8×8）进行直方图均衡化。当然，如果有噪点的话，噪点会被放大，需要对小区域内的对比度进行了限制，所以这个算法全称叫：对比度受限的自适应直方图均衡化CLAHE(Contrast Limited Adaptive Histogram Equalization)。 # 自适应均衡化，参数可选 clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8, 8)) # clipLimit: 表示阈值，用于限制对比度的增强。对比度限制是CLAHE算法的一个重要参数，它控制了每个像素周围直方图均衡化的程度。较大的值将导致更强烈的限制，可能防止过度增强对比度。 # tileGridSize: 这是用于图像分割的瓦片（tile）的大小。图像将被分成多个瓦片，每个瓦片将独立进行直方图均衡化。tileGridSize指定了这些瓦片的大小，它是一个包含两个整数的元组，表示瓦片的行数和列数 cl1 = clahe.apply(img) 15.3 练习 cv2.calcHist()函数中的参数 3 是指要计算的区域(mask：目标区域白色，其余黑色)，编写一个只计算图片左上角 200×200 区域直方图的程序。 15.4 小结 直方图是一种分析图像的手段。 cv2.calcHist()和numpy.bincount()均可用来计算直方图，使用 Matplotlib 绘制直方图。 均衡化用来使图像的直方图分布更加均匀，提升亮度和对比度。 15.5 引用 维基百科：直方图均衡化 维基百科：自适应直方图均衡化 Cambridge in Color website 16 模板匹配 学习使用模板匹配在图像中寻找物体。 16.1 目标 使用模板匹配在图像中寻找物体 OpenCV 函数：cv2.matchTemplate(), cv2.minMaxLoc() 16.2 教程 16.2.1 模板匹配 模板匹配就是用来在大图中找小图，也就是说在一副图像中寻找另外一张模板图像的位置： 用cv2.matchTemplate()实现模板匹配。首先我们来读入图片和模板： import cv2 import numpy as np from matplotlib import pyplot as plt img = cv2.imread('lena.jpg', 0) template = cv2.imread('face.jpg', 0) h, w = template.shape[:2] # rows->h, cols->w 匹配函数返回的是一副灰度图，最白的地方表示最大的匹配。使用cv2.minMaxLoc()函数可以得到最大匹配值的坐标，以这个点为左上角角点，模板的宽和高画矩形就是匹配的位置了： # 相关系数匹配方法：cv2.TM_CCOEFF res = cv2.matchTemplate(img, template, cv2.TM_CCOEFF) min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res) left_top = max_loc # 左上角 right_bottom = (left_top[0] + w, left_top[1] + h) # 右下角 cv2.rectangle(img, left_top, right_bottom, 255, 2) # 画出矩形位置 16.2.2 原理 这部分可看可不看，不太理解也没关系，还记得前面的方法吗？不懂得就划掉(✿◕‿◕✿) 模板匹配的原理其实很简单，就是不断地在原图中移动模板图像去比较，有 6 种不同的比较方法，详情可参考：TemplateMatchModes 平方差匹配 CV_TM_SQDIFF：用两者的平方差来匹配，最好的匹配值为 0 归一化平方差匹配 CV_TM_SQDIFF_NORMED 相关匹配 CV_TM_CCORR：用两者的乘积匹配，数值越大表明匹配程度越好 归一化相关匹配 CV_TM_CCORR_NORMED 相关系数匹配 CV_TM_CCOEFF：用两者的相关系数匹配，1 表示完美的匹配，-1 表示最差的匹配 归一化相关系数匹配 CV_TM_CCOEFF_NORMED 归一化的意思就是将值统一到 0~1。模板匹配也是应用卷积来实现的：假设原图大小为 W×H，模板图大小为 w×h，那么生成图大小是(W-w+1)×(H-h+1)，生成图中的每个像素值表示原图与模板的匹配程度。 16.2.3 匹配多个物体 前面我们是找最大匹配的点，所以只能匹配一次。我们可以设定一个匹配阈值来匹配多次： # 1.读入原图和模板 img_rgb = cv2.imread('mario.jpg') img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY) template = cv2.imread('mario_coin.jpg', 0) h, w = template.shape[:2] # 2.标准相关模板匹配 res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED) threshold = 0.8 # 3.这边是 Python/Numpy 的知识，后面解释 loc = np.where(res >= threshold) # 匹配程度大于%80 的坐标 y,x for pt in zip(*loc[::-1]): # *号表示可选参数 right_bottom = (pt[0] + w, pt[1] + h) cv2.rectangle(img_rgb, pt, right_bottom, (0, 0, 255), 2) 第 3 步有几个 Python/Numpy 的重要知识，来大致看下： np.where()在这里返回 res 中值大于 0.8 的所有坐标，如： x = np.arange(9.).reshape(3, 3) print(np.where(x > 5)) # 结果 (先 y 坐标，再 x 坐标)：(array([2, 2, 2]), array([0, 1, 2])) zip()函数，功能强大到难以解释，举个简单例子就知道了： x = [1, 2, 3] y = [4, 5, 6] print(list(zip(x, y))) # [(1, 4), (2, 5), (3, 6)] 这样大家就能理解前面代码的用法了吧：因为 loc 是先 y 坐标再 x 坐标，所以用 loc[::-1] 翻转一下，然后再用 zip 函数拼接在一起。 16.3 练习 之前我们有学过形状匹配，不论形状旋转/缩放都可以匹配到。思考一下，图片旋转或缩放的话模板匹配还有作用吗？ 16.4 小结 模板匹配用来在大图中找小图。 cv2.matchTemplate()用来进行模板匹配。 16.5 引用 模板匹配 TemplateMatchModes 17 霍夫变换 学习使用霍夫变换识别出图像中的直线和圆。 17.1 目标 理解霍夫变换的实现 分别使用霍夫线变换和圆变换检测图像中的直线和圆 OpenCV 函数：cv2.HoughLines(), cv2.HoughLinesP(), cv2.HoughCircles() 17.2 教程 17.2.1 理解霍夫变换 霍夫变换常用来在图像中提取直线和圆等几何形状，笔者来做个简易的解释： 学过几何的都知道，直线可以分别用直角坐标系和极坐标系来表示： 那么经过某个点(x0,y0)的所有直线都可以用这个式子来表示： 也就是说每一个(r,θ)都表示一条经过(x0,y0)直线，那么同一条直线上的点必然会有同样的(r,θ)。如果将某个点所有的(r,θ)绘制成下面的曲线，那么同一条直线上的点的(r,θ)曲线会相交于一点： OpenCV 中首先计算(r,θ)累加数，累加数超过一定值后就认为在同一直线上。 霍夫变换通过将图像中的每个点映射到一个累加器空间（Hough空间）中，通过在该空间中累加点的信息，可以找到对应于在图像中共线的点的直线参数。对于直线检测，通常使用极坐标表示直线，即(r, θ)，其中r是从原点到直线的距离，θ是直线与水平轴的夹角。 在霍夫直线检测中，计算(r, θ)累加数的过程如下： 对于图像中的每个边缘点，计算(r, θ)空间上的可能直线参数。 对于每个边缘点的(r, θ)，在霍夫空间中进行累加，增加相应位置的计数器。 当某个(r, θ)位置的计数超过了一个阈值（通常设定的阈值），则认为在霍夫空间中找到了一个共线的点组，对应于一条直线。 这种方法的思想是，如果在图像中存在一条直线，那么通过这条直线上的点在霍夫空间中形成的曲线就会交于一点或者一组点，而其他非共线的点则会在霍夫空间中形成零散的计数。 霍夫变换的优点是对于存在噪声、间断和部分遮挡的图像中的直线检测仍然较为鲁棒。 17.2.2 霍夫直线变换 OpenCV 中用cv2.HoughLines()在二值图上实现霍夫变换，函数返回的是一组直线的(r,θ)数据： import cv2 import numpy as np # 加载图片，转为二值图 img = cv2.imread('shapes.jpg') drawing = np.zeros(img.shape[:], dtype=np.uint8) gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) edges = cv2.Canny(gray, 50, 150) # 霍夫直线变换 lines = cv2.HoughLines(edges, 0.8, np.pi / 180, 90) 函数中： 参数 1：要检测的二值图（一般是阈值分割或边缘检测后的图） 参数 2：距离 r 的精度，值越大，考虑越多的线 参数 3：角度 θ 的精度，值越小，考虑越多的线 参数 4：累加数阈值，值越小，考虑越多的线 # 将检测的线画出来（注意是极坐标噢） for line in lines: rho, theta = line[0] a = np.cos(theta) b = np.sin(theta) x0 = a * rho y0 = b * rho x1 = int(x0 + 1000 * (-b)) y1 = int(y0 + 1000 * (a)) x2 = int(x0 - 1000 * (-b)) y2 = int(y0 - 1000 * (a)) cv2.line(drawing, (x1, y1), (x2, y2), (0, 0, 255)) 17.2.3 统计概率霍夫直线变换 前面的方法又称为标准霍夫变换，它会计算图像中的每一个点，计算量比较大，另外它得到的是整一条线（r 和 θ），并不知道原图中直线的端点。所以提出了统计概率霍夫直线变换(Probabilistic Hough Transform)，是一种改进的霍夫变换： drawing = np.zeros(img.shape[:], dtype=np.uint8) # 统计概率霍夫线变换 lines = cv2.HoughLinesP(edges, 0.8, np.pi / 180, 90, minLineLength=50, maxLineGap=10) 前面几个参数跟之前的一样，有两个可选参数： minLineLength：最短长度阈值，比这个长度短的线会被排除 maxLineGap：同一直线两点之间的最大距离 # 将检测的线画出来 for line in lines: x1, y1, x2, y2 = line[0] cv2.line(drawing, (x1, y1), (x2, y2), (0, 255, 0), 1, lineType=cv2.LINE_AA) cv2.LINE_AA在之前绘图功能中讲解过，表示抗锯齿线型。 17.2.4 霍夫圆变换 霍夫圆变换跟直线变换类似，只不过线是用(r, θ)表示，圆是用(x_center, y_center, r)来表示，从二维变成了三维，数据量变大了很多；所以一般使用霍夫梯度法减少计算量，对该算法感兴趣的同学可参考：Circle Hough Transform drawing = np.zeros(img.shape[:], dtype=np.uint8) # 霍夫圆变换 circles = cv2.HoughCircles(edges, cv2.HOUGH_GRADIENT, 1, 20, param2=30) circles = np.intp(np.around(circles)) 其中， 参数 2：变换方法，一般使用霍夫梯度法，详情：HoughModes 参数 3 dp=1：表示霍夫梯度法中累加器图像的分辨率与原图一致 参数 4：两个不同圆圆心的最短距离 参数 5：param2 跟霍夫直线变换中的累加数阈值一样 # 将检测的圆画出来 for i in circles[0, :]: cv2.circle(drawing, (i[0], i[1]), i[2], (0, 255, 0), 2) # 画出外圆 cv2.circle(drawing, (i[0], i[1]), 2, (0, 0, 255), 3) # 画出圆心 17.3 小结 霍夫变换用来提取图像中的直线和圆等几何形状。 霍夫直线变换：cv2.HoughLines()（整条直线）, cv2.HoughLinesP()。 霍夫圆变换：cv2.HoughCircles()。 17.4 引用 Hough transform 经典霍夫变换（Hough Transform） 7 番外篇：亮度与对比度 学习如何调整图片的亮度和对比度。 7.1 亮度与对比度 亮度调整是将图像像素的强度整体变大/变小，对比度调整指的是图像暗处的像素强度变低，亮处的像素强度变高，从而拓宽某个区域内的显示精度。 OpenCV 中亮度和对比度应用这个公式来计算：g(x)=αf(x)+β，其中：α、β常称为增益与偏置值，分别控制图片的对比度和亮度。 [!TIP] 此处对 α/β 控制对比度和亮度有争议，具体请参考：OpenCV 关于对比度和亮度的误解。 import cv2 import numpy as np img = cv2.imread('lena.jpg') # 此处需注意，请参考后面的解释 res = np.uint8(np.clip((1.5 * img + 10), 0, 255)) tmp = np.hstack((img, res)) # 两张图片横向合并（便于对比显示） cv2.imshow('Img->ContrastBrightness', tmp) cv2.waitKey(0) 还记得图像混合那一节中 numpy 对数据溢出的取模处理吗？250+10 = 260 => 260%256=4。它并不适用于我们的图像处理，所以用 np.clip() 函数将数据限定：a a=0, a>255 => a=255。 7.2 练习 创建两个滑动条分别调整对比度和亮度（对比度范围：0~0.3，亮度：0~100）。提示：因为滑动条没有小数，所以可以设置为 0~300，然后乘以 0.01。 亮度/对比度用 C++实现也很有趣，推荐阅读：OpenCV 改变图像亮度和对比度以及优化。 7.3 引用 numpy.clip() OpenCV 关于对比度和亮度的误解 OpenCV 改变图像亮度和对比度以及优化 Mat::convertTo 8 番外篇：卷积基础 - 图片边框 了解卷积/滤波的基础知识，给图片添加边框。 卷积的概念其实很好理解，下面我就给大家做个最简单的解释，绝对轻松加愉快的辣 o(￣ ▽ ￣)o 8.1 卷积 什么是二维卷积呢？看下面一张图就一目了然： 卷积就是循环对图像跟一个核逐个元素相乘再求和得到另外一副图像的操作，比如结果图中第一个元素 5 是怎么算的呢？原图中 3×3 的区域与 3×3 的核逐个元素相乘再相加： 算完之后，整个框再往右移一步继续计算，横向计算完后，再往下移一步继续计算……网上有一副很经典的动态图，方便我们理解卷积： 8.2 padding 不难发现，前面我们用 3×3 的核对一副 6×6 的图像进行卷积，得到的是 4×4 的图，图片缩小了！那怎么办呢？我们可以把原图扩充一圈，再卷积，这个操作叫填充 padding。 事实上，原图为 n×n，卷积核为 f×f，最终结果图大小为(n-f+1) × (n-f+1)。 那么扩展的这一层应该填充什么值呢？OpenCV 中有好几种填充方式，都使用cv2.copyMakeBorder()函数实现，一起来看看。 8.3 添加边框 cv2.copyMakeBorder()用来给图片添加边框，它有下面几个参数： src：要处理的原图 top, bottom, left, right：上下左右要扩展的像素数 borderType：边框类型，这个就是需要关注的填充方式，详情请参考：BorderTypes 其中默认方式和固定值方式最常用，我们详细说明一下： 8.3.1 固定值填充 顾名思义，cv2.BORDER_CONSTANT这种方式就是边框都填充成一个固定的值，比如下面的程序都填充 0： img = cv2.imread('6_by_6.bmp', 0) print(img) # 固定值边框，统一都填充 0 也称为 zero padding cons = cv2.copyMakeBorder(img, 1, 1, 1, 1, cv2.BORDER_CONSTANT, value=0) print(cons) 8.3.2 默认边框类型 默认边框cv2.BORDER_DEFAULT其实是取镜像对称的像素填充，比较拗口，一步步解释： default = cv2.copyMakeBorder(img, 1, 1, 1, 1, cv2.BORDER_DEFAULT) print(default) 首先进行上下填充，填充成与原图像边界对称的值，如下图： 同理再进行左右两边的填充，最后把四个顶点补充上就好了： [!TIP] 一般情况下默认方式更加合理，因为边界的像素值更加接近。具体应视场合而定。 8.4 OpenCV 进行卷积 OpenCV 中用cv2.filter2D()实现卷积操作，比如我们的核是下面这样（3×3 区域像素的和除以 10）： img = cv2.imread('lena.jpg') # 定义卷积核 kernel = np.ones((3, 3), np.float32) / 10 # 卷积操作，-1 表示通道数与原图相同 dst = cv2.filter2D(img, -1, kernel) 可以看到这个核对图像进行了模糊处理，这是卷积的众多功能之一。当然卷积还有很多知识没有学到，后面我们再继续深入。 8.5 练习 尝试给\"lena.jpg\"添加几种不同的边框类型，对比下效果。 8.6 引用 图像卷积与滤波的一些知识点 9 番外篇：图像梯度 了解图像梯度和边缘检测的相关概念。 还记得前面10 平滑图像中提到的滤波与模糊的区别吗？我们说低通滤波器是模糊，高通滤波器是锐化，这节我们就来看看高通滤波器。 9.1 图像梯度 如果你还记得高数中用一阶导数来求极值的话，就很容易理解了。把图片想象成连续函数，因为边缘部分的像素值是与旁边像素明显有区别的，所以对图片局部求极值，就可以得到整幅图片的边缘信息了。不过图片是二维的离散函数，导数就变成了差分，这个差分就称为图像的梯度。 当然，大部分人应该是早忘记高数了(￣ ▽ ￣)\"，所以看不懂的话，就把上面的解释划掉，我们重新从卷积的角度来看看。 9.1.1 垂直边缘提取 滤波是应用卷积来实现的，卷积的关键就是卷积核，我们来考察下面这个卷积核： 这个核是用来提取图片中的垂直边缘的，怎么做到的呢？看下图： 上图中进行了2次卷积操作，第一次卷积结果为-290，取为0；第二次卷积结果为930，取为255。卷积的结果就是垂直方向上的梯度值，即边缘的强度。由于边缘的值明显小于（或大于）周边像素，所以边缘的差分结果会明显不同，这样就提取出了垂直边缘。同理，把上面那个矩阵转置一下，就是提取水平边缘。这种差分操作就称为图像的梯度计算： 还记得滤波函数cv2.filter2D()吗？（08 番外篇：卷积基础 - 图片边框）我们来手动实现上面的功能： img = cv2.imread('sudoku.jpg', 0) # 进行垂直边缘提取 kernel = np.array([[-1, 0, 1], [-2, 0, 2], [-1, 0, 1]], dtype=np.float32) dst_v = cv2.filter2D(img, -1, kernel) # 进行水平边缘提取 dst_h = cv2.filter2D(img, -1, kernel.T) # 横向并排对比显示 cv2.imshow('Img->EdgeVertical->EdgeHorizontal', np.hstack((img, dst_v, dst_h))) cv2.waitKey(0) 9.1.2 Sobel 算子 上面的这种差分方法就叫Sobel 算子，它先在垂直方向计算梯度Gx=k1×src，再在水平方向计算梯度Gy=k2×src，最后求出总梯度：G=sqrt{Gx^2+Gy^2} 我们可以把前面的代码用 Sobel 算子更简单地实现： sobelx = cv2.Sobel(img, -1, 1, 0, ksize=3) # 只计算 x 方向 sobely = cv2.Sobel(img, -1, 0, 1, ksize=3) # 只计算 y 方向 # img: 表示输入的图像，即要应用Sobel算子的图像。 # -1: 表示深度（depth）参数，表示输出图像的深度。如果为-1，表示输出图像的深度将与输入图像的深度相同。 # 0: 表示在x方向上的差分阶数，表示Sobel算子在水平方向上的导数。在这种情况下，设置为0表示不在x方向上进行差分。 # 1: 表示在y方向上的差分阶数，表示Sobel算子在垂直方向上的导数。在这种情况下，它用于计算图像中每个像素在y方向上的梯度。 # ksize=3: 这是Sobel核的大小，即核的尺寸。 [!TIP] 很多人疑问，Sobel 算子的卷积核这几个值是怎么来的呢？事实上，并没有规定，你可以用你自己的。 比如，最初只利用领域间的原始差值来检测边缘的Prewitt 算子： 还有比 Sobel 更好用的Scharr 算子，大家可以了解下： 这些算法都是一阶边缘检测的代表，网上也有算子之间的对比资料，有兴趣的可参考文末引用。 9.1.3 Laplacian 算子 高数中用一阶导数求极值，在这些极值的地方，二阶导数为 0，所以也可以通过求二阶导计算梯度： 一维的一阶和二阶差分公式分别为： 提取前面的系数，那么一维的 Laplacian 滤波核是： 而对于二维函数 f(x,y)，两个方向的二阶差分分别是： 合在一起就是： 同样提取前面的系数，那么二维的 Laplacian 滤波核就是： 这就是 Laplacian 算子的图像卷积模板，有些资料中在此基础上考虑斜对角情况，将卷积核拓展为： OpenCV 中直接使用cv2.Laplacian()函数： laplacian = cv2.Laplacian(img, -1) # 使用 Laplacian 算子 Laplacian 算子是二阶边缘检测的典型代表，一/二阶边缘检测各有优缺点，大家可自行了解。 9.2 练习 （选做）同志们有空补补高数姿势（知识）呗！(✿◕‿◕✿) 9.3 引用 Sobel 导数 维基百科：边缘检测 数字图像 - 边缘检测原理 - Sobel, Laplace, Canny 算子 10 番外篇：轮廓层级 了解轮廓间的层级关系。 前面我们使用cv2.findContours()寻找轮廓时，参数 3 表示轮廓的寻找方式(RetrievalModes)。当时我们传入的是 cv2.RETR_TREE，它表示什么意思呢？另外，函数返回值 hierarchy 有什么用途呢？下面我们就来研究下这两个问题。 10.1 理解轮廓层级 很多情况下，图像中的形状之间是有关联的，比如说下图： 图中总共有 8 条轮廓，2 和 2a 分别表示外层和里层的轮廓，3 和 3a 也是一样。从图中看得出来： 轮廓 0/1/2 是最外层的轮廓，我们可以说它们处于同一轮廓等级：0 级 轮廓 2a 是轮廓 2 的子轮廓，反过来说 2 是 2a 的父轮廓，轮廓 2a 算一个等级：1 级 同样 3 是 2a 的子轮廓，轮廓 3 处于一个等级：2 级 类似的，3a 是 3 的子轮廓，等等………… 这里面 OpenCV 关注的就是两个概念：同一轮廓等级和轮廓间的子属关系。 10.2 OpenCV 中轮廓等级的表示 如果我们打印出cv2.findContours()函数的返回值 hierarchy，会发现它是一个包含 4 个值的数组：[Next, Previous, First Child, Parent] Next：与当前轮廓处于同一层级的下一条轮廓 举例来说，前面图中跟 0 处于同一层级的下一条轮廓是 1，所以 Next=1；同理，对轮廓 1 来说，Next=2；那么对于轮廓 2 呢？没有与它同一层级的下一条轮廓了，此时 Next=-1。 Previous：与当前轮廓处于同一层级的上一条轮廓 跟前面一样，对于轮廓 1 来说，Previous=0；对于轮廓 2，Previous=1；对于轮廓 1，没有上一条轮廓了，所以 Previous=-1。 First Child：当前轮廓的第一条子轮廓 比如对于轮廓 2，第一条子轮廓就是轮廓 2a，所以 First Child=2a；对轮廓 3a，First Child=4。 Parent：当前轮廓的父轮廓 比如 2a 的父轮廓是 2，Parent=2；轮廓 2 没有父轮廓，所以 Parent=-1。 下面我们通过代码验证一下： import cv2 # 1.读入图片 img = cv2.imread('hierarchy.jpg') img_gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY) _, thresh = cv2.threshold(img_gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU) # 2.寻找轮廓 contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, 2) # 3.绘制轮廓 print(len(contours),hierarchy) # 8 条 cv2.drawContours(img, contours, -1, (0, 0, 255), 2) [!TIP] OpenCV 中找到的轮廓序号跟前面讲的不同噢，如下图： 现在既然我们了解了层级的概念，那么类似 cv2.RETR_TREE 的轮廓寻找方式又是啥意思呢？ 10.3 轮廓寻找方式 OpenCV 中有四种轮廓寻找方式RetrievalModes，下面分别来看下： 10.3.1 RETR_LIST 这是最简单的一种寻找方式，它不建立轮廓间的子属关系，也就是所有轮廓都属于同一层级。这样，hierarchy 中的后两个值[First Child, Parent] 都为-1。比如同样的图，我们使用 cv2.RETR_LIST 来寻找轮廓： contours, hierarchy = cv2.findContours(thresh, cv2.RETR_LIST, 2) print(hierarchy) # 结果如下 [[[ 1 -1 -1 -1] [ 2 0 -1 -1] [ 3 1 -1 -1] [ 4 2 -1 -1] [ 5 3 -1 -1] [ 6 4 -1 -1] [ 7 5 -1 -1] [-1 6 -1 -1]]] 因为没有从属关系，所以轮廓 0 的下一条是 1，1 的下一条是 2…… [!TIP] 如果你不需要轮廓层级信息的话，cv2.RETR_LIST 更推荐使用，因为性能更好。 10.3.2 RETR_TREE cv2.RETR_TREE 就是之前我们一直在使用的方式，它会完整建立轮廓的层级从属关系，前面已经详细说明过了。 10.3.3 RETR_EXTERNAL 这种方式只寻找最高层级的轮廓，也就是它只会找到前面我们所说的 3 条 0 级轮廓： contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, 2) print(len(contours), hierarchy, sep='\\n') # 结果如下 3 [[[ 1 -1 -1 -1] [ 2 0 -1 -1] [-1 1 -1 -1]]] 10.3.4 RETR_CCOMP 相比之下 cv2.RETR_CCOMP 比较难理解，但其实也很简单：它把所有的轮廓只分为 2 个层级，不是外层的就是里层的。结合代码和图片，我们来理解下： contours, hierarchy = cv2.findContours(thresh, cv2.RETR_CCOMP, 2) print(hierarchy) # 结果如下 [[[ 1 -1 -1 -1] [ 2 0 -1 -1] [ 4 1 3 -1] [-1 -1 -1 2] [ 6 2 5 -1] [-1 -1 -1 4] [ 7 4 -1 -1] [-1 6 -1 -1]]] [!TIP] 使用这个参数找到的轮廓序号与之前不同。 图中括号里面 1 代表外层轮廓，2 代表里层轮廓。比如说对于轮廓 2，Next 就是 4，Previous 是 1，它有里层的轮廓 3，所以 First Child=3，但因为只有两个层级，它本身就是外层轮廓，所以 Parent=-1。大家可以针对其他的轮廓自己验证一下。 10.4 练习 如下图，找到 3 个圆环的内环，然后填充成(180,215,215) 这种颜色： 11 番外篇：凸包及更多轮廓特征 计算凸包及更多轮廓特征。 11.1 多边形逼近 前面我们学习过最小外接矩和最小外接圆，那么可以用一个最小的多边形包围物体吗？当然可以： import cv2 import numpy as np # 1.先找到轮廓 origin = cv2.imread('unregular.jpg') img = cv2.imread('unregular.jpg', 0) _, thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU) contours, hierarchy = cv2.findContours(thresh, 3, 2) cnt = contours[0] # 2.进行多边形逼近，得到多边形的角点 approx3 = cv2.approxPolyDP(cnt, 3, True) approx50 = cv2.approxPolyDP(cnt, 50, True) # 3.画出多边形 image1 = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR) cv2.polylines(image1, [approx3], True, (0, 255, 0), 2) print(\"approx3: \", len(approx3)) # 角点的个数 image2 = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR) cv2.polylines(image2, [approx50], True, (0, 255, 0), 2) print(\"approx50: \", len(approx50)) # 角点的个数 cv2.imshow('Img->Approx50->Approx3', np.hstack((origin, image2, image1))) cv2.waitKey(0) 其中cv2.approxPolyDP()的参数 2(epsilon) 是一个距离值，表示多边形的轮廓接近实际轮廓的程度，值越小，越精确；参数 3 表示是否闭合。 11.2 凸包 凸包跟多边形逼近很像，只不过它是物体最外层的\"凸\"多边形：集合 A 内连接任意两个点的直线都在 A 的内部，则称集合 A 是凸形的。如下图，红色的部分为手掌的凸包，双箭头部分表示凸缺陷 (Convexity Defects)，凸缺陷常用来进行手势识别等： # 1.先找到轮廓 img = cv2.imread('convex.jpg', 0) _, thresh = cv2.threshold(img, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU) contours, hierarchy = cv2.findContours(thresh, 3, 2) cnt = contours[0] # 2.寻找凸包，得到凸包的角点 hull = cv2.convexHull(cnt) # 3.绘制凸包 image = cv2.cvtColor(img, cv2.COLOR_GRAY2BGR) cv2.polylines(image, [hull], True, (0, 255, 0), 2) 其中函数cv2.convexHull()有个可选参数 returnPoints，默认是 True，代表返回角点的 x/y 坐标；如果为 False 的话，表示返回轮廓中是凸包角点的索引，比如说： print(hull[0]) # [[362 184]]（坐标） hull2 = cv2.convexHull(cnt, returnPoints=False) print(hull2[0]) # [510]（cnt 中的索引） print(cnt[510]) # [[362 184]] 当使用cv2.convexityDefects()计算凸包缺陷时，returnPoints 需为 False 另外可以用下面的语句来判断轮廓是否是凸形的： print(cv2.isContourConvex(hull)) # True 11.3 点到轮廓距离 cv2.pointPolygonTest()函数计算点到轮廓的最短距离（也就是垂线），又称多边形测试： dist = cv2.pointPolygonTest(cnt, (100, 100), True) # -3.535 其中参数 3 为 True 时表示计算距离值：点在轮廓外面值为负，点在轮廓上值为 0，点在轮廓里面值为正；参数 3 为 False 时，只返回-1/0/1 表示点相对轮廓的位置，不计算距离。 更多轮廓特征，如当量直径、平均强度等。new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Match/":{"url":"Markdown/Match/","title":"A 竞赛追踪","keywords":"","body":"A 竞赛追踪 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/":{"url":"Markdown/Resource/","title":"B 资源工具","keywords":"","body":"优秀资源汇总 1 综合导航 1 AIGC导航：https://www.aigc.cn/ --> 综合导航⭐️⭐️ 2 柒夜导航：https://nav.qinight.com/ --> 综合导航⭐️⭐️ 3 导航文库：https://docs.apachecn.org/ --> 编程学习♓ 4 熊猫搜书：https://xmsoushu.com/?mpyit.com --> 电子书查找➿ 5 简视频：https://www.aewz.com/ --> 视频素材⛺ 2 在线工具箱 ① 即时工具：https://www.67tool.com/ ② Toolfun：https://tools.fun/ ③ TinyWow: https://tinywow.com/ 3 PPT 1 第1PPT：https://www.1ppt.com/ --> PPT模板 2 优品PPT：https://www.ypppt.com/ --> PPT模板 3 51PPT：https://www.51pptmoban.com/ --> PPT模板 4 PPT超级市场: https://www.pptsupermarket.com/ --> 可以当导航页面使用，下面的工具比较好用 4 其他 1 廖雪峰官网：https://www.liaoxuefeng.com/ --> 编程语言自学 2 书栈网：https://www.bookstack.cn/ --> 编程语言自学 3 汉典：https://www.zdic.net/ -- > 汉字、词组、古籍、书法等 4 Groupdocs：https://products.groupdocs.app/translation/zh/total --> 在线文档翻译和转换 5 数据结构与算法：https://pan.baidu.com/s/1bPuOgfeLS2MWZheEhK88Cw?pwd=6666 提取码：6666 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/ubuntu.html":{"url":"Markdown/Resource/ubuntu.html","title":"1 Ubuntu","keywords":"","body":"1 Ubuntu 1 Linux命令大全(手册): https://www.linuxcool.com/ 2 鸟哥的Linux私房菜：https://linux.vbird.org/ 3 肝下25万字的《决战Linux到精通》笔记，你的Linux水平将从入门到入魔 点击传送 4 史上最全的Linux常用命令汇总（超全面！超详细！）收藏这一篇就够了！点击传送 5 Linux学习教程，Linux入门教程（超详细）：http://c.biancheng.net/linux_tutorial/ new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/ros.html":{"url":"Markdown/Resource/ros.html","title":"2 ROS1","keywords":"","body":"2 ROS ROS1 1 ROS Index: https://index.ros.org/ 2 赵虚左讲义：http://www.autolabor.com.cn/book/ROSTutorials/ 3 创客制造-ROS1轻松学：https://www.ncnynl.com/ros1.html 4 鱼香ROS：http://fishros.com/#/fish_home Github: https://github.com/fishros/install 5 ROS Robots: https://robots.ros.org/ ROS2 1 古月居ROS2入门教程：https://book.guyuehome.com/new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/c++.html":{"url":"Markdown/Resource/c++.html","title":"3 C++","keywords":"","body":"3 C++ 1 cppreference：https://zh.cppreference.com/w/%E9%A6%96%E9%A1%B5 2 LEARN C++：https://www.learncpp.com/ 3 cplusplus：https://cplusplus.com/ 4 tutorialspoint：https://www.tutorialspoint.com/index.htm 5 Awesome C++：https://github.com/fffaraz/awesome-cpp new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/python.html":{"url":"Markdown/Resource/python.html","title":"4 Python","keywords":"","body":"4 Python 1 Python - 100天从新手到大：https://github.com/jackfrued/Python-100-Days --> Python推荐学习资源 网盘链接：链接：https://pan.baidu.com/s/19_5fDewSwfM5qGSWYG38dA?pwd=6666 提取码：6666 2 Python标准库：https://docs.python.org/zh-cn/3/new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/vim.html":{"url":"Markdown/Resource/vim.html","title":"5 Vim","keywords":"","body":"5 Vim 1 Vim 在线学习：https://www.lanqiao.cn/courses/2/learning/?id=16new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Resource/docker.html":{"url":"Markdown/Resource/docker.html","title":"6 Docker","keywords":"","body":"6 Docker 1 Docker 教程：https://www.runoob.com/docker/docker-tutorial.html 2 Docker Hub: https://hub.docker.com/new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/":{"url":"Markdown/Tools/","title":"2 常用工具","keywords":"","body":"B 常用工具 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/Git-1.html":{"url":"Markdown/Tools/Git-1.html","title":"1.1 廖雪峰Git教程","keywords":"","body":"1.1 Git 教程--廖雪峰[搬] 廖雪峰Git教程链接：https://www.liaoxuefeng.com/wiki/896043488029600 Git大全：https://gitee.com/all-about-git Git命令在线学习：https://oschina.gitee.io/learn-git-branching/ 史上最浅显易懂的Git教程！ 为什么要编写这个教程？因为我在学习Git的过程中，买过书，也在网上Google了一堆Git相关的文章和教程，但令人失望的是，这些教程不是难得令人发指，就是简单得一笔带过，或者，只支离破碎地介绍Git的某几个命令，还有直接从Git手册粘贴帮助文档的，总之，初学者很难找到一个由浅入深，学完后能立刻上手的Git教程。 既然号称史上最浅显易懂的Git教程，那这个教程有什么让你怦然心动的特点呢？ 首先，本教程绝对面向初学者，没有接触过版本控制概念的读者也可以轻松入门，不必担心起步难度； 其次，本教程实用性超强，边学边练，一点也不觉得枯燥。而且，你所学的Git命令是“充分且必要”的，掌握了这些东西，你就可以通过Git轻松地完成你的工作。 文字+图片还看不明白？有视频！！！ 本教程只会让你成为Git用户，不会让你成为Git专家。很多Git命令只有那些专家才明白（事实上我也不明白，因为我不是Git专家），但我保证这些命令可能你一辈子都不会用到。既然Git是一个工具，就没必要把时间浪费在那些“高级”但几乎永远不会用到的命令上。一旦你真的非用不可了，到时候再自行Google或者请教专家也未迟。 如果你是一个开发人员，想用上这个世界上目前最先进的分布式版本控制系统，那么，赶快开始学习吧！ 1 Git 简介 Git是什么？ Git是目前世界上最先进的分布式版本控制系统（没有之一）。 Git有什么特点？简单来说就是：高端大气上档次！ 那什么是版本控制系统？ 如果你用Microsoft Word写过长篇大论，那你一定有这样的经历： 想删除一个段落，又怕将来想恢复找不回来怎么办？有办法，先把当前文件“另存为……”一个新的Word文件，再接着改，改到一定程度，再“另存为……”一个新文件，这样一直改下去，最后你的Word文档变成了这样： 过了一周，你想找回被删除的文字，但是已经记不清删除前保存在哪个文件里了，只好一个一个文件去找，真麻烦。 看着一堆乱七八糟的文件，想保留最新的一个，然后把其他的删掉，又怕哪天会用上，还不敢删，真郁闷。 更要命的是，有些部分需要你的财务同事帮助填写，于是你把文件Copy到U盘里给她（也可能通过Email发送一份给她），然后，你继续修改Word文件。一天后，同事再把Word文件传给你，此时，你必须想想，发给她之后到你收到她的文件期间，你作了哪些改动，得把你的改动和她的部分合并，真困难。 于是你想，如果有一个软件，不但能自动帮我记录每次文件的改动，还可以让同事协作编辑，这样就不用自己管理一堆类似的文件了，也不需要把文件传来传去。如果想查看某次改动，只需要在软件里瞄一眼就可以，岂不是很方便？ 这个软件用起来就应该像这个样子，能记录每次文件的改动： 这样，你就结束了手动管理多个“版本”的史前时代，进入到版本控制的20世纪。 1 Git的诞生 很多人都知道，Linus在1991年创建了开源的Linux，从此，Linux系统不断发展，已经成为最大的服务器系统软件了。 Linus虽然创建了Linux，但Linux的壮大是靠全世界热心的志愿者参与的，这么多人在世界各地为Linux编写代码，那Linux的代码是如何管理的呢？ 事实是，在2002年以前，世界各地的志愿者把源代码文件通过diff的方式发给Linus，然后由Linus本人通过手工方式合并代码！ 你也许会想，为什么Linus不把Linux代码放到版本控制系统里呢？不是有CVS、SVN这些免费的版本控制系统吗？因为Linus坚定地反对CVS和SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比CVS、SVN好用，但那是付费的，和Linux的开源精神不符。 不过，到了2002年，Linux系统已经发展了十年了，代码库之大让Linus很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是Linus选择了一个商业的版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权Linux社区免费使用这个版本控制系统。 安定团结的大好局面在2005年就被打破了，原因是Linux社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发Samba的Andrew试图破解BitKeeper的协议（这么干的其实也不只他一个），被BitMover公司发现了（监控工作做得不错！），于是BitMover公司怒了，要收回Linux社区的免费使用权。 Linus可以向BitMover公司道个歉，保证以后严格管教弟兄们，嗯，这是不可能的。实际情况是这样的： Linus花了两周时间自己用C写了一个分布式版本控制系统，这就是Git！一个月之内，Linux系统的源码已经由Git管理了！牛是怎么定义的呢？大家可以体会一下。 Git迅速成为最流行的分布式版本控制系统，尤其是2008年，GitHub网站上线了，它为开源项目免费提供Git存储，无数开源项目开始迁移至GitHub，包括jQuery，PHP，Ruby等等。 历史就是这么偶然，如果不是当年BitMover公司威胁Linux社区，可能现在我们就没有免费而超级好用的Git了。 2 集中式vs分布式 Linus一直痛恨的CVS及SVN都是集中式的版本控制系统，而Git是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 先说集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。 集中式版本控制系统最大的毛病就是必须联网才能工作，如果在局域网内还好，带宽够大，速度够快，可如果在互联网上，遇到网速慢的话，可能提交一个10M的文件就需要5分钟，这还不得把人给憋死啊。 那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。 在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 当然，Git的优势不单是不必联网这么简单，后面我们还会看到Git极其强大的分支管理，把SVN等远远抛在了后面。 CVS作为最早的开源而且免费的集中式版本控制系统，直到现在还有不少人在用。由于CVS自身设计的问题，会造成提交文件不完整，版本库莫名其妙损坏的情况。同样是开源而且免费的SVN修正了CVS的一些稳定性问题，是目前用得最多的集中式版本库控制系统。 除了免费的外，还有收费的集中式版本控制系统，比如IBM的ClearCase（以前是Rational公司的，被IBM收购了），特点是安装比Windows还大，运行比蜗牛还慢，能用ClearCase的一般是世界500强，他们有个共同的特点是财大气粗，或者人傻钱多。 微软自己也有一个集中式版本控制系统叫VSS，集成在Visual Studio中。由于其反人类的设计，连微软自己都不好意思用了。 分布式版本控制系统除了Git以及促使Git诞生的BitKeeper外，还有类似Git的Mercurial和Bazaar等。这些分布式版本控制系统各有特点，但最快、最简单也最流行的依然是Git！ 1.1 安装Git 最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。 要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字： 1 在Linux上安装Git 首先，你可以试着输入git，看看系统有没有安装Git： $ git The program 'git' is currently not installed. You can install it by typing: sudo apt-get install git 像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。 如果你碰巧用Debian或Ubuntu Linux，通过一条sudo apt-get install git就可以直接完成Git的安装，非常简单。 老一点的Debian或Ubuntu Linux，要把命令改为sudo apt-get install git-core，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫git-core了。由于Git名气实在太大，后来就把GNU Interactive Tools改成gnuit，git-core正式改为git。 如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：./config，make，sudo make install这几个命令安装就好了。 2 在Mac OS X上安装Git 如果你正在使用Mac做开发，有两种安装Git的方法。 一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：http://brew.sh/。 第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”->“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。 Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！ 3 在Windows上安装Git 在Windows上使用Git，可以从Git官网直接下载安装程序，然后按默认选项安装即可。 安装完成后，在开始菜单里找到“Git”->“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！ 安装完成后，还需要最后一步设置，在命令行输入： $ git config --global user.name \"Your Name\" $ git config --global user.email \"email@example.com\" 因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。 注意git config命令的--global参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。 1.2 创建版本库 1 创建版本库 什么是版本库呢？版本库又名仓库，英文名repository，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 所以，创建一个版本库非常简单，首先，选择一个合适的地方，创建一个空目录： $ mkdir learngit $ cd learngit $ pwd /Users/michael/learngit pwd命令用于显示当前目录。在我的Mac上，这个仓库位于/Users/michael/learngit。 如果你使用 Windows 系统，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。 第二步，通过git init命令把这个目录变成 Git 可以管理的仓库： $ git init Initialized empty Git repository in /Users/michael/learngit/.git/ 瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前目录下多了一个.git的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。 如果你没有看到.git目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。 也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。 2 把文件添加到版本库 首先这里再明确一下，所有的版本控制系统，其实只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。 不幸的是，Microsoft的Word格式是二进制格式，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。 因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 使用Windows的童鞋要特别注意： 千万不要使用Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载Visual Studio Code代替记事本，不但功能强大，而且免费！ 言归正传，现在我们编写一个readme.txt文件，内容如下： Git is a version control system. Git is free software. 一定要放到learngit目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。 和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。 第一步，用命令git add告诉Git，把文件添加到仓库： $ git add readme.txt 执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。 第二步，用命令git commit告诉Git，把文件提交到仓库： $ git commit -m \"wrote a readme file\" [master (root-commit) eaadf4e] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 简单解释一下git commit命令，-m后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。 嫌麻烦不想输入-m \"xxx\"行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。 git commit命令执行成功后会告诉你，1 file changed：1个文件被改动（我们新添加的readme.txt文件）；2 insertions：插入了两行内容（readme.txt有两行内容）。 为什么Git添加文件需要add，commit一共两步呢？因为commit可以一次提交很多文件，所以你可以多次add不同的文件，比如： $ git add file1.txt $ git add file2.txt file3.txt $ git commit -m \"add 3 files.\" 3 疑难解答 Q：输入git add readme.txt，得到错误：fatal: not a git repository (or any of the parent directories)。 A：Git命令必须在Git仓库目录内执行（git init除外），在仓库目录外执行是没有意义的。 Q：输入git add readme.txt，得到错误fatal: pathspec 'readme.txt' did not match any files。 A：添加某个文件时，该文件必须在当前目录下存在，用ls或者dir命令查看当前目录的文件，看看文件是否存在，或者是否写错了文件名。 4 小结 现在总结一下今天学的两点内容： 初始化一个Git仓库，使用git init命令。 添加文件到Git仓库，分两步： 使用命令git add ，注意，可反复多次使用，添加多个文件； 使用命令git commit -m ，完成。 2 时光机穿梭 1 时光机穿梭 我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容： Git is a distributed version control system. Git is free software. 现在，运行git status命令看看结果： $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") git status命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，readme.txt被修改过了，但还没有准备提交的修改。 虽然Git告诉我们readme.txt被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的readme.txt，所以，需要用git diff这个命令看看： $ git diff readme.txt diff --git a/readme.txt b/readme.txt index 46d49bf..9247db6 100644 --- a/readme.txt +++ b/readme.txt @@ -1,2 +1,2 @@ -Git is a version control system. +Git is a distributed version control system. Git is free software. git diff顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个distributed单词。 知道了对readme.txt作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是git add $ git add readme.txt 同样没有任何输出。在执行第二步git commit之前，我们再运行git status看看当前仓库的状态： $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: readme.txt git status告诉我们，将要被提交的修改包括readme.txt，下一步，就可以放心地提交了： $ git commit -m \"add distributed\" [master e475afc] add distributed 1 file changed, 1 insertion(+), 1 deletion(-) 提交后，我们再用git status命令看看仓库的当前状态： $ git status On branch master nothing to commit, working tree clean Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。 2 小结 要随时掌握工作区的状态，使用`git status`命令。 如果`git status`告诉你有文件被修改过，用`git diff`可以查看修改内容。 2.1 版本回退 1 版本回退 现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下： Git is a distributed version control system. Git is free software distributed under the GPL. 然后尝试提交： $ git add readme.txt $ git commit -m \"append GPL\" [master 1094adb] append GPL 1 file changed, 1 insertion(+), 1 deletion(-) 像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个commit恢复，然后继续工作，而不是把几个月的工作成果全部丢失。 现在，我们回顾一下readme.txt文件一共有几个版本被提交到Git仓库里了： 版本1：wrote a readme file Git is a version control system. Git is free software. 版本2：add distributed Git is a distributed version control system. Git is free software. 版本3：append GPL Git is a distributed version control system. Git is free software distributed under the GPL. 当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用git log命令查看： $ git log commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) Author: Michael Liao Date: Fri May 18 21:06:15 2018 +0800 append GPL commit e475afc93c209a690c39c13a46716e8fa000c366 Author: Michael Liao Date: Fri May 18 21:03:36 2018 +0800 add distributed commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 Author: Michael Liao Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file git log命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是append GPL，上一次是add distributed，最早的一次是wrote a readme file。 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上--pretty=oneline参数： $ git log --pretty=oneline 1094adb7b9b3807259d8cb349e7df1d4d6477073 (HEAD -> master) append GPL e475afc93c209a690c39c13a46716e8fa000c366 add distributed eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 wrote a readme file 需要友情提示的是，你看到的一大串类似1094adb...的是commit id（版本号），和SVN不一样，Git的commit id不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的commit id和我的肯定不一样，以你自己的为准。为什么commit id需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。 每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线： 好了，现在我们启动时光穿梭机，准备把readme.txt回退到上一个版本，也就是add distributed的那个版本，怎么做呢？ 首先，Git必须知道当前版本是哪个版本，在Git中，用HEAD表示当前版本，也就是最新的提交1094adb...（注意我的提交ID和你的肯定不一样），上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。 现在，我们要把当前版本append GPL回退到上一个版本add distributed，就可以使用git reset命令： $ git reset --hard HEAD^ HEAD is now at e475afc add distributed --hard参数有啥意义？这个后面再讲，现在你先放心使用。 看看readme.txt的内容是不是版本add distributed： $ cat readme.txt Git is a distributed version control system. Git is free software. 果然被还原了。 还可以继续回退到上一个版本wrote a readme file，不过且慢，让我们用git log再看看现在版本库的状态： $ git log commit e475afc93c209a690c39c13a46716e8fa000c366 (HEAD -> master) Author: Michael Liao Date: Fri May 18 21:03:36 2018 +0800 add distributed commit eaadf4e385e865d25c48e7ca9c8395c3f7dfaef0 Author: Michael Liao Date: Fri May 18 20:59:18 2018 +0800 wrote a readme file 最新的那个版本append GPL已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？ 办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个append GPL的commit id是1094adb...，于是就可以指定回到未来的某个版本： $ git reset --hard 1094a HEAD is now at 83b0afe append GPL 版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。 再小心翼翼地看看readme.txt的内容： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. 果然，我胡汉三又回来了。 Git的版本回退速度非常快，因为Git在内部有个指向当前版本的HEAD指针，当你回退版本的时候，Git仅仅是把HEAD从指向append GPL： 然后顺便把工作区的文件更新了。所以你让HEAD指向哪个版本号，你就把当前版本定位在哪。 现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的commit id怎么办？ 在Git中，总是有后悔药可以吃的。当你用$ git reset --hard HEAD^回退到add distributed版本时，再想恢复到append GPL，就必须找到append GPL的commit id。Git提供了一个命令git reflog用来记录你的每一次命令： $ git reflog e475afc HEAD@{1}: reset: moving to HEAD^ 1094adb (HEAD -> master) HEAD@{2}: commit: append GPL e475afc HEAD@{3}: commit: add distributed eaadf4e HEAD@{4}: commit (initial): wrote a readme file 终于舒了口气，从输出可知，append GPL的commit id是1094adb，现在，你又可以乘坐时光机回到未来了。 2 小结 现在总结一下： `HEAD`指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令`git reset --hard commit_id`。 穿梭前，用`git log`可以查看提交历史，以便确定要回退到哪个版本。 要重返未来，用`git reflog`查看命令历史，以便确定要回到未来的哪个版本 2.2 工作区和暂存区 1 工作区和暂存区 Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。 先来看名词解释。 1.1 工作区（Working Directory） 就是你在电脑里能看到的目录，比如我的learngit文件夹就是一个工作区： 1.2 版本库（Repository） 工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。 Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支master，以及指向master的一个指针叫HEAD。 分支和HEAD的概念我们以后再讲。 前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的： 第一步：用git add把文件添加进去，实际上就是把文件修改添加到暂存区； 第二步：用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支。 因为我们创建Git版本库时，Git自动为我们创建了唯一一个master分支，所以，现在，git commit就是往master分支上提交更改。 你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。 俗话说，实践出真知。现在，我们再练习一遍，先对readme.txt做个修改，比如加上一行内容： Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. 然后，在工作区新增一个LICENSE文本文件（内容随便写）。 先用git status查看一下状态： $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt Untracked files: (use \"git add ...\" to include in what will be committed) LICENSE no changes added to commit (use \"git add\" and/or \"git commit -a\") Git非常清楚地告诉我们，readme.txt被修改了，而LICENSE还从来没有被添加过，所以它的状态是Untracked。 现在，使用两次命令git add，把readme.txt和LICENSE都添加后，用git status再查看一下： $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: LICENSE modified: readme.txt 现在，暂存区的状态就变成这样了： 所以，git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 $ git commit -m \"understand how stage works\" [master e43a48b] understand how stage works 2 files changed, 2 insertions(+) create mode 100644 LICENSE 一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的： $ git status On branch master nothing to commit, working tree clean 现在版本库变成了这样，暂存区就没有任何内容了： 2 小结 暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。 没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。 2.3 管理修改 1 管理修改 现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。 你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。 为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes. 然后，添加： $ git add readme.txt $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: readme.txt 然后，再修改readme.txt： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. 提交： $ git commit -m \"git tracks changes\" [master 519219b] git tracks changes 1 file changed, 1 insertion(+) 提交后，再看看状态： $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 咦，怎么第二次的修改没有被提交？ 别激动，我们回顾一下操作过程： 第一次修改 -> git add -> 第二次修改 -> git commit 你看，我们前面讲了，Git管理的是修改，当你用git add命令后，在工作区的第一次修改被放入暂存区，准备提交。但是，在工作区的第二次修改并没有放入暂存区，所以，git commit只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 提交后，用git diff HEAD -- readme.txt命令可以查看工作区和版本库里面最新版本的区别： $ git diff HEAD -- readme.txt diff --git a/readme.txt b/readme.txt index 76d770f..a9c5755 100644 --- a/readme.txt +++ b/readme.txt @@ -1,4 +1,4 @@ Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. -Git tracks changes. +Git tracks changes of files. 可见，第二次修改确实没有被提交。 那怎么提交第二次修改呢？你可以继续git add再git commit，也可以别着急提交第一次修改，先git add第二次修改，再git commit，就相当于把两次修改合并后一块提交了： 第一次修改 -> git add -> 第二次修改 -> git add -> git commit 好，现在，把第二次修改提交了，然后开始小结。 2 小结 现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用git add到暂存区，那就不会加入到commit中。 2.4 撤销修改 1 撤销修改 自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在readme.txt中添加了一行： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. My stupid boss still prefers SVN. 在你准备提交前，一杯咖啡起了作用，你猛然发现了stupid boss可能会让你丢掉这个月的奖金！ 既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用git status查看一下： $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 你可以发现，Git会告诉你，git checkout -- file可以丢弃工作区的修改： $ git checkout -- readme.txt 命令git checkout -- readme.txt意思就是，把readme.txt文件在工作区的修改全部撤销，这里有两种情况： 一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态； 一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。 总之，就是让这个文件回到最近一次git commit或git add时的状态。 现在，看看readme.txt的文件内容： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. 文件内容果然复原了。 git checkout -- file命令中的--很重要，没有--，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到git checkout命令。 现在假定是凌晨3点，你不但写了一些胡话，还git add到暂存区了： $ cat readme.txt Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. My stupid boss still prefers SVN. $ git add readme.txt 庆幸的是，在commit之前，你发现了这个问题。用git status查看一下，修改只是添加到了暂存区，还没有提交： $ git status On branch master Changes to be committed: (use \"git reset HEAD ...\" to unstage) modified: readme.txt Git同样告诉我们，用命令git reset HEAD 可以把暂存区的修改撤销掉（unstage），重新放回工作区： $ git reset HEAD readme.txt Unstaged changes after reset: M readme.txt git reset命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用HEAD时，表示最新的版本。 再用git status查看一下，现在暂存区是干净的，工作区有修改： $ git status On branch master Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt 还记得如何丢弃工作区的修改吗？ $ git checkout -- readme.txt $ git status On branch master nothing to commit, working tree clean 整个世界终于清静了！ 现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得版本回退一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把stupid boss提交推送到远程版本库，你就真的惨了…… 2 小结 又到了小结时间。 场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令git checkout -- file。 场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD ，就回到了场景1，第二步按场景1操作。 场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 2.5 删除文件 1 删除文件 在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件test.txt到Git并且提交： $ git add test.txt $ git commit -m \"add test.txt\" [master b84166e] add test.txt 1 file changed, 1 insertion(+) create mode 100644 test.txt 一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用rm命令删了： $ rm test.txt 这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，git status命令会立刻告诉你哪些文件被删除了： $ git status On branch master Changes not staged for commit: (use \"git add/rm ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) deleted: test.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令git rm删掉，并且git commit： $ git rm test.txt rm 'test.txt' $ git commit -m \"remove test.txt\" [master d46f35e] remove test.txt 1 file changed, 1 deletion(-) delete mode 100644 test.txt 现在，文件就从版本库中被删除了。 小提示：先手动删除文件，然后使用git rm 和git add效果是一样的。 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： $ git checkout -- test.txt git checkout其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！ 2 小结 命令git rm用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删。但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。 3 远程仓库 1 远程仓库 到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。 可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。 没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。 Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。 你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？ 其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。 实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。 完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫GitHub的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。 在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置： 第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key： $ ssh-keygen -t rsa -C \"youremail@example.com\" 你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。 如果一切顺利的话，可以在用户主目录里找到.ssh目录，里面有id_rsa和id_rsa.pub两个文件，这两个就是SSH Key的秘钥对，id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面： 然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容： 点“Add Key”，你就应该看到已经添加的Key： 为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。 最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。 如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。 确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。 2 小结 “有了远程仓库，妈妈再也不用担心我的硬盘了。”——Git点读机 3.1 添加远程库 1 添加远程库 现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步。这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库： 在Repository name填入learngit，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库： 目前，在GitHub上的这个learngit仓库还是空的。GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。 现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令： $ git remote add origin git@github.com:michaelliao/learngit.git 请千万注意，把上面的michaelliao替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。 添加后，远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。 下一步，就可以把本地库的所有内容推送到远程库上： $ git push -u origin master Counting objects: 20, done. Delta compression using up to 4 threads. Compressing objects: 100% (15/15), done. Writing objects: 100% (20/20), 1.64 KiB | 560.00 KiB/s, done. Total 20 (delta 5), reused 0 (delta 0) remote: Resolving deltas: 100% (5/5), done. To github.com:michaelliao/learngit.git * [new branch] master -> master Branch 'master' set up to track remote branch 'master' from 'origin'. 把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。 由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。 推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： $ git push origin master 把本地master分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！ 2 SSH警告 当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告： The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established. RSA key fingerprint is xx.xx.xx.xx.xx. Are you sure you want to continue connecting (yes/no)? 这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入yes回车即可。 Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了： Warning: Permanently added 'github.com' (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充GitHub服务器，输入yes前可以对照GitHub的RSA Key的指纹信息是否与SSH连接给出的一致。 3 删除远程库 如果添加的时候地址写错了，或者就是想删除远程库，可以用git remote rm 命令。使用前，建议先用git remote -v查看远程库信息： $ git remote -v origin git@github.com:michaelliao/learn-git.git (fetch) origin git@github.com:michaelliao/learn-git.git (push) 然后，根据名字删除，比如删除origin： $ git remote rm origin 此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。 4 小结 要关联一个远程库，使用命令git remote add origin git@server-name:path/repo-name.git； 关联一个远程库时必须给远程库指定一个名字，origin是默认习惯命名； 关联后，使用命令git push -u origin master第一次推送master分支的所有内容； 此后，每次本地提交后，只要有必要，就可以使用命令git push origin master推送最新修改； 分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！ 3.2 从远程库克隆 1 从远程库克隆 上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。 现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。 首先，登陆GitHub，创建一个新的仓库，名字叫gitskills： 我们勾选Initialize this repository with a README，这样GitHub会自动为我们创建一个README.md文件。创建完毕后，可以看到README.md文件： 现在，远程库已经准备好了，下一步是用命令git clone克隆一个本地库： $ git clone git@github.com:michaelliao/gitskills.git Cloning into 'gitskills'... remote: Counting objects: 3, done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3 Receiving objects: 100% (3/3), done. 注意把Git库的地址换成你自己的，然后进入gitskills目录看看，已经有README.md文件了： $ cd gitskills $ ls README.md 如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。 你也许还注意到，GitHub给出的地址不止一个，还可以用https://github.com/michaelliao/gitskills.git这样的地址。实际上，Git支持多种协议，默认的git://使用ssh，但也可以使用https等其他协议。 使用https除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用ssh协议而只能用https。 2 小结 要克隆一个仓库，首先必须知道仓库的地址，然后使用git clone命令克隆。 Git支持多种协议，包括https，但ssh协议速度最快。 4 分支管理 1 分支管理 分支就是科幻电影里面的平行宇宙，当你正在电脑前努力学习Git的时候，另一个你正在另一个平行宇宙里努力学习SVN。 如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，结果，你既学会了Git又学会了SVN！ 分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。 现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。 其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。 但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。 4.1 创建与合并分支 1 创建与合并分支 在版本回退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 一开始的时候，master分支是一条线，Git用master指向最新的提交，再用HEAD指向master，就能确定当前分支，以及当前分支的提交点： HEAD │ │ ▼ master │ │ ▼ ┌───┐ ┌───┐ ┌───┐ │ │───▶│ │───▶│ │ └───┘ └───┘ └───┘ 每次提交，master分支都会向前移动一步，这样，随着你不断提交，master分支的线也越来越长。 当我们创建新的分支，例如dev时，Git新建了一个指针叫dev，指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： master │ │ ▼ ┌───┐ ┌───┐ ┌───┐ │ │───▶│ │───▶│ │ └───┘ └───┘ └───┘ ▲ │ │ dev ▲ │ │ HEAD 你看，Git创建一个分支很快，因为除了增加一个dev指针，改改HEAD的指向，工作区的文件都没有任何变化！ 不过，从现在开始，对工作区的修改和提交就是针对dev分支了，比如新提交一次后，dev指针往前移动一步，而master指针不变： master │ │ ▼ ┌───┐ ┌───┐ ┌───┐ ┌───┐ │ │───▶│ │───▶│ │───▶│ │ └───┘ └───┘ └───┘ └───┘ ▲ │ │ dev ▲ │ │ HEAD 假如我们在dev上的工作完成了，就可以把dev合并到master上。Git怎么合并呢？最简单的方法，就是直接把master指向dev的当前提交，就完成了合并： HEAD │ │ ▼ master │ │ ▼ ┌───┐ ┌───┐ ┌───┐ ┌───┐ │ │───▶│ │───▶│ │───▶│ │ └───┘ └───┘ └───┘ └───┘ ▲ │ │ dev 所以Git合并分支也很快！就改改指针，工作区内容也不变！ 合并完分支后，甚至可以删除dev分支。删除dev分支就是把dev指针给删掉，删掉后，我们就剩下了一条master分支： HEAD │ │ ▼ master │ │ ▼ ┌───┐ ┌───┐ ┌───┐ ┌───┐ │ │───▶│ │───▶│ │───▶│ │ └───┘ └───┘ └───┘ └───┘ 真是太神奇了，你看得出来有些提交是通过分支完成的吗？ 下面开始实战。 首先，我们创建dev分支，然后切换到dev分支： $ git checkout -b dev Switched to a new branch 'dev' git checkout命令加上-b参数表示创建并切换，相当于以下两条命令： $ git branch dev $ git checkout dev Switched to branch 'dev' 然后，用git branch命令查看当前分支： $ git branch * dev master git branch命令会列出所有分支，当前分支前面会标一个*号。 然后，我们就可以在dev分支上正常提交，比如对readme.txt做个修改，加上一行： Creating a new branch is quick. 然后提交： $ git add readme.txt $ git commit -m \"branch test\" [dev b17d20e] branch test 1 file changed, 1 insertion(+) 现在，dev分支的工作完成，我们就可以切换回master分支： $ git checkout master Switched to branch 'master' 切换回master分支后，再查看一个readme.txt文件，刚才添加的内容不见了！因为那个提交是在dev分支上，而master分支此刻的提交点并没有变： 现在，我们把dev分支的工作成果合并到master分支上： $ git merge dev Updating d46f35e..b17d20e Fast-forward readme.txt | 1 + 1 file changed, 1 insertion(+) git merge命令用于合并指定分支到当前分支。合并后，再查看readme.txt的内容，就可以看到，和dev分支的最新提交是完全一样的。 注意到上面的Fast-forward信息，Git告诉我们，这次合并是“快进模式”，也就是直接把master指向dev的当前提交，所以合并速度非常快。 当然，也不是每次合并都能Fast-forward，我们后面会讲其他方式的合并。 合并完成后，就可以放心地删除dev分支了： $ git branch -d dev Deleted branch dev (was b17d20e). 删除后，查看branch，就只剩下master分支了： $ git branch * master 因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在master分支上工作效果是一样的，但过程更安全。 2 switch 我们注意到切换分支使用git checkout ，而前面讲过的撤销修改则是git checkout -- ，同一个命令，有两种作用，确实有点令人迷惑。 实际上，切换分支这个动作，用switch更科学。因此，最新版本的Git提供了新的git switch命令来切换分支： 创建并切换到新的dev分支，可以使用： $ git switch -c dev 直接切换到已有的master分支，可以使用： $ git switch master 使用新的git switch命令，比git checkout要更容易理解。 3 小结 Git鼓励大量使用分支： 查看分支：git branch 创建分支：git branch 切换分支：git checkout 或者git switch 创建+切换分支：git checkout -b 或者git switch -c 合并某分支到当前分支：git merge 删除分支：git branch -d 4.2 解决冲突 1 解决冲突 人生不如意之事十之八九，合并分支往往也不是一帆风顺的。 准备新的feature1分支，继续我们的新分支开发： $ git switch -c feature1 Switched to a new branch 'feature1' 修改readme.txt最后一行，改为： Creating a new branch is quick AND simple. 在feature1分支上提交： $ git add readme.txt $ git commit -m \"AND simple\" [feature1 14096d0] AND simple 1 file changed, 1 insertion(+), 1 deletion(-) 切换到master分支： $ git switch master Switched to branch 'master' Your branch is ahead of 'origin/master' by 1 commit. (use \"git push\" to publish your local commits) Git还会自动提示我们当前master分支比远程的master分支要超前1个提交。 在master分支上把readme.txt文件的最后一行改为： Creating a new branch is quick & simple. 提交： $ git add readme.txt $ git commit -m \"& simple\" [master 5dc6824] & simple 1 file changed, 1 insertion(+), 1 deletion(-) 现在，master分支和feature1分支各自都分别有新的提交，变成了这样： HEAD │ │ ▼ master │ │ ▼ ┌───┐ ┌─▶│ │ ┌───┐ ┌───┐ ┌───┐ │ └───┘ │ │───▶│ │───▶│ │──┤ └───┘ └───┘ └───┘ │ ┌───┐ └─▶│ │ └───┘ ▲ │ │ feature1 这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看： $ git merge feature1 Auto-merging readme.txt CONFLICT (content): Merge conflict in readme.txt Automatic merge failed; fix conflicts and then commit the result. 果然冲突了！Git告诉我们，readme.txt文件存在冲突，必须手动解决冲突后再提交。git status也可以告诉我们冲突的文件： $ git status On branch master Your branch is ahead of 'origin/master' by 2 commits. (use \"git push\" to publish your local commits) You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge) Unmerged paths: (use \"git add ...\" to mark resolution) both modified: readme.txt no changes added to commit (use \"git add\" and/or \"git commit -a\") 我们可以直接查看readme.txt的内容： Git is a distributed version control system. Git is free software distributed under the GPL. Git has a mutable index called stage. Git tracks changes of files. >>>>>> feature1 Git用，=======，>>>>>>>标记出不同分支的内容，我们修改如下后保存： Creating a new branch is quick and simple. 再提交： $ git add readme.txt $ git commit -m \"conflict fixed\" [master cf810e4] conflict fixed 现在，master分支和feature1分支变成了下图所示： HEAD │ │ ▼ master │ │ ▼ ┌───┐ ┌───┐ ┌─▶│ │───▶│ │ ┌───┐ ┌───┐ ┌───┐ │ └───┘ └───┘ │ │───▶│ │───▶│ │──┤ ▲ └───┘ └───┘ └───┘ │ ┌───┐ │ └─▶│ │──────┘ └───┘ ▲ │ │ feature1 用带参数的git log也可以看到分支的合并情况： $ git log --graph --pretty=oneline --abbrev-commit * cf810e4 (HEAD -> master) conflict fixed |\\ | * 14096d0 (feature1) AND simple * | 5dc6824 & simple |/ * b17d20e branch test * d46f35e (origin/master) remove test.txt * b84166e add test.txt * 519219b git tracks changes * e43a48b understand how stage works * 1094adb append GPL * e475afc add distributed * eaadf4e wrote a readme file 最后，删除feature1分支： $ git branch -d feature1 Deleted branch feature1 (was 14096d0). 工作完成。 2 小结 当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 用git log --graph命令可以看到分支合并图。 4.3 分支管理策略 1 分支管理策略 通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下--no-ff方式的git merge： 首先，仍然创建并切换dev分支： $ git switch -c dev Switched to a new branch 'dev' 修改readme.txt文件，并提交一个新的commit： $ git add readme.txt $ git commit -m \"add merge\" [dev f52c633] add merge 1 file changed, 1 insertion(+) 现在，我们切换回master： $ git switch master Switched to branch 'master' 准备合并dev分支，请注意--no-ff参数，表示禁用Fast forward： $ git merge --no-ff -m \"merge with no-ff\" dev Merge made by the 'recursive' strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。 合并后，我们用git log看看分支历史： $ git log --graph --pretty=oneline --abbrev-commit * e1e9c68 (HEAD -> master) merge with no-ff |\\ | * f52c633 (dev) add merge |/ * cf810e4 conflict fixed ... 可以看到，不使用Fast forward模式，merge后就像这样： 2 分支策略 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。 所以，团队合作的分支看起来就像这样： 3 小结 Git分支十分强大，在团队开发中应该充分应用。 合并分支时，加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。 4.4 Bug分支 1 Bug分支 软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。 当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支issue-101来修复它。但是，等等，当前正在dev上进行的工作还没有提交： $ git status On branch dev Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: hello.py Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt 并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？ 幸好，Git还提供了一个stash功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作： $ git stash Saved working directory and index state WIP on dev: f52c633 add merge 现在，用git status查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。 首先确定要在哪个分支上修复bug，假定需要在master分支上修复，就从master创建临时分支： $ git checkout master Switched to branch 'master' Your branch is ahead of 'origin/master' by 6 commits. (use \"git push\" to publish your local commits) $ git checkout -b issue-101 Switched to a new branch 'issue-101' 现在修复bug，需要把“Git is free software ...”改为“Git is a free software ...”，然后提交： $ git add readme.txt $ git commit -m \"fix bug 101\" [issue-101 4c805e2] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) 修复完成后，切换到master分支，并完成合并，最后删除issue-101分支： $ git switch master Switched to branch 'master' Your branch is ahead of 'origin/master' by 6 commits. (use \"git push\" to publish your local commits) $ git merge --no-ff -m \"merged bug fix 101\" issue-101 Merge made by the 'recursive' strategy. readme.txt | 2 +- 1 file changed, 1 insertion(+), 1 deletion(-) 太棒了，原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到dev分支干活了！ $ git switch dev Switched to branch 'dev' $ git status On branch dev nothing to commit, working tree clean 工作区是干净的，刚才的工作现场存到哪去了？用git stash list命令看看： $ git stash list stash@{0}: WIP on dev: f52c633 add merge 工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法： 一是用git stash apply恢复，但是恢复后，stash内容并不删除，你需要用git stash drop来删除； 另一种方式是用git stash pop，恢复的同时把stash内容也删了： $ git stash pop On branch dev Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: hello.py Changes not staged for commit: (use \"git add ...\" to update what will be committed) (use \"git checkout -- ...\" to discard changes in working directory) modified: readme.txt Dropped refs/stash@{0} (5d677e2ee266f39ea296182fb2354265b91b3b2a) 再用git stash list查看，就看不到任何stash内容了： $ git stash list 你可以多次stash，恢复的时候，先用git stash list查看，然后恢复指定的stash，用命令： $ git stash apply stash@{0} 在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。 那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？ 有木有更简单的方法？ 有！ 同样的bug，要在dev上修复，我们只需要把4c805e2 fix bug 101这个提交所做的修改“复制”到dev分支。注意：我们只想复制4c805e2 fix bug 101这个提交所做的修改，并不是把整个master分支merge过来。 为了方便操作，Git专门提供了一个cherry-pick命令，让我们能复制一个特定的提交到当前分支： $ git branch * dev master $ git cherry-pick 4c805e2 [master 1d4b803] fix bug 101 1 file changed, 1 insertion(+), 1 deletion(-) Git自动给dev分支做了一次提交，注意这次提交的commit是1d4b803，它并不同于master的4c805e2。因为这两个commit只是改动相同，但确实是两个不同的commit。用git cherry-pick，我们就不需要在dev分支上手动再把修bug的过程重复一遍。 有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要git stash命令保存现场，才能从dev分支切换到master分支。 2 小结 修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除； 当手头工作没有完成时，先把工作现场git stash一下，然后去修复bug。修复后，再git stash pop，回到工作现场； 在master分支上修复的bug，想要合并到当前dev分支，可以用git cherry-pick 命令，把bug提交的修改“复制”到当前分支，避免重复劳动。 4.5 Feature分支 1 Feature分支 软件开发中，总有无穷无尽的新的功能要不断添加进来。 添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了。所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。 现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。 于是准备开发： $ git switch -c feature-vulcan Switched to a new branch 'feature-vulcan' 5分钟后，开发完毕： $ git add vulcan.py $ git status On branch feature-vulcan Changes to be committed: (use \"git reset HEAD ...\" to unstage) new file: vulcan.py $ git commit -m \"add feature vulcan\" [feature-vulcan 287773e] add feature vulcan 1 file changed, 2 insertions(+) create mode 100644 vulcan.py 切回dev，准备合并： $ git switch dev 一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。 但是！ 就在此时，接到上级命令，因经费不足，新功能必须取消！ 虽然白干了，但是这个包含机密资料的分支还是必须就地销毁： $ git branch -d feature-vulcan error: The branch 'feature-vulcan' is not fully merged. If you are sure you want to delete it, run 'git branch -D feature-vulcan'. 销毁失败。Git友情提醒，feature-vulcan分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的-D参数。。 现在我们强行删除： $ git branch -D feature-vulcan Deleted branch feature-vulcan (was 287773e). 终于删除成功！ 2 小结 开发一个新feature，最好新建一个分支； 如果要丢弃一个没有被合并过的分支，可以通过git branch -D 强行删除。 4.6 多人协作 1 多人协作 当你从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了。并且，远程仓库的默认名称是origin。 要查看远程库的信息，用git remote： $ git remote origin 或者，用git remote -v显示更详细的信息： $ git remote -v origin git@github.com:michaelliao/learngit.git (fetch) origin git@github.com:michaelliao/learngit.git (push) 上面显示了可以抓取和推送的origin的地址。如果没有推送权限，就看不到push的地址。 2 推送分支 推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： $ git push origin master 如果要推送其他分支，比如dev，就改成： $ git push origin dev 但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？ master分支是主分支，因此要时刻与远程同步； dev分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步； bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug； feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。 总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！ 3 抓取分支 多人协作时，大家都会往master和dev分支上推送各自的修改。 现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆： $ git clone git@github.com:michaelliao/learngit.git Cloning into 'learngit'... remote: Counting objects: 40, done. remote: Compressing objects: 100% (21/21), done. remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0 Receiving objects: 100% (40/40), done. Resolving deltas: 100% (14/14), done. 当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的master分支。不信可以用git branch命令看看： $ git branch * master 现在，你的小伙伴要在dev分支上开发，就必须创建远程origin的dev分支到本地，于是他用这个命令创建本地dev分支： $ git checkout -b dev origin/dev 现在，他就可以在dev上继续修改，然后，时不时地把dev分支push到远程： $ git add env.txt $ git commit -m \"add env\" [dev 7a5e5dd] add env 1 file changed, 1 insertion(+) create mode 100644 env.txt $ git push origin dev Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 308 bytes | 308.00 KiB/s, done. Total 3 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git f52c633..7a5e5dd dev -> dev 你的小伙伴已经向origin/dev分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送： $ cat env.txt env $ git add env.txt $ git commit -m \"add new env\" [dev 7bd91f1] add new env 1 file changed, 1 insertion(+) create mode 100644 env.txt $ git push origin dev To github.com:michaelliao/learngit.git ! [rejected] dev -> dev (non-fast-forward) error: failed to push some refs to 'git@github.com:michaelliao/learngit.git' hint: Updates were rejected because the tip of your current branch is behind hint: its remote counterpart. Integrate the remote changes (e.g. hint: 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后，在本地合并，解决冲突，再推送： $ git pull There is no tracking information for the current branch. Please specify which branch you want to merge with. See git-pull(1) for details. git pull If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/ dev git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接。根据提示，设置dev和origin/dev的链接： $ git branch --set-upstream-to=origin/dev dev Branch 'dev' set up to track remote branch 'dev' from 'origin'. 再pull： $ git pull Auto-merging env.txt CONFLICT (add/add): Merge conflict in env.txt Automatic merge failed; fix conflicts and then commit the result. 这回git pull成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push： $ git commit -m \"fix env conflict\" [dev 57c53ab] fix env conflict $ git push origin dev Counting objects: 6, done. Delta compression using up to 4 threads. Compressing objects: 100% (4/4), done. Writing objects: 100% (6/6), 621 bytes | 621.00 KiB/s, done. Total 6 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git 7a5e5dd..57c53ab dev -> dev 因此，多人协作的工作模式通常是这样： 1 首先，可以试图用git push origin 推送自己的修改；2 如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；3 如果合并有冲突，则解决冲突，并在本地提交；4 没有冲突或者解决掉冲突后，再用git push origin 推送就能成功！ 如果git pull提示no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令git branch --set-upstream-to origin/。 这就是多人协作的工作模式，一旦熟悉了，就非常简单。 4 小结 查看远程库信息，使用git remote -v； 本地新建的分支如果不推送到远程，对其他人就是不可见的； 从本地推送分支，使用git push origin branch-name，如果推送失败，先用git pull抓取远程的新提交； 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致； 建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name； 从远程抓取分支，使用git pull，如果有冲突，要先处理冲突。 4.7 Rebase 1 Rebase 在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。 每次合并再push后，分支变成了这样： $ git log --graph --pretty=oneline --abbrev-commit * d1be385 (HEAD -> master, origin/master) init hello * e5e69f1 Merge branch 'dev' |\\ | * 57c53ab (origin/dev, dev) fix env conflict | |\\ | | * 7a5e5dd add env | * | 7bd91f1 add new env | |/ * | 12a631b merged bug fix 101 |\\ \\ | * | 4c805e2 fix bug 101 |/ / * | e1e9c68 merge with no-ff |\\ \\ | |/ | * f52c633 add merge |/ * cf810e4 conflict fixed 总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？ 其实是可以做到的！ Git有一种称为rebase的操作，有人把它翻译成“变基”。 先不要随意展开想象。我们还是从实际问题出发，看看怎么把分叉的提交变成直线。 在和远程分支同步后，我们对hello.py这个文件做了两次提交。用git log命令看看： $ git log --graph --pretty=oneline --abbrev-commit * 582d922 (HEAD -> master) add author * 8875536 add comment * d1be385 (origin/master) init hello * e5e69f1 Merge branch 'dev' |\\ | * 57c53ab (origin/dev, dev) fix env conflict | |\\ | | * 7a5e5dd add env | * | 7bd91f1 add new env ... 注意到Git用(HEAD -> master)和(origin/master)标识出当前分支的HEAD和远程origin的位置分别是582d922 add author和d1be385 init hello，本地分支比远程分支快两个提交。 现在我们尝试推送本地分支： $ git push origin master To github.com:michaelliao/learngit.git ! [rejected] master -> master (fetch first) error: failed to push some refs to 'git@github.com:michaelliao/learngit.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. 很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下： $ git pull remote: Counting objects: 3, done. remote: Compressing objects: 100% (1/1), done. remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0 Unpacking objects: 100% (3/3), done. From github.com:michaelliao/learngit d1be385..f005ed4 master -> origin/master * [new tag] v1.0 -> v1.0 Auto-merging hello.py Merge made by the 'recursive' strategy. hello.py | 1 + 1 file changed, 1 insertion(+) 再用git status看看状态： $ git status On branch master Your branch is ahead of 'origin/master' by 3 commits. (use \"git push\" to publish your local commits) nothing to commit, working tree clean 加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。 用git log看看： $ git log --graph --pretty=oneline --abbrev-commit * e0ea545 (HEAD -> master) Merge branch 'master' of github.com:michaelliao/learngit |\\ | * f005ed4 (origin/master) set exit=1 * | 582d922 add author * | 8875536 add comment |/ * d1be385 init hello ... 对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？ 有！ 什么问题？ 不好看！ 有没有解决方法？ 有！ 这个时候，rebase就派上了用场。我们输入命令git rebase试试： $ git rebase First, rewinding head to replay your work on top of it... Applying: add comment Using index info to reconstruct a base tree... M hello.py Falling back to patching base and 3-way merge... Auto-merging hello.py Applying: add author Using index info to reconstruct a base tree... M hello.py Falling back to patching base and 3-way merge... Auto-merging hello.py 输出了一大堆操作，到底是啥效果？再用git log看看： $ git log --graph --pretty=oneline --abbrev-commit * 7e61ed4 (HEAD -> master) add author * 3611cfe add comment * f005ed4 (origin/master) set exit=1 * d1be385 init hello ... 原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了f005ed4 (origin/master) set exit=1之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的。但是，我们本地的commit修改内容已经变化了，它们的修改不再基于d1be385 init hello，而是基于f005ed4 (origin/master) set exit=1，但最后的提交7e61ed4内容是一致的。 这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。 最后，通过push操作把本地分支推送到远程： Mac:~/learngit michael$ git push origin master Counting objects: 6, done. Delta compression using up to 4 threads. Compressing objects: 100% (5/5), done. Writing objects: 100% (6/6), 576 bytes | 576.00 KiB/s, done. Total 6 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), completed with 1 local object. To github.com:michaelliao/learngit.git f005ed4..7e61ed4 master -> master 再用git log看看效果： $ git log --graph --pretty=oneline --abbrev-commit * 7e61ed4 (HEAD -> master, origin/master) add author * 3611cfe add comment * f005ed4 set exit=1 * d1be385 init hello ... 远程分支的提交历史也是一条直线。 2 小结 rebase操作可以把本地未push的分叉提交历史整理成直线； rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。 5 标签管理 1 标签管理 发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。 Git有commit，为什么还要引入tag？ “请把上周一的那个版本打包发布，commit号是6a5819e...” “一串乱七八糟的数字不好找！” 如果换一个办法： “请把上周一的那个版本打包发布，版本号是v1.2” “好的，按照tag v1.2查找commit就行！” 所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。 5.1 创建标签 1 创建标签 在Git中打标签非常简单，首先，切换到需要打标签的分支上： $ git branch * dev master $ git checkout master Switched to branch 'master' 然后，敲命令git tag 就可以打一个新标签： $ git tag v1.0 可以用命令git tag查看所有标签： $ git tag v1.0 默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是找到历史提交的commit id，然后打上就可以了： $ git log --pretty=oneline --abbrev-commit 12a631b (HEAD -> master, tag: v1.0, origin/master) merged bug fix 101 4c805e2 fix bug 101 e1e9c68 merge with no-ff f52c633 add merge cf810e4 conflict fixed 5dc6824 & simple 14096d0 AND simple b17d20e branch test d46f35e remove test.txt b84166e add test.txt 519219b git tracks changes e43a48b understand how stage works 1094adb append GPL e475afc add distributed eaadf4e wrote a readme file 比方说要对add merge这次提交打标签，它对应的commit id是f52c633，敲入命令： $ git tag v0.9 f52c633 再用命令git tag查看标签： $ git tag v0.9 v1.0 注意，标签不是按时间顺序列出，而是按字母排序的。可以用git show 查看标签信息： $ git show v0.9 commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9) Author: Michael Liao Date: Fri May 18 21:56:54 2018 +0800 add merge diff --git a/readme.txt b/readme.txt ... 可以看到，v0.9确实打在add merge这次提交上。 还可以创建带有说明的标签，用-a指定标签名，-m指定说明文字： $ git tag -a v0.1 -m \"version 0.1 released\" 1094adb 用命令git show 可以看到说明文字： $ git show v0.1 tag v0.1 Tagger: Michael Liao Date: Fri May 18 22:48:43 2018 +0800 version 0.1 released commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1) Author: Michael Liao Date: Fri May 18 21:06:15 2018 +0800 append GPL diff --git a/readme.txt b/readme.txt ... 注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 2 小结 命令git tag 用于新建一个标签，默认为HEAD，也可以指定一个commit id； 命令git tag -a -m \"blablabla...\"可以指定标签信息； 命令git tag可以查看所有标签。 5.2 操作标签 1 操作标签 如果标签打错了，也可以删除： $ git tag -d v0.1 Deleted tag 'v0.1' (was f15b0dd) 因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。 如果要推送某个标签到远程，使用命令git push origin ： $ git push origin v1.0 Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v1.0 -> v1.0 或者，一次性推送全部尚未推送到远程的本地标签： $ git push origin --tags Total 0 (delta 0), reused 0 (delta 0) To github.com:michaelliao/learngit.git * [new tag] v0.9 -> v0.9 如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除： $ git tag -d v0.9 Deleted tag 'v0.9' (was f52c633) 然后，从远程删除。删除命令也是push，但是格式如下： $ git push origin :refs/tags/v0.9 To github.com:michaelliao/learngit.git - [deleted] v0.9 要看看是否真的从远程库删除了标签，可以登陆GitHub查看。 2 小结 命令git push origin 可以推送一个本地标签到远程； 命令git push origin --tags可以推送全部未推送过的本地标签到远程； 命令git tag -d 可以删除一个本地标签； 命令git push origin :refs/tags/可以删除一个远程标签。 6 使用Github 1 使用Github 我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。 在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的。因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。 但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。 如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页https://github.com/twbs/bootstrap，点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone： git clone git@github.com:michaelliao/bootstrap.git 一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址git@github.com:twbs/bootstrap.git克隆，因为没有权限，你将不能推送修改。 Bootstrap的官方仓库twbs/bootstrap、你在GitHub上克隆的仓库my/bootstrap，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样： ┌─ GitHub ────────────────────────────────────┐ │ │ │ ┌─────────────────┐ ┌─────────────────┐ │ │ │ twbs/bootstrap │────>│ my/bootstrap │ │ │ └─────────────────┘ └─────────────────┘ │ │ ▲ │ └──────────────────────────────────┼──────────┘ ▼ ┌─────────────────┐ │ local/bootstrap │ └─────────────────┘ 如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。 如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。 如果你没能力修改bootstrap，但又想要试一把pull request，那就Fork一下我的仓库：https://github.com/michaelliao/learngit，创建一个`your-github-id.txt`的文本文件，写点自己学习Git的心得，然后推送一个pull request给我，我会视心情而定是否接受。 2 小结 在GitHub上，可以任意Fork开源仓库； 自己拥有Fork后的仓库的读写权限； 可以推送pull request给官方仓库来贡献代码。 7 使用Gitee 1 使用Gitee 使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。 如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——Gitee（gitee.com）。 和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。 Gitee的免费版本也提供私有库功能，只是有5人的成员上限。 Gitee企业版正在优惠中： 买1年送1个月：优惠码lhkYPzFJ 买2年送3个月：优惠码YGyEBFZC 买3年送6个月：优惠码qBNwfvET Gitee企业版专属购买通道 >> 小提示：记得先复制优惠码信息，在购买页面输入优惠码即可。 使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。选择右上角用户头像 -> 菜单“修改资料”，然后选择“SSH公钥”，填写一个便于识别的标题，然后把用户主目录下的.ssh/id_rsa.pub文件的内容粘贴进去： 点击“确定”即可完成并看到刚才添加的Key： 如果我们已经有了一个本地的git仓库（例如，一个名为learngit的本地库），如何把它关联到Gitee的远程库上呢？ 首先，我们在Gitee上创建一个新的项目，选择右上角用户头像 -> 菜单“控制面板”，然后点击“创建项目”： 项目名称最好与本地库保持一致： 然后，我们在本地库上使用命令git remote add把它和Gitee的远程库关联： git remote add origin git@gitee.com:liaoxuefeng/learngit.git 之后，就可以正常地用git push和git pull推送了！ 如果在使用命令git remote add时报错： git remote add origin git@gitee.com:liaoxuefeng/learngit.git fatal: remote origin already exists. 这说明本地库已经关联了一个名叫origin的远程库，此时，可以先用git remote -v查看远程库信息： git remote -v origin git@github.com:michaelliao/learngit.git (fetch) origin git@github.com:michaelliao/learngit.git (push) 可以看到，本地库已经关联了origin的远程库，并且，该远程库指向GitHub。 我们可以删除已有的GitHub远程库： git remote rm origin 再关联Gitee的远程库（注意路径中需要填写正确的用户名）： git remote add origin git@gitee.com:liaoxuefeng/learngit.git 此时，我们再查看远程库信息： git remote -v origin git@gitee.com:liaoxuefeng/learngit.git (fetch) origin git@gitee.com:liaoxuefeng/learngit.git (push) 现在可以看到，origin已经被关联到Gitee的远程库了。通过git push命令就可以把本地库推送到Gitee上。 有的小伙伴又要问了，一个本地库能不能既关联GitHub，又关联Gitee呢？ 答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。 使用多个远程库时，我们要注意，git给远程库起的默认名称是origin，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。 仍然以learngit本地库为例，我们先删除已关联的名为origin的远程库： git remote rm origin 然后，先关联GitHub的远程库： git remote add github git@github.com:michaelliao/learngit.git 注意，远程库的名称叫github，不叫origin了。 接着，再关联Gitee的远程库： git remote add gitee git@gitee.com:liaoxuefeng/learngit.git 同样注意，远程库的名称叫gitee，不叫origin。 现在，我们用git remote -v查看远程库信息，可以看到两个远程库： git remote -v gitee git@gitee.com:liaoxuefeng/learngit.git (fetch) gitee git@gitee.com:liaoxuefeng/learngit.git (push) github git@github.com:michaelliao/learngit.git (fetch) github git@github.com:michaelliao/learngit.git (push) 如果要推送到GitHub，使用命令： git push github master 如果要推送到Gitee，使用命令： git push gitee master 这样一来，我们的本地库就可以同时与多个远程库互相同步： ┌─────────┐ ┌─────────┐ │ GitHub │ │ Gitee │ └─────────┘ └─────────┘ ▲ ▲ └─────┬─────┘ │ ┌─────────────┐ │ Local Repo │ └─────────────┘ Gitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。你可以通过Fork我的仓库：https://gitee.com/liaoxuefeng/learngit，创建一个your-gitee-id.txt的文本文件， 写点自己学习Git的心得，然后推送一个pull request给我，这个仓库会在Gitee和GitHub做双向同步。 8 自定义Git 1 自定义Git 在安装Git一节中，我们已经配置了user.name和user.email，实际上，Git还有很多可配置项。 比如，让Git显示颜色，会让命令输出看起来更醒目： $ git config --global color.ui true 这样，Git会适当地显示不同的颜色，比如git status命令： 文件名就会标上颜色。 我们在后面还会介绍如何更好地配置Git，以便让你的工作更高效。 8.1 忽略特殊文件 1 忽略特殊文件 有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次git status都会显示Untracked files ...，有强迫症的童鞋心里肯定不爽。 好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。 注意：.gitignore文件本身应该提交给Git管理，这样可以确保所有人在同一项目下都使用相同的.gitignore文件。 不需要从头写.gitignore文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：https://github.com/github/gitignore 忽略文件的原则是： 1 忽略操作系统自动生成的文件，比如缩略图等； 2 忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的.class文件； 3 忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。 举个例子： 假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件了。如果有自定义目录，目录下就会有Desktop.ini文件，因此你需要忽略Windows自动生成的垃圾文件： # Windows: Thumbs.db ehthumbs.db Desktop.ini 然后，继续忽略Python编译产生的.pyc、.pyo、dist等文件或目录： # Python: *.py[cod] *.so *.egg *.egg-info dist build 加上你自己定义的文件，最终得到一个完整的.gitignore文件，内容如下： # Windows: Thumbs.db ehthumbs.db Desktop.ini # Python: *.py[cod] *.so *.egg *.egg-info dist build # My configurations: db.ini deploy_key_rsa 最后一步就是把.gitignore也提交到Git，就完成了！当然检验.gitignore的标准是git status命令是不是说working directory clean。 使用Windows的童鞋注意了，如果你在资源管理器里新建一个.gitignore文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为.gitignore了。 有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被.gitignore忽略了： $ git add App.class The following paths are ignored by one of your .gitignore files: App.class Use -f if you really want to add them. 如果你确实想添加该文件，可以用-f强制添加到Git： $ git add -f App.class 或者你发现，可能是.gitignore写得有问题，需要找出来到底哪个规则写错了，可以用git check-ignore命令检查： $ git check-ignore -v App.class .gitignore:3:*.class App.class Git会告诉我们，.gitignore的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。 还有些时候，当我们编写了规则排除了部分文件时： # 排除所有.开头的隐藏文件: .* # 排除所有.class文件: *.class 但是我们发现.*这个规则把.gitignore也排除了，并且App.class需要被添加到版本库，但是被*.class规则排除了。 虽然可以用git add -f强制添加进去，但有强迫症的童鞋还是希望不要破坏.gitignore规则，这个时候，可以添加两条例外规则： # 排除所有.开头的隐藏文件: .* # 排除所有.class文件: *.class # 不排除.gitignore和App.class: !.gitignore !App.class 把指定文件排除在.gitignore规则外的写法就是!+文件名，所以，只需把例外文件添加进去即可。 可以通过https://gitignore.itranswarp.com在线生成.gitignore文件。 2 小结 忽略某些文件时，需要编写.gitignore； .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理！ 8.2 配置别名 1 配置别名 有没有经常敲错命令？比如git status？status这个单词真心不好记。 如果敲git st就表示git status那就简单多了，当然这种偷懒的办法我们是极力赞成的。 我们只需要敲一行命令，告诉Git，以后st就表示status： $ git config --global alias.st status 好了，现在敲git st看看效果。 当然还有别的命令可以简写，很多人都用co表示checkout，ci表示commit，br表示branch： $ git config --global alias.co checkout $ git config --global alias.ci commit $ git config --global alias.br branch 以后提交就可以简写成： $ git ci -m \"bala bala bala...\" --global参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。 在撤销修改一节中，我们知道，命令git reset HEAD file可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个unstage别名： $ git config --global alias.unstage 'reset HEAD' 当你敲入命令： $ git unstage test.py 实际上Git执行的是： $ git reset HEAD test.py 配置一个git last，让其显示最后一次提交信息： $ git config --global alias.last 'log -1' 这样，用git last就能显示最近一次的提交： $ git last commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2 Merge: bd6ae48 291bea8 Author: Michael Liao Date: Thu Aug 22 22:49:22 2013 +0800 merge & fix hello.py 甚至还有人丧心病狂地把lg配置成了： git config --global alias.lg \"log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit\" 来看看git lg的效果： 为什么不早点告诉我？别激动，咱不是为了多记几个英文单词嘛！ 2 配置文件 配置Git的时候，加上--global是针对当前用户起作用的。如果不加，那只针对当前的仓库起作用。 配置文件放哪了？每个仓库的Git配置文件都放在.git/config文件中： $ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true [remote \"origin\"] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/* [branch \"master\"] remote = origin merge = refs/heads/master [alias] last = log -1 别名就在[alias]后面，要删除别名，直接把对应的行删掉即可。 而当前用户的Git配置文件放在用户主目录下的一个隐藏文件.gitconfig中： $ cat .gitconfig [alias] co = checkout ci = commit br = branch st = status [user] name = Your Name email = your@email.com 配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。 3 小结 给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。 8.3 搭建Git服务器 1 搭建Git服务器 在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。 GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。 搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的apt命令就可以完成安装。 假设你已经有sudo权限的用户账号，下面，正式开始安装。 第一步，安装git： $ sudo apt-get install git 第二步，创建一个git用户，用来运行git服务： $ sudo adduser git 第三步，创建证书登录： 收集所有需要登录的用户的公钥，就是他们自己的id_rsa.pub文件，把所有公钥导入到/home/git/.ssh/authorized_keys文件里，一行一个。 第四步，初始化Git仓库： 先选定一个目录作为Git仓库，假定是/srv/sample.git，在/srv目录下输入命令： $ sudo git init --bare sample.git Git就会创建一个裸仓库，裸仓库没有工作区。因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以.git结尾。然后，把owner改为git： $ sudo chown -R git:git sample.git 第五步，禁用shell登录： 出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑/etc/passwd文件完成。找到类似下面的一行： git:x:1001:1001:,,,:/home/git:/bin/bash 改为： git:x:1001:1001:,,,:/home/git:/usr/bin/git-shell 这样，git用户可以正常通过ssh使用git，但无法登录shell，因为我们为git用户指定的git-shell每次一登录就自动退出。 第六步，克隆远程仓库： 现在，可以通过git clone命令克隆远程仓库了，在各自的电脑上运行： $ git clone git@server:/srv/sample.git Cloning into 'sample'... warning: You appear to have cloned an empty repository. 剩下的推送就简单了。 2 管理公钥 如果团队很小，把每个人的公钥收集起来放到服务器的/home/git/.ssh/authorized_keys文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用Gitosis来管理公钥。 这里我们不介绍怎么玩Gitosis了，几百号人的团队基本都在500强了，相信找个高水平的Linux管理员问题不大。 3 管理权限 有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。Gitolite就是这个工具。 这里我们也不介绍Gitolite了，不要把有限的生命浪费到权限斗争中。 4 小结 搭建Git服务器非常简单，通常10分钟即可完成； 要方便管理公钥，用Gitosis； 要像SVN那样变态地控制权限，用Gitolite。 9 使用SourceTree 1 使用SourceTree 当我们对Git的提交、分支已经非常熟悉，可以熟练使用命令操作Git后，再使用GUI工具，就可以更高效。 Git有很多图形界面工具，这里我们推荐SourceTree，它是由Atlassian开发的免费Git图形界面工具，可以操作任何Git库。 首先从官网下载SourceTree并安装，然后直接运行SourceTree。 第一次运行SourceTree时，SourceTree并不知道我们的Git库在哪。如果本地已经有了Git库，直接从资源管理器把文件夹拖拽到SourceTree上，就添加了一个本地Git库： 也可以选择“New”-“Clone from URL”直接从远程克隆到本地。 2 提交 我们双击learngit这个本地库，SourceTree会打开另一个窗口，展示这个Git库的当前所有分支以及文件状态。选择左侧面板的“WORKSPACE”-“File status”，右侧会列出当前已修改的文件（Unstaged files）： 选中某个文件，该文件就自动添加到“Staged files”，实际上是执行了git add README.md命令： 然后，我们在下方输入Commit描述，点击“Commit”，就完成了一个本地提交： 实际上是执行了git commit -m \"update README.md\"命令。 使用SourceTree进行提交就是这么简单，它的优势在于可以可视化地观察文件的修改，并以红色和绿色高亮显示。 3 分支 在左侧面板的“BRANCHES”下，列出了当前本地库的所有分支。当前分支会加粗并用○标记。要切换分支，我们只需要选择该分支，例如master，然后点击右键，在弹出菜单中选择“Checkout master”，实际上是执行命令git checkout master： 要合并分支，同样选择待合并分支，例如dev，然后点击右键，在弹出菜单中选择“Merge dev into master”，实际上是执行命令git merge dev： 4 推送 在SourceTree的工具栏上，分别有Pull和Push，分别对应命令git pull和git push，只需注意本地和远程分支的名称要对应起来，使用时十分简单。 注意到使用SourceTree时，我们只是省下了敲命令的麻烦，SourceTree本身还是通过Git命令来执行任何操作。如果操作失败，SourceTree会自动显示执行的Git命令以及错误信息，我们可以通过Git返回的错误信息知道出错的原因： 5 小结 使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便。 SourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。 10 期末总结 终于到了期末总结的时刻了！ 经过几天的学习，相信你对Git已经初步掌握。一开始，可能觉得Git上手比较困难，尤其是已经熟悉SVN的童鞋，没关系，多操练几次，就会越用越顺手。 Git虽然极其强大，命令繁多，但常用的就那么十来个，掌握好这十几个常用命令，你已经可以得心应手地使用Git了。 友情附赠Git Cheat Sheet，建议打印出来备用： Git Cheat Sheet 现在告诉你Git的官方网站：http://git-scm.com，英文自我感觉不错的童鞋，可以经常去官网看看。 如果你学了Git后，工作效率大增，有更多的空闲时间健身看电影，那我的教学目标就达到了。 谢谢观看！new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/Git-2.html":{"url":"Markdown/Tools/Git-2.html","title":"1.2 Git常用指令","keywords":"","body":"1.2 Git常用指令 1 使用远程仓库 1 Git 全局设置 创建版本库之前，首先要进行 Git 全局设置。 因为使用了--global参数，这个设置一次即可，所有版本库都会使用这个参数 git config --global user.name \"Your Name\" git config --global user.email \"email@example.com\" 2 创建版本库第一步：创建空目录 cd ~ mkdir GitRepo 第二步：通过git init命令把这个目录变成 Git 可以管理的仓库 cd GitRepo git init 3 把文件添加到版本库 touch README.md git add README.md 4 提交文件到暂存库 git commit -m \"first commit\" 5 添加SSH Key第一步：创建SSH Key 在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件。如果已经有了，可直接跳过此步骤。如果没有，打开终端，创建SSH Key： ssh-keygen -t rsa -C \"youremail@example.com\" 第二步：添加SSH Key 登陆GitHub，打开“Account settings”，“SSH Keys”页面。然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴id_rsa.pub文件的内容。点“Add Key”，你就应该看到已经添加的Key。 6 添加远程库第一步：新建仓库 登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库。在Repository name填入GitRepo，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库。 第二步：关联远程仓库 把一个已有的本地仓库与远程仓库关联，把本地仓库的内容推送到GitHub仓库。在本地的GitRepo仓库下运行命令： git remote add origin git@github.com:YourGitRepoName/gitrepo.git 远程库的名字就是origin，这是Git默认的叫法，也可以改成别的，但是origin这个名字一看就知道是远程库。后面的 URL 使用 HTTPS 或者 SSH 都可以，一般使用 SSH。 7 本地推送到远程执行完上述步骤，就可以把本地库的所有内容推送到远程库上： git push -u origin master 备注： 第一次推送时使用-u参数，用于将本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令，不使用-u参数 当你第一次使用Git的clone或者push命令连接GitHub时，会得到一个警告。这是因为 Git 使用 SSH 连接，而 SSH 连接在第一次验证 GitHub 服务器的 Key 时，需要你确认 GitHub 的 Key 的指纹信息是否真的来自 GitHub 的服务器，输入yes回车即可。 8 拉取远程仓库内容语法：git pull : git pull origin next:master 9 查询和删除远程仓库查询远程仓库： git remote -v 删除远程仓库： git remote rm origin 10 从远程仓库克隆 mkdir RemoteRepo cd RemoteRepo git clone git@github.com:YourGitRepoName/RepoName.git 2 Git Cheat Sheet 1 GIT BASICS 命令 解释 git init 在指定的目录下创建一个空的 git repo。不带参数将在当前目录下创建一个 git repo。 git clone 克隆一个指定repo到本地。指定的可以是由 HTTP 或 SSH 指定的远程仓库路径或者本地文件系统。 git add 将指定目录的所有修改加入到下一次 commit 中。把 替换成 将添加指定文件的修改。 git commit -m \"\" 提交暂存区的修改，使用指定的 作为提交信息，而不是打开文本编辑器输入提交信息。 git status 显示哪些文件已被 staged、未被 staged 以及未跟踪 untracked。 git log 以缺省格式显示全部 commit 历史。更多自定义参数请参考后续部分。 repo 表示 仓库 2 GIT DIFF 命令 解释 git diff ⽐较⼯作区和暂存区的修改。 git diff HEAD ⽐较⼯作区和上⼀次 commit 后的修改。 git diff --cached ⽐较暂存区和上⼀次 commit 后的修改。 3 UNDOING CHANGEAS 命令 解释 git revert 对指定 创建⼀个 undo 的 commit，并应⽤到当前分⽀。 git reset 将 从暂存区移除，但保持⼯作区不变。此操作不会修改⼯作区的任何⽂件。 4 REWRITING GIT HISTORY 命令 解释 git commit -m --amend 将当前 staged 修改合并到最近⼀次的 commit 中。 git rebase 基于 对当前分⽀进⾏ rebase。 可以是 commit、分⽀名称、tag 或相对于 HEAD 的 commit。 git reflog 显示本地 repo 的所有 commit ⽇志。 5 GIT BRANCHES 命令 解释 git branch 显示本地 repo 的所有分⽀。 git switch -c 创建并切换到⼀个新的名为 的分⽀。去掉 -c 参数将切换到⼀个已有分⽀。 git merge 将指定 分⽀合并到当前分⽀。 6 REMOTE REPOSITORIES 命令 解释 git remote add 添加⼀个新的远程连接。添加后可使⽤ 作为指定 远程连接的名称。 git fetch 从指定 抓取指定 的所有 commit 到本地 repo。去掉 将抓取远程所有分⽀的修改。 git pull 从指定 抓取所有分⽀的 commit 并⽴刻合并到本地 repo。 git push 将本地指定 推送到指定远程 。如果远程没有对应的分⽀，将⾃动在远程创建此分⽀。 7 GIT CONFIG 命令 解释 git config --global user.name 配置当前⽤户名，使⽤--global参数将针对当前系统登录⽤户⽣效。 git config --global user.email 配置当前⽤户Email。 git config --global alias. 配置⼀个 git 命令的快捷⽅式。例如：配置”alias.glog log --graph --oneline”使”git glog”相当于”git log --graph --oneline”. git config --system core.editor 配置⽂本编辑器，例如vi，在必要时⾃动打开此⽂本编辑器。 git config --global --edit 打开当前⽤户的 git 全局配置并编辑。 8 GIT LOG 命令 解释 git log - 限制 log 的显示数量。例如：”git log -5” 仅显示最新 5 条 commit。 git log --oneline 每⾏显示⼀条commit。 git log --author=\"\" 按提交者名字搜索并显示 commit。 git log --grep=\"\" 按指定内容搜索并显示 commit。 git log .. 显示指定范围的 commit。范围参数可以是 commit ID、分⽀名称、HEAD或任意相对位置。 git log -- 仅显示包含指定⽂件修改的 commit。 git log --graph 使⽤--graph参数显示图形化的 branch 信息。 9 GIT RESET 命令 解释 git reset 移除所有暂存区的修改，但不会修改⼯作区。 git reset --hard 移除所有暂存区的修改，并强制删除所有⼯作区的修改。 git reset > 将当前分⽀回滚到指定 ，清除暂存区的修改，但保持⼯作区状态不变。 git reset --hard 将当前分⽀回滚到指定 ，清除暂存区的修改，并强制删除所有⼯作区的修改。 10 GIT REBASE 命令 解释 git rebase -i 以交互模式对当前分⽀做rebase。 11 GIT PULL 命令 解释 git pull --rebase 抓取所有远程分⽀，并以 rebase 模式并⼊本地 repo ⽽不是 merge。 12 GIT PUSH 命令 解释 git push --force 将本地分⽀推送到远程。不要使⽤--force参数，除⾮你完全明⽩此操作的后果。 git push --tags 使⽤ push 命令并不会⾃动将本地 tag 推送到远程。加上--tags参数会将所有本地 tag 推送到远程。 3 工作区、版本库和暂存区示意图 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/Git-3.html":{"url":"Markdown/Tools/Git-3.html","title":"1.3 Git疑难解答","keywords":"","body":"1.3 Git 疑难解答 1 git pull的用法 git pull命令用于从另一个存储库或本地分支获取并集成(整合)。git pull命令的作用是：取回远程主机某个分支的更新，再与本地的指定分支合并，它的完整格式如下： git pull [options] [ […]] 常见格式： git pull : 1 描述 将远程存储库中的更改合并到当前分支中。在默认模式下，git pull是git fetch后跟git merge FETCH_HEAD的缩写。 更准确地说，git pull使用给定的参数运行git fetch，并调用git merge将检索到的分支头合并到当前分支中。 使用–rebase，它运行git rebase而不是git merge。 2 示例 取回 origin 主机的 next 分支，与本地的 master 分支合并： git pull origin next:master 如果远程分支 next 要与当前分支合并，则冒号后面的部分可以省略: git pull origin next 上面命令表示，取回 origin/next 分支，再与当前分支合并。实质上，这等同于先做 git fetch，再执行 git merge。 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系(tracking)。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。 Git也允许手动建立追踪关系。 git branch --set-upstream master origin/next 上面命令指定master分支追踪origin/next分支。如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名: git pull origin 上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”(remote-tracking branch)进行合并。 如果当前分支只有一个追踪分支，连远程主机名都可以省略: git pull 上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用rebase模式，可以使用–rebase选项: git pull --rebase : 3 git fetch 和 git pull 的区别 git fetch：相当于是从远程获取最新版本到本地，不会自动合并。 git fetch origin master git log -p master..origin/master git merge origin/master 以上命令的含义： 首先从远程的origin的master主分支下载最新的版本到origin/master分支上，然后比较本地的master分支和origin/master分支的差别最后进行合并 git pull：相当于是从远程获取最新版本并merge到本地 git pull origin master 上述命令其实相当于git fetch 和 git merge。 在实际使用中，git fetch更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。 原文出自【易百教程】 原文链接：https://www.yiibai.com/git/git_pull.htmlnew Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/Markdown-1.html":{"url":"Markdown/Tools/Markdown-1.html","title":"2.1 Markdown基本语法","keywords":"","body":"2.1 Markdown 基本语法 Markdown官方教程： https://markdown.com.cn/ 1 标题 语法： # 一级标题 （快捷键Ctrl+1） ## 二级标题 （快捷键Ctrl+2） ### 三级标题 （快捷键Ctrl+3） #### 四级标题 （快捷键Ctrl+4） ##### 五级标题 （快捷键Ctrl+5） ###### 六级标题 （快捷键Ctrl+6） 执行效果： 2 段落 语法： 使用空白行将一行或多行文本进行分隔: 第一段: I really like using Markdown. 第二段: I think I'll use it to format all of my documents from now on. 执行效果：使用空白行将一行或多行文本进行分隔:第一段: I really like using Markdown. 第二段: I think I'll use it to format all of my documents from now on. 3 换行 语法1： 在一行末尾加两个空格后回车进行换行: 第一段: I really like using Markdown. 第二段: I think I'll use it to format all of my documents from now on. 执行效果：在一行末尾加两个空格后回车进行换行:第一段: I really like using Markdown.第二段: I think I'll use it to format all of my documents from now on. 语法2： 使用进行换行: 第一段: I really like using Markdown. 第二段: I think I'll use it to format all of my documents from now on. 执行效果：使用进行换行:第一段: I really like using Markdown. 第二段: I think I'll use it to format all of my documents from now on. 4 首行缩进 语法： 不同特殊占位符所占空白不一样大。 1 &emsp; 或 &#8195;  //全角 举例1： &emsp;&emsp;这是2个&emsp;字节的首行缩进效果 &#8195;&#8195;这是2个&#8195;字节的首行缩进效果 这是没有首行缩进效果 2 &ensp; 或 &#8194;  //半角 举例2： &ensp;&ensp; 这是2个&ensp;字节的首行缩进效果 &&#8194;&#8194;这是2个&#8194;字节的首行缩进效果 这是没有首行缩进效果 执行效果： 举例1：   这是2个&emsp;字节的首行缩进效果   这是2个&#8195;字节的首行缩进效果 这是没有首行缩进效果 举例2：   这是2个&ensp;字节的首行缩进效果   这是2个&#8194;字节的首行缩进效果 这是没有首行缩进效果 5 强调 语法： 1. 加粗 （快捷键Ctrl+B） 在单词或短语前后各加两个**星号**或下划线，__下划线__ 前后不能有字。 2. 斜体 （快捷键Ctrl+I） 在单词或短语前后各加一个*星号*或 _下划线_。 3. 斜体和加粗 在单词或短语的前后各添加三个 ***星号***或 ___下划线___。也可以进行组合，例如：**_A_** 或 __*B*__。 4. 删除 在单词或短语前后各加两个~~飘(Tab上面那个键)~~ 执行效果：1 加粗在单词或短语前后各加两个星号或下划线，下划线 前后不能有字。 2 斜体在单词或短语前后各加一个星号或 下划线。 3 斜体和加粗在单词或短语的前后各添加三个 星号或 下划线。也可以进行组合，例如：A 或 B。 4 删除 在单词或短语前后各加两个飘(Tab上面那个键) 6 引用 语法： 1. 块引用 在段落前添加一个 > 号，例如 >Dorothy followed her through many of the beautiful rooms in her castle. 2. 多个段落块引用 > Dorothy followed her through many of the beautiful rooms in her castle. > > The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 3. 嵌套块引用 >一级嵌套第一段 > >一级嵌套第二段 >>二级嵌套第一段 >> >>二级嵌套第二段 >> >>二级嵌套第三段 >> >>>三级嵌套第一段 >>>三级嵌套第二段 4. 带有其他语法的块引用 > #### The quarterly results look great! > > - Revenue was off the chart. > - Profits were higher than ever. > > *Everything* is going according to **plan**. 执行效果：1 块引用在段落前添加一个 > 号，例如 Dorothy followed her through many of the beautiful rooms in her castle. 2 多个段落块引用 Dorothy followed her through many of the beautiful rooms in her castle. The Witch bade her clean the pots and kettles and sweep the floor and keep the fire fed with wood. 3 嵌套块引用 一级嵌套第一段 一级嵌套第二段 二级嵌套第一段 二级嵌套第二段 二级嵌套第三段 三级嵌套第一段三级嵌套第二段 4 带有其他语法的块引用 The quarterly results look great! Revenue was off the chart. Profits were higher than ever. Everything is going according to plan. 7 列表 语法： 1 有序列表 在列表前添加数字和英文句点，数字必须以1开头，后续不必按照顺序排列。 1. aaa 2. bbb 3. ccc 4. 789 2 无序列表 在列表前添加破折号(-)、(*)或(+)，缩进一个或多个列表项可以创建嵌套列表。 - aaa - bbb - ccc - ddd - eee - fff - ggg - hhh 3 列表中嵌套其他元素 3.1 嵌套段落 * 第一项 * 第二项 需要在第二项下加入其他项目 * 第三项 * 第四项 3.2 引用块 * 第一项 * 第二项 >引用块在第二个项下方 > > * 第三项 3.3 代码块 1. 第一步骤 2. 第二步骤，代码相关操作：（采用两个制表符缩进） Test 3. 第三步骤 4. 第四步骤 3.4 图片 1. 第一步骤 2. 第二步骤，图片相关操作： ![图片不显示时显示](相对路径 \"图片显示时鼠标悬停时显示名称\") 举例：![test picture](images/a.png \"Picture\") > 根据实操结果，markdown中的图片路径最好使用相对路径的方式，如果要引用其他文件夹的图片，需要使用相对路径表示法，表述出其他文件的路径信息，例如: \"../../\"这种方式 3. 第三步骤 3.5 列表 1. 第一项 2. 第二项 3. 第三项 - 缩进项目 - 缩进项目 4. 第四项 5. 第五项 4 任务列表 - [x] Java - [x] 大数据 - [ ] 人工智能 - [x] 机器学习 执行效果：1 有序列表在列表前添加数字和英文句点，数字必须以1开头，后续不必按照顺序排列。 aaa bbb ccc 789 2 无序列表在列表前添加破折号(-)、(*)或(+)，缩进一个或多个列表项可以创建嵌套列表。 aaa bbb ccc ddd eee fff ggg hhh 3 列表中嵌套其他元素3.1 嵌套段落 第一项 第二项需要在第二项下加入其他项目 第三项 第四项 3.2 引用块 第一项 第二项 引用块在第二个项下方 第三项 3.3 代码块 第一步骤 第二步骤，代码相关操作：（采用两个制表符缩进） Test 第三步骤 第四步骤 3.4 图片 第一步骤 第二步骤，图片相关操作： 举例： 根据实操结果，markdown中的图片路径最好使用相对路径的方式，如果要引用其他文件夹的图片，需要使用相对路径表示法，表述出其他文件的路径信息，例如: \"../../\"这种方式 第三步骤 3.5 列表 第一项 第二项 第三项 缩进项目 缩进项目 第四项 第五项 4 任务列表 [x] Java [x] 大数据 [ ] 人工智能 [x] 机器学习 8 代码 语法： 1. 反引号包裹代码 命令提示，`nano`类型 2. 转义反引号 代码的单词或短语中包含多个反引号时使用 ``Use `code` in Markdown file.`` 3. 代码块 3个反引号(```将以下代码填入此处```) Test 执行效果： 1 反引号包裹代码命令提示，nano类型 2 转义反引号代码的单词或短语中包含多个反引号时使用Use `code` in Markdown file. 3 代码块 Test 9 分割线 语法： 使用三个或多个星号(*)、破折号(-)或下划线(_)可创建分割线 *** --- ___ 执行效果：使用三个或多个星号(*)、破折号(-)或下划线(_)可创建分割线 10 链接 语法： 1. 语法代码 [超链接显示名](超链接地址 \"超链接title\") 超链接：[Markdown语法教学](https://markdown.com.cn \"Markdown语法教学链接\") 2. 网址和Email地址 使用尖括号将网址括起 3. 带格式化的链接 在链接语法前后加星号(*)，可以对链接进行加粗 在方括号中加反引号，可将链接表示为代码 Markdown指引网站 **[Markdown Guide](https://www.markdownguide.org)**。 代码链接[`code`](https://eff.org) 执行效果：1 语法代码超链接显示名超链接：Markdown语法教学 2 网址和Email地址 使用尖括号将网址括起https://markdown.com.cnfake@example.com 3 带格式化的链接在链接语法前后加星号(**)，可以对链接进行加粗Markdown指引网站 Markdown Guide。在方括号中加反引号，可将链接表示为代码代码链接code 11 图片 语法： 1. 本地图片连接 ![替代文本](图片相对路径 \"图片title\") ![picture](images/a.png \"1\") 2. 网络图片链接 ![picture2](https://img0.baidu.com/it/u=2767790527,3674585198&fm=253&fmt=auto&app=138&f=JPEG?w=667&h=500\"Shiprock\") 执行效果：1 本地图片连接 2 网络图片链接 12 表格 语法： 默认左对齐 - | 表头1 | 表头2 | | - | - | | 1行1列 | 1行2列 | | 2行1列 | 2行2列 | 表格行和列还可以扩展，格式相同 居中对齐 :-: | 表头1 | 表头2 | | :-: | :-: | | 1行1列 | 1行2列 | | 2行1列 | 2行2列 | 右对齐 -: | 表头1 | 表头2 | | -: | -: | | 1行1列 | 1行2列 | | 2行1列 | 2行2列 | 执行效果： 默认左对齐 - 表头1 表头2 1行1列 1行2列 2行1列 2行2列 表格行和列还可以扩展，格式相同 居中对齐 :-: 表头1 表头2 1行1列 1行2列 2行1列 2行2列 右对齐 -: 表头1 表头2 1行1列 1行2列 2行1列 2行2列 13 转义字符 语法： Markdown中的转义字符为\\，转义的有： \\\\ 反斜杠 \\` 反引号 \\* 星号 \\_ 下划线 \\{\\} 大括号 \\[\\] 中括号 \\(\\) 小括号 \\# 井号 \\+ 加号 \\- 减号 \\. 英文句号 \\! 感叹号 执行效果： \\ 反斜杠 ` 反引号 * 星号 _ 下划线 {} 大括号 [] 中括号 () 小括号 # 井号 + 加号 - 减号 . 英文句号 ! 感叹号 14 字体、字号、颜色 语法： 我是黑体字 我是微软雅黑 我是华文彩云 黑体 gray null 执行效果： 我是黑体字 我是微软雅黑 我是华文彩云 黑体 gray null new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/Markdown-2.html":{"url":"Markdown/Tools/Markdown-2.html","title":"2.2 Markdown数学公式","keywords":"","body":"2.2 Markdown数学公式 [info] 说明 此网页不支持渲染LaTeX公式，但Markdown是支持的，在Markdown中直接使用算式对应的内容，即可看到公式. 1 LaTeX编辑数学公式基本语法元素 ​LaTeX中的数学模式有两种形式:inline (行内公式)和 display(块间公式)。前者是指在正文插入行间数学公式, 后者独立排列, 可以有或没有编号。 行间公式(inline):用$...$将公式括起来。 块间公式(displayed)，用$$...$$将公式括起来是无编号的形式，块间元素默认是居中显示的。 2 公式语法 1 上/下标 算式 语法 $x2$ x^2 $y1$​ y_1 注意：若上/下标的内容超过一个字符，则内容需要使用花括号括起来，下同 例如： $x^2+y_0+y_{n+1}$ 执行效果为： 2 分式 算式 语法 $1/2$ 1/2 $\\frac{1}{2}$​ \\frac{1}{2} 例如： $1/2+\\frac{y+x}{2}+(x+y)/2$ 执行效果为： 3 开方 算式 语法 $\\sqrt{2}$ \\sqrt{2} $\\sqrt[3]{2}$​ \\sqrt[3]{2} 4 累加累乘 算式 语法 $\\sum{a}$ \\sum{a} $\\sum_{n=1}^{100}{a_n}$​ \\sum_{n=1}^{100}{a_n} $\\sum\\limits_{n=1}^{100}{a_n}$ \\sum\\limits_{n=1}^{100}{a_n} $\\prod{x} $​ \\prod{x} $\\prod_{n=1}^{99}{x_n}$ \\prod_{n=1}^{99}{x_n} $\\prod\\limits_{n=1}^{99}{x_n} $​ \\prod\\limits_{n=1}^{99}{x_n} 注意：仅当行内公式时，需要使用\\limits调整下标位置，公式块对一些符号默认上下标在最上下面，因此不需要使用\\limits，下同 举例： $$\\prod_{n=1}^{99}{x_n}$$ 执行效果为： 5 积分 算式 语法 $\\int_0^1f(x)dx$ \\int_0^1f(x)dx 6 极限 算式 语法 $\\lim_{n\\rightarrow\\infty}{n}$ \\lim_{n\\rightarrow\\infty}{n} $\\lim\\limits_{n\\rightarrow\\infty}{n}$ \\lim\\limits_{n\\rightarrow\\infty}{n} 7 对数 算式 语法 $\\ln{x}$ \\ln{x} $\\lg{x}$ \\lg{x} $\\log_a{x}$ \\log_a{x} 8 希腊字母 大写 语法 小写 语法 $A$ A $\\alpha $ \\alpha $B$ B $\\beta $ \\beta $ \\Gamma $ \\Gamma $ \\gamma$ \\gamma $\\Delta$ \\Delta $\\delta$ \\delta $E$ E $ \\epsilon$ \\epsilon $\\varepsilon $ \\varepsilon $Z$ Z $ \\zeta$ \\zeta $H$ H $\\eta $ \\eta $\\Theta$ \\Theta $\\theta $ \\theta $I $ I $\\iota $ \\iota $K$ K $ \\kappa$ \\kappa $\\Lambda$ \\Lambda $ \\lambda$ \\lambda $M$ M $\\mu $ \\mu $N$ N $\\nu $ \\nu $\\Xi$ \\Xi $ \\xi$ \\xi $O$ O $ \\omicron$ \\omicron $\\Pi$ \\Pi $ \\pi$ \\pi $P$ P $\\rho $ \\rho $\\Sigma$ \\Sigma $\\sigma $ \\sigma $T$ T $\\tau $ \\tau $\\Upsilon$ \\Upsilon $ \\upsilon$ \\upsilon $\\Phi$ \\Phi $ \\phi$ \\phi $ \\varphi$ \\varphi $X$ X $ \\chi$ \\chi $\\Psi$ \\Psi $\\psi $ \\psi $\\Omega$ \\Omega $ \\omega$ \\omega 9 三角函数 算式 语法 $\\sin{x} $ \\sin{x} $\\cos{x} $ \\cos{x} $ \\tan{x} $ \\tan{x} $\\arcsin{x}$ \\arcsin{x} $\\arccos{x} $ \\arccos{x} $\\arctan{x}$ \\arctan{x} 10 运算符 算式 语法 $\\pm $ \\pm $\\times $ \\times $ \\cdot $ \\cdot $\\div$ \\div $\\neq $ \\neq $\\equiv$ \\equiv $\\leq$ \\leq $\\geq$ \\geq $\\approx$ \\approx 11 特殊字符 算式 语法 $ \\forall $ \\forall $\\exists $ \\exists $ \\infty$ \\infty $\\emptyset$ \\emptyset $\\cdots $ \\cdots $\\nabla$ \\nabla $\\bot$ \\bot $\\angle$ \\angle $\\because$ \\because $\\therefore$ \\therefore 空格 \\quad $\\approx$ \\approx $360^\\circ$ 360^\\circ $\\in$ \\in $\\notin$ \\notin ${$ { $}$ } 12 箭头 算式 语法 $ \\uparrow $ \\uparrow $\\downarrow $ \\downarrow $\\Uparrow $ \\Uparrow $ \\Downarrow$ \\Downarrow $\\updownarrow$ \\updownarrow $\\Updownarrow $ \\Updownarrow $\\rightarrow$ \\rightarrow $\\leftarrow$ \\leftarrow $\\Rightarrow$ \\Rightarrow $\\Leftarrow$ \\Leftarrow $\\leftrightarrow$ \\leftrightarrow $\\Leftrightarrow$ \\Leftrightarrow $\\longrightarrow$ \\longrightarrow $\\longleftarrow$ \\longleftarrow $\\Longrightarrow$ \\Longrightarrow $\\Longleftarrow$ \\Longleftarrow $\\longleftrightarrow$ \\longleftrightarrow $\\Longleftrightarrow$ \\Longleftrightarrow 13 上\\下花括号 算式 语法 $ \\overbrace{a+b+\\dots+n}^{m个} $ \\overbrace{a+b+\\dots+n}^{m个} $\\underbrace{a+b+\\dots+n}_{m个} $ \\underbrace{a+b+\\dots+n}_{m个} 14 分段函数\\方程组 语法： \\left左符号(左符号'.'表示省略，下同) \\begin{cases} 第一行\\\\(其中，\\\\是换行，下同) 第二行\\\\ ... \\end{cases} \\right右符号(若左符号和右符号都为'.'，则\\left\\right可以省略) 举例： $$ \\left. \\begin{cases} a_1x+b_1y+c_1z=d_1\\\\ a_2x+b_2y+c_2z=d_2\\\\ a_3x+b_3y+c_3z=d_3 \\end{cases} \\right\\} \\Rightarrow \\begin{cases} x=z=1\\\\ y=2 \\end{cases} $$ 执行效果： 15 连等式 语法： \\begin{align} 第一行左式 &= 第一行右式\\\\ 第二行左式 &= 第二行右式\\\\ ... \\end{align} 举例： $$ \\begin{align} f(x) &= x^2+2x+1\\\\ &=(x+1)^2 \\end{align} $$ 执行效果： 16 矩阵 语法： \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}\\\\ \\begin{matrix} 0 & 1 \\\\ 1 & 0 \\end{matrix}\\\\ \\begin{pmatrix} 0 & -i \\\\ i & 0 \\end{pmatrix}\\\\ \\begin{Bmatrix} 1 & 0 \\\\ 0 & -1 \\end{Bmatrix}\\\\ \\begin{vmatrix} a & b \\\\ c & d \\end{vmatrix}\\\\ \\begin{Vmatrix} i & 0 \\\\ 0 & -i \\end{Vmatrix} 执行效果： new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Tools/Cmake-1.html":{"url":"Markdown/Tools/Cmake-1.html","title":"3 Cmake","keywords":"","body":"3 Cmake CMake Practice（CMake 实践） -- Cjacker 为了阅读方便，本文档整理摘抄自互联网上的PDF版本，仅供学习参考使用。 PDF及练习参考代码：https://pan.baidu.com/s/14tSQq5ggZ4e1xCrCl_BUSw 提取码：6666 前言 cmake 已经开发了 5、6 年的时间，如果没有 KDE4，也许不会有人或者 Linux 发行版本重视 cmake，因为除了 Kitware 似乎没有人使用它。通过 KDE4 的选型和开发，cmake 逐渐进入了人们的视线，在实际的使用过程中，cmake 的优势也逐渐的被大家所认识，至少 KDE 的开发者们给予了 cmake 极高的评价，同时庞大的 KDE 项目使用 cmake 来作为构建工具也证明了 cmake 的可用性和大项目管理能力。 所以，cmake 应该感谢 KDE，也正因为如此，cmake 的开发者投入了 KDE 从 autotools 到 cmake 的迁移过程中，并相当快速和顺利的完成了迁移，现在整个 KDE4 开发版本全部使用 cmake 构建。 这也是促使我们学习 cmake 的原因，首先 cmake 被接受并成功应用，其次，cmake 的优势在实际使用中不断的体现出来。 我们为什么不来认识一下这款优秀的工程构建工具呢？ 在 2006 年 KDE 大会，听 cmake 开发者当面介绍了 cmake 之后，我就开始关注 cmake，并将 cmake 纳入了 Everest 发行版，作为系统默认组件。最近 QT-4.3 也正式进入了 Everest 系统，为 KDE4 构建完成了准备工作。 但是，在学习 cmake 的过程中，发现官方的文档非常的少，而且错误也较多，比如：在介绍 Find 模块编写的文档中，模块名称为 FOO，但是后面却出现了 Foo_FIND_QUIETLY 的定义，这显然是错误的，这样的定义永远不可能有效，正确的定义是 FOO_FIND_QUIETLY。种种原因，促使我开始写一份“面向使用和实用”的 cmake 文档，也就是本教程《cmake 实践》(Cmake Practice)。 本文档是边学习边编写的成果，更像是一个学习笔记和 Tutorial，因此难免有失误或者理解不够透彻的地方，比如，我仍然不能理解为什么绝大部分使用变量的情况要通过${}引用，而在 IF 语句中却必须直接使用变量名。也希望能够有 cmake 的高手来指点迷津。 补：从 cmake 的 maillist，我找到了一些答案，原文是： The IF(var)or IF(NOT var) command expects var to be the name of a variable. This is stated in CMake's manual. So, for your situation IF(${libX}) is the same as IF(/usr/lib/xorg) and then CMake will check the value of the variable named /usr/lib/xorg. 也就是说 IF 需要的是变量名而不是变量值。 这个文档是开放的，开放的目的是为了让更多的人能够读到并且能够修改，任何人都可以对它作出修改和补充，但是，为了大家都能够获得你关于 cmake 的经验和积累，如果你发现错误或者添加了新内容后，请务必 CC 给我一份，让我们共同把 cmake 掌握的更好。 一、初识 cmake CMake 不再使你在构建项目时郁闷地想自杀了。 --一位 KDE 开发者 1. 背景知识 cmake 是 kitware 公司以及一些开源开发者在开发几个工具套件(VTK)的过程中的衍生品，最终形成体系，成为一个独立的开放源代码的项目。项目的诞生时间是 2001 年。其官方网站是 www.cmake.org，可以通过访问官方网站获得更多关于 cmake 的信息。cmake 的流行其实要归功于 KDE4 的开发(似乎跟当年的 svn 一样，KDE 将代码仓库从 CVS 迁移到 SVN，同时证明了 SVN 管理大型项目的可用性)，在 KDE 开发者使用了近 10 年 autotools 之后，他们终于决定为 KDE4 选择一个新的工程构建工具，其根本原因用 KDE 开发者的话来说就是：只有少数几个“编译专家”能够掌握 KDE 现在的构建体系(admin/Makefile.common)。在经历了 unsermake， scons 以及 cmake 的选型和尝试之后，KDE4 决定使用 cmake 作为自己的构建系统。在迁移过程中，进展异常的顺利，并获得了 cmake 开发者的支持。所以，目前的 KDE4 开发版本已经完全使用 cmake 来进行构建。像 kdesvn，rosegarden 等项目也开始使用cmake，这也注定了 cmake 必然会成为一个主流的构建体系。 2. 特点 cmake 的特点主要有： 1 开放源代码，使用类 BSD 许可发布 http://cmake.org/HTML/Copyright.html 2 跨平台，并可生成 native 编译配置文件，在 Linux/Unix 平台，生成 makefile；在苹果平台，可以生成 xcode；在 Windows 平台，可以生成 MSVC 的工程文件。 3 能够管理大型项目，KDE4 就是最好的证明。 4 简化编译构建过程和编译过程。Cmake 的工具链非常简单：cmake+make。 5 高效虑，按照 KDE 官方说法，CMake 构建 KDE4 的 kdelibs 要比使用 autotools 来构建 KDE3.5.6 的 kdelibs 快 40%，主要是因为 Cmake 在工具链中没有 libtool。 6 可扩展，可以为 cmake 编写特定功能的模块，扩充 cmake 功能。 3. 问题，难道就没有问题？ 1 cmake 很简单，但绝对没有听起来或者想象中那么简单。 2 cmake 编写的过程实际上是编程的过程，跟以前使用 autotools 一样，不过你需要编写的是 CMakeLists.txt(每个目录一个)，使用的是”cmake 语言和语法”。 3 cmake 跟已有体系的配合并不是特别理想，比如 pkgconfig，您在实际使用中会有所体会，虽然有一些扩展可以使用，但并不理想。 4. 个人的建议 1 如果你没有实际的项目需求，那么看到这里就可以停下来了，因为 cmake 的学习过程就是实践过程，没有实践，读的再多几天后也会忘记。 2 如果你的工程只有几个文件，直接编写 Makefile 是最好的选择。 3 如果使用的是 C/C++/Java 之外的语言，请不要使用 cmake(至少目前是这样)。 4 如果你使用的语言有非常完备的构建体系，比如 java 的 ant，也不需要学习 cmake，虽然有成功的例子，比如 QT4.3 的 csharp 绑定 qyoto。 5 如果项目已经采用了非常完备的工程管理工具，并且不存在维护问题，没有必要迁移到 cmake 。 6 如果仅仅使用 qt 编程，没有必要使用 cmake，因为 qmake 管理 Qt 工程的专业性和自动化程度比 cmake 要高很多。 二、安装 cmake 还需要安装吗？ cmake 目前已经成为各大 Linux 发行版提供的组件，比如 Everest 直接在系统中包含，Fedora 在 extra 仓库中提供，所以，需要自己动手安装的可能性很小。如果你使用的操作系统(比如 Windows 或者某些 Linux 版本)没有提供 cmake 或者包含的版本较旧，建议你直接从 cmake 官方网站下载安装。 http://www.cmake.org/HTML/Download.html 在这个页面，提供了源代码的下载以及针对各种不同操作系统的二进制下载，可以选择适合自己操作系统的版本下载安装。因为各个系统的安装方式和包管理格式有所不同，在此就不再赘述了，相信一定能够顺利安装 cmake。 三、初试 cmake — cmake 的 helloworld Hello world，世界 你好 本节选择了一个最简单的例子 Helloworld 来演练一下 cmake 的完整构建过程，本节并不会深入的探讨 cmake，仅仅展示一个简单的例子，并加以粗略的解释。我们选择了 Everest Linux 作为基本开发平台，因为这个只有一张 CD 的发行版本，包含了 gcc4.2/gtk/qt3/qt4等完整的开发环境，同时，系统默认集成了 cmake 最新版本 2.4.6。 [info] 备注：此处使用 Ubuntu 操作亦可 1. 准备工作 首先，在家目录下新建 /backup 目录， 在 /backup 目录下建立一个 cmake 目录，用来放置我们学习过程中的所有练习。 cd ~ mkdir -p /backup/cmake 以后我们所有的 cmake 练习都会放在 /backup/cmake 的子目录下(你也可以自行安排目录，这个并不是限制，仅仅是为了叙述的方便)。 然后在 cmake 建立第一个练习目录 t1： cd /backup/cmake mkdir t1 cd t1 在 t1 目录建立 main.c 和 CMakeLists.txt(注意文件名大小写)： main.c 文件内容： // main.c #include int main() { printf(\"Hello World from t1 Main!\\n\"); return 0; } CmakeLists.txt 文件内容： PROJECT(HELLO) SET(SRC_LIST main.c) MESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINARY_DIR}) MESSAGE(STATUS \"This is SOURCE dir \" ${HELLO_SOURCE_DIR}) ADD_EXECUTABLE(hello ${SRC_LIST}) 2. 开始构建 所有的文件创建完成后，t1 目录中应该存在 main.c 和 CMakeLists.txt 两个文件。接下来我们来构建这个工程，在这个目录中点击右键，打开终端，在终端中输入：cmake . (注意命令后面的点号，代表本目录)。 输出大概是这个样子： -- The C compiler identification is GNU 9.4.0 -- The CXX compiler identification is GNU 9.4.0 -- Check for working C compiler: /usr/bin/cc -- Check for working C compiler: /usr/bin/cc -- works -- Detecting C compiler ABI info -- Detecting C compiler ABI info - done -- Detecting C compile features -- Detecting C compile features - done -- Check for working CXX compiler: /usr/bin/c++ -- Check for working CXX compiler: /usr/bin/c++ -- works -- Detecting CXX compiler ABI info -- Detecting CXX compiler ABI info - done -- Detecting CXX compile features -- Detecting CXX compile features - done -- This a BINARY dir /home/qlf/backup/cmake/t1 -- This a SOURCE dir /home/qlf/backup/cmake/t1 -- Configuring done -- Generating done -- Build files have been written to: /home/qlf/backup/cmake/t1 再让我们看一下目录中的内容，你会发现，系统自动生成了： CMakeFiles，CMakeCache.txt，cmake_install.cmake 等文件，并且生成了 Makefile。 然后进行工程的实际构建，继续在终端中输入 make 命令，大概会得到如下的彩色输出： Scanning dependencies of target hello [ 50%] Building C object CMakeFiles/hello.dir/main.c.o [100%] Linking C executable hello [100%] Built target hello 如果你需要看到 make 构建的详细过程，可以使用 make VERBOSE=1 或者 VERBOSE=1 make 命令来进行构建。 这时候，我们需要的目标文件 hello 已经构建完成，位于当前目录，尝试在终端中输入： ./hello 得到输出： Hello World from t1 Main! 恭喜您，到这里为止您已经完全掌握了 cmake 的使用方法。 3. 简单的解释 我们来重新看一下 CMakeLists.txt，这个文件是 cmake 的构建定义文件，文件名是大小写相关的，如果工程存在多个目录，需要确保每个要管理的目录都存在一个 CMakeLists.txt。(关于多目录构建，后面我们会提到，这里不作过多解释)。 上面例子中的 CMakeLists.txt 文件内容如下： PROJECT (HELLO) SET(SRC_LIST main.c) MESSAGE(STATUS \"This is BINARY dir \" ${HELLO_BINARY_DIR}) MESSAGE(STATUS \"This is SOURCE dir \" ${HELLO_SOURCE_DIR}) ADD_EXECUTABLE(hello ${SRC_LIST}) PROJECT 指令的语法是： PROJECT(projectname [CXX] [C] [Java]) 你可以用这个指令定义工程名称，并可指定工程支持的语言，支持的语言列表是可以忽略的，默认情况表示支持所有语言。这个指令隐式的定义了两个 cmake 变量： _BINARY_DIR 以及 _SOURCE_DIR，这里就是 HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR (所以 CMakeLists.txt 中两个 MESSAGE 指令可以直接使用了这两个变量)，因为采用的是内部编译，两个变量目前指的都是工程所在路径/backup/cmake/t1，后面我们会讲到外部编译，两者所指代的内容会有所不同。 同时 cmake 系统也帮助我们预定义了 PROJECT_BINARY_DIR 和 PROJECT_SOURCE_DIR 变量，他们的值分别跟 HELLO_BINARY_DIR 与 HELLO_SOURCE_DIR 一致。 为了统一起见，建议以后直接使用PROJECT_BINARY_DIR和PROJECT_SOURCE_DIR，即使修改了工程名称，也不会影响这两个变量。如果使用了，修改工程名称后，需要同时修改这些变量。 SET指令的语法是： SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) 现阶段，你只需要了解 SET 指令可以用来显式的定义变量即可。比如我们用到的是SET(SRC_LIST main.c)，如果有多个源文件，也可以定义成：SET(SRC_LIST main.c t1.c t2.c)。 MESSAGE语法的指令是： MESSAGE([SEND_ERROR | STATUS | FATAL_ERROR] \"message to display\" ...) 这个指令用于向终端输出用户定义的信息，包含了三种类型： 1 SEND_ERROR，产生错误，生成过程被跳过 2 STATUS，输出前缀为--的信息 3 FATAL_ERROR，立即终止所有cmake过程 我们在这里使用的是 STATUS 信息输出，演示了由 PROJECT 指令定义的两个隐式变量 HELLO_BINARY_DIR 和 HELLO_SOURCE_DIR。 ADD_EXECUTABLE(hello ${SRC_LIST}) 定义了这个工程会生成一个文件名为 hello 的可执行文件，相关的源文件是 SRC_LIST 中定义的源文件列表， 本例中你也可以直接写成ADD_EXECUTABLE(hello main.c)。 在本例我们使用了${}来引用变量，这是 cmake 的变量引用方式。但是，有一些例外，比如在 IF 控制语句，变量是直接使用变量名引用，而不需要${}。如果使用了${}去应用变量，其实 IF 会去判断名为${}所代表的值的变量，那当然是不存在的了。 将本例改写成一个最简化的CMakeLists.txt： PROJECT(HELLO) ADD_EXECUTABLE(hello main.c) 4. 基本语法规则 前面提到过，cmake 其实仍然要使用”cmake 语言和语法”去构建，上面的内容就是所谓的 ”cmake 语言和语法”，最简单的语法规则是： 1 变量使用${}方式取值，但是在 IF 控制语句 中是直接使用变量名。 2 指令(参数1 参数2...) 参数使用括弧括起，参数之间使用空格或分号分开。 以上面的 ADD_EXECUTABLE 指令为例，如果存在另外一个 func.c 源文件，就要写成： ADD_EXECUTABLE(hello main.c func.c)或者 ADD_EXECUTABLE(hello main.c;func.c) 3 指令是大小写无关的，参数和变量是大小写相关的。但，推荐你全部使用大写指令。 上面的 MESSAGE 指令已经用到了这条规则： MESSAGE(STATUS “This is BINARY dir” ${HELLO_BINARY_DIR}) 也可以写成： MESSAGE(STATUS “This is BINARY dir ${HELLO_BINARY_DIR}”) 这里需要特别解释的是作为工程名 HELLO 和生成的可执行文件 hello 是没有任何关系的。hello 定义的可执行文件的文件名，你完全可以写成：ADD_EXTCUTABLE(t1 main.c)，编译后会生成一个 t1 可执行文件。 5. 关于语法的疑惑 cmake 的语法还是比较灵活而且考虑到各种情况，比如 SET(SRC_LIST main.c) 也可以写成 SET(SRC_LIST \"main.c\") 是没有区别的，但是假设一个源文件的文件名是 fu nc.c(文件名中间包含了空格)。 这时候就必须使用双引号，如果写成了SET(SRC_LIST fu nc.c)，就会出现错误，提示你找不到 fu 文件和 nc.c 文件。这种情况，就必须写成：SET(SRC_LIST \"fu nc.c\")。 此外，你可以可以忽略掉 source 列表中的源文件后缀，比如可以写成 ADD_EXECUTABLE(t1 main)，cmake 会自动的在本目录查找 main.c 或者 main.cpp 等，当然，最好不要偷这个懒，以免这个目录确实存在一个 main.c 一个 main。 同时参数也可以使用分号来进行分割。 下面的例子也是合法的： ADD_EXECUTABLE(t1 main.c t1.c) 可以写成 ADD_EXECUTABLE(t1 main.c;t1.c)。 我们只需要在编写 CMakeLists.txt 时注意形成统一的风格即可。 6. 清理工程 跟经典的 autotools 系列工具一样，运行： make clean 即可对构建结果进行清理。 7. 问题？问题！ “我尝试运行了 make distclean，这个指令一般用来清理构建过程中产生的中间文件的，如果要发布代码，必然要清理掉所有的中间文件，但是为什么在 cmake 工程中这个命令是无效的?” 是的，cmake 并不支持 make distclean，关于这一点，官方是有明确解释的： 因为 CMakeLists.txt 可以执行脚本并通过脚本生成一些临时文件，但是却没有办法来跟踪这些临时文件到底是哪些。因此，没有办法提供一个可靠的 make distclean 方案。 Some build trees created with GNU autotools have a \"make distclean\" target that cleans the build and also removes Makefiles and other parts of the generated build system. CMake does not generate a \"make distclean\" target because CMakeLists.txt files can run scripts and arbitrary commands; CMake has no way of tracking exactly which files are generated as part of running CMake. Providing a distclean target would give users the false impression that it would work as expected. (CMake does generate a \"make clean\" target to remove files generated by the compiler and linker.) A \"make distclean\" target is only necessary if the user performs an in-source build. CMake supports in-source builds, but we strongly encourage users to adopt the notion of an out-of-source build. Using a build tree that is separate from the source tree will prevent CMake from generating any files in the source tree. Because CMake does not change the source tree, there is no need for a distclean target. One can start a fresh build by deleting the build tree or creating a separate build tree. 同时，还有另外一个非常重要的提示，就是：我们刚才进行的是内部构建(in-source build)，而 cmake 强烈推荐的是外部构建(out-of-source build)。 8. 内部构建与外部构建 上面的例子展示的是“内部构建”，相信看到生成的临时文件比您的代码文件还要多的时候，估计这辈子你都不希望再使用内部构建 :-D 举个简单的例子来说明外部构建，以编译 wxGTK 动态库和静态库为例，在 Everest 中打包方式是这样的： 解开 wxGTK 后， 在其中建立 static 和 shared 目录， 进入 static 目录，运行 ../configure –enable-static;make 会在 static 目录生成 wxGTK 的静态库， 进入 shared 目录，运行 ../configure –enable-shared;make 就会在 shared 目录生成动态库。 这就是外部编译的一个简单例子。 对于 cmake ，内部编译上面已经演示过了，它生成了一些无法自动删除的中间文件，所以，引出了我们对外部编译的探讨，外部编译的过程如下： 1 首先请清除 t1 目录中除 main.c、CMakeLists.txt之外的所有中间文件，最关键的是CMakeCache.txt。2 在 t1 目录中建立 build 目录，当然你也可以在任何地方建立 build 目录，不一定必须在工程目录中。 3 进入 build 目录 ，在终端中执行cmake ..（注意，..代表父目录，因为父目录存在我们需要的 CMakeLists.txt，如果你在其他地方建立了 build 目录，需要运行 cmake ），查看一下 build 目录，就会发现生成了编译需要的 Makefile 以及其他的中间文件。 4 继续在终端中运行 make 构建工程，就会在当前目录（build 目录）中获得目标文件 hello。 上述过程就是所谓的 out-of-source 外部编译，一个最大的好处是，对于原有的工程没有任何影响，所有动作全部发生在编译目录。通过这一点，也足以说服我们全部采用外部编译方式构建工程。 这里需要特别注意的是： 通过外部编译进行工程构建，HELLO_SOURCE_DIR仍然指代工程目录，即/backup/cmake/t1，而HELLO_BINARY_DIR则指代编译路径，即/backup/cmake/t1/build。 9. 小结 本小结描述了使用 cmake 构建 Hello World 程序全部过程，并介绍了三个简单的指令：PROJECT/MESSAGE/ADD_EXECUTABLE 以及变量调用的方法，同时提及了两个隐式变量 _SOURCE_DIR 及_BINARY_DIR，演示了变量调用的方法。从这个过程来看，有些开发者可能会想，这实在比我写 Makefile 要复杂多了，甚至我都可以不编写 Makefile，直接使用gcc main.c即可生成需要的目标文件。是的，正如第一节提到的，如果工程只有几个文件，还是直接编写 Makefile 最简单。但是，kdelibs 压缩包达到 50M，您认为使用什么方案更容易一点呢？ 下一节，我们的任务是让 Hello World 看起来更像一个工程。 四、更好一点的 Hello world 没有最好，只有更好 从本小节开始，后面所有的构建我们都将采用 out-of-source 外部构建，约定的构建目录是工程目录下的 build 自录。 本小节的任务是让前面的 Hello World 更像一个工程，我们需要做的是： 1 为工程添加一个子目录 src，用来放置工程源代码 2 添加一个子目录 doc，用来放置这个工程的文档 hello.txt 3 在工程目录添加文本文件 COPYRIGHT，README 4 在工程目录添加一个 runhello.sh 脚本，用来调用 hello 二进制 5 将构建后的目标文件放入构建目录的 bin 子目录 6 最终安装这些文件：将 hello 二进制与 runhello.sh 安装至//bin，将doc 目录下的内容以及 COPYRIGHT、README 安装到//usr/share/doc/cmake/t2 备注：表示预定义的路径 1. 准备工作 在~/backup/cmake/目录下建立 t2 目录。 将 t1 工程的 main.c 和 CMakeLists.txt 拷贝到 t2 目录中。 2. 添加子目录src 在t2目录中，打开终端，执行： mkdir src mv main.c src 现在的工程看起来是这个样子： 一个子目录 src，一个 CMakeLists.txt。 上一节我们提到，需要为任何子目录建立一个 CMakeLists.txt，进入子目录 src，编写 CMakeLists.txt 如下： ADD_EXECUTABLE(hello main.c) 将 t2 目录下的 CMakeLists.txt 修改为： PROJECT(HELLO) ADD_SUBDIRECTORY(src bin) 然后建立 build 目录，进入 build 目录进行外部编译： cmake .. make 编译过程中可能会出现No cmake_minimum_required command is present.的警告，这个不影响项目构建，忽略即可。 构建完成后，你会发现生成的目标文件 hello 位于 build/bin 目录中。 语法解释： ADD_SUBDIRECTORY 指令 ADD_SUBDIRECTORY(source_dir [binary_dir] [EXCLUDE_FROM_ALL]) 这个指令用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。EXCLUDE_FROM_ALL 参数的含义是将这个目录从编译过程中排除。比如，工程的 example，可能就需要工程构建完成后，再进入 example 目录单独进行构建(当然，你也可以通过定义依赖来解决此类问题)。 上面的例子定义了将 src 子目录加入工程，并指定编译输出(包含编译中间结果)路径为 bin 目录。如果不进行 bin 目录的指定，那么编译结果(包括中间结果)都将存放在 build/src 目录(这个目录跟原有的 src 目录对应)，指定 bin 目录后，相当于在编译时将 src 重命名为 bin，所有的中间结果和目标二进制都将存放在 bin 目录。 这里需要提一下的是 SUBDIRS 指令，使用方法是： SUBDIRS(dir1 dir2...)，但是这个指令已经不推荐使用。它可以一次添加多个子目录，并且，即使外部编译，子目录体系仍然会被保存。 如果我们在上面的例子中将 ADD_SUBDIRECTORY (src bin) 修改为 SUBDIRS(src)，那么在 build 目录中将出现一个 src 目录，生成的目标代码 hello 将存放在 src 目录中。 3. 换个地方保存目标二进制 不论是 SUBDIRS 还是 ADD_SUBDIRECTORY 指令(不论是否指定编译输出目录)，我们都可以通过 SET 指令重新定义 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 变量来指定最终的目标二进制的位置（指最终生成的 hello 或者最终的共享库，不包含编译生成的中间文件）。 SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_DIR}/bin) SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_DIR}/lib) 在第一节我们提到了 _BINARY_DIR 和 PROJECT_BINARY_DIR 变量，它们指的是编译发生的当前目录。如果是内部编译，就相当于 PROJECT_SOURCE_DIR 也就是工程代码所在目录；如果是外部编译，指的是外部编译所在目录，也就是本例中的 build 目录。 所以，上面两个指令分别定义了： 可执行二进制的输出路径为 build/bin 和库的输出路径为 build/lib。 本节我们没有提到共享库和静态库的构建，所以，你可以不考虑第二条指令。 问题是，我应该把这两条指令写在t2 工程的 CMakeLists.txt 还是 src 目录下的 CMakeLists.txt。把握一个简单的原则，在哪里 ADD_EXECUTABLE 或 ADD_LIBRARY，如果需要改变目标存放路径，就在哪里加入上述的定义。 在这个例子里，当然就是指 src 下的 CMakeLists.txt 了。 4. 如何安装 安装的需要有两种，一种是从代码编译后直接 make install 安装，一种是打包时的指定目录安装。 所以，即使最简单的手工编写的 Makefile，看起来也是这个样子的： DESTDIR= install: mkdir -p $(DESTDIR)/usr/bin install -m 755 hello $(DESTDIR)/usr/bin 你可以通过：make install 将 hello 直接安装到 /usr/bin 目录，也可以通过 make install DESTDIR=/tmp/test 将它安装在 /tmp/test/usr/bin 目录，打包时这个方式经常被使用。 稍微复杂一点的是还需要定义 PREFIX，一般 autotools 工程，会运行这样的指令： ./configure --prefix=/usr 或者 ./configure --prefix=/usr/local 来指定 PREFIX 比如上面的 Makefile 就可以改写成： DESTDIR= PREFIX=/usr install: mkdir -p $(DESTDIR)/$(PREFIX)/bin install -m 755 hello $(DESTDIR)/$(PREFIX)/bin 那么我们的 HelloWorld 应该怎么进行安装呢？ 这里需要引入一个新的 cmake 指令 INSTALL 和一个非常有用的变量 CMAKE_INSTALL_PREFIX。 CMAKE_INSTALL_PREFIX 变量类似于 configure 脚本的 --prefix，常见的使用方法看起来是这个样子：cmake -DCMAKE_INSTALL_PREFIX=/usr。 INSTALL 指令用于定义安装规则，安装的内容可以包括目标二进制、动态库、静态库以及文件、目录、脚本等。 INSTALL 指令包含了各种安装类型，我们需要一个个分开解释： 1. 目标文件的安装： INSTALL(TARGETS targets... [ [ARCHIVE|LIBRARY|RUNTIME] [DESTINATION ] [PERMISSIONS permissions...] [ CONFIGURATIONS [Debug|Release|...] ] [COMPONENT ] [OPTIONAL] ] [...]) 参数中的 TARGETS 后面跟的就是我们通过 ADD_EXECUTABLE 或者 ADD_LIBRARY 定义的目标文件，可能是可执行二进制、动态库、静态库。 目标类型也就相对应的有三种，ARCHIVE 特指静态库，LIBRARY 特指动态库，RUNTIME 特指可执行目标二进制。 DESTINATION 定义了安装的路径，如果路径以/开头，即使用绝对路径，这时候 CMAKE_INSTALL_PREFIX 其实就无效了。如果你希望使用 CMAKE_INSTALL_PREFIX 来定义安装路径，就要写成相对路径，即不要以 /开头，那么安装后的路径就是 ${CMAKE_INSTALL_PREFIX}/。 举个简单的例子： INSTALL(TARGETS myrun mylib mystaticlib RUNTIME DESTINATION bin LIBRARY DESTINATION lib ARCHIVE DESTINATION libstatic ) 上面的例子会将： 可执行目标二进制 myrun 安装到 ${CMAKE_INSTALL_PREFIX}/bin 目录 动态库 mylib 安装到 ${CMAKE_INSTALL_PREFIX}/lib 目录 静态库 mystaticlib 安装到 ${CMAKE_INSTALL_PREFIX}/libstatic 目录 特别注意的是你不需要关心 TARGETS 具体生成的路径，只需要写上 TARGETS 名称就可以了。 2. 普通文件的安装： INSTALL(FILES files... DESTINATION [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [RENAME ] [OPTIONAL] ) 可用于安装一般文件，并可以指定访问权限，文件名是此指令所在路径下的相对路径。如果默认不定义权限 PERMISSIONS，安装后的权限为： OWNER_WRITE, OWNER_READ, GROUP_READ,和 WORLD_READ，即 644 权限。 非目标文件的可执行程序安装(比如脚本之类)： INSTALL(PROGRAMS files... DESTINATION [PERMISSIONS permissions...] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [RENAME ] [OPTIONAL] ) 跟上面的 “普通文件安装” 指令使用方法一样，唯一的不同是安装后权限为： OWNER_EXECUTE, GROUP_EXECUTE, 和 WORLD_EXECUTE，即 755 权限。 3. 目录的安装： INSTALL(DIRECTORY dirs... DESTINATION [FILE_PERMISSIONS permissions...] [DIRECTORY_PERMISSIONS permissions...] [USE_SOURCE_PERMISSIONS] [CONFIGURATIONS [Debug|Release|...]] [COMPONENT ] [[PATTERN | REGEX ] [EXCLUDE] [PERMISSIONS permissions...]] [...] ) 这里主要介绍其中的 DIRECTORY、PATTERN 以及 PERMISSIONS 参数。 DIRECTORY 后面连接的是所在 Source 目录的相对路径，但务必注意：abc 和 abc/有很大的区别。 如果目录名不以 / 结尾，那么这个目录将被安装为目标路径下的 abc，如果目录名以 / 结尾，代表将这个目录中的内容安装到目标路径，但不包括这个目录本身。 PATTERN 用于使用正则表达式进行过滤，PERMISSIONS 用于指定 PATTERN 过滤后的文件权限。 我们来看一个例子： INSTALL(DIRECTORY icons scripts/ DESTINATION share/myproj PATTERN \"CVS\" EXCLUDE PATTERN \"scripts/*\" PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ ) 这条指令的执行结果是： 将 icons 目录安装到 /share/myproj，将 scripts/中的内容安装到 /share/myproj 不包含目录名为 CVS 的目录，对于 scripts/* 文件指定权限为 OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ。 安装时 Cmake 脚本的执行： INSTALL([[SCRIPT ] [CODE ]] [...]) SCRIPT 参数用于在安装时调用 cmake 脚本文件（也就是 .cmake 文件） CODE 参数用于执行 CMAKE 指令，必须以双引号括起来。比如： INSTALL(CODE \"MESSAGE(\\\"Sample install message.\\\")\") 安装还有几个被标记为过时的指令，比如 INSTALL_FILES 等，这些指令已经不再推荐使用，所以，这里就不再赘述了。 下面，我们就来改写我们的工程文件，让它来支持各种文件的安装，并且，我们要使用 CMAKE_INSTALL_PREFIX指令。 5. 修改 Helloworld 支持安装 在本节开头我们定义了本节的任务如下： 1 为工程添加一个子目录 src，用来放置工程源代码 2 添加一个子目录 doc，用来放置这个工程的文档 hello.txt 3 在工程目录添加文本文件 COPYRIGHT，README 4 在工程目录添加一个 runhello.sh 脚本，用来调用 hello 二进制 5 将构建后的目标文件放入构建目录的 bin 子目录 6 最终安装这些文件：将 hello 二进制与 runhello.sh 安装至//bin，将doc 目录下的内容以及 COPYRIGHT、README 安装到//share/doc/cmake/t2 首先我们先补上未添加的文件： 添加 doc 目录及文件 cd ~/backup/cmake/t2 mkdir doc sudo gedit doc/hello.txt #hello.txt中填写：这是 Cmake 练习工程 Helloworld 的 doc 说明文档 在t2工程目录中使用touch runhello.sh命令创建 runhello.sh 脚本，脚本文件中填写： ./hello 在t2工程目录中添加 COPYRIGHT 和 README文件： cd ~/backup/cmake/t2 touch COPYRIGHT touch README 下面改写各目录的 CMakeLists.txt： 1 安装 COPYRIGHT/README，修改t2工程目录中 CMakelists.txt，加入以下指令： INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake/t2) 2 安装 runhello.sh，修改t2工程目录中 CMakeLists.txt，加入如下指令： INSTALL(PROGRAMS runhello.sh DESTINATION bin) 3 安装 doc 中的 hello.txt，这里有两种方式：一是通过在 doc 目录建立 CMakeLists.txt 并将 doc 目录通过 ADD_SUBDIRECTORY 加入工程来完成。另一种方法是直接在工程目录通过 INSTALL(DIRECTORY)来完成。前者比较简单，各位可以根据兴趣自己完成，我们来尝试后者，顺便演示以下 DIRECTORY 的安装。 因为 hello.txt 要安装到 //share/doc/cmake/t2，所以我们不能直接安装整个 doc 目录，这里采用的方式是安装 doc 目录中的内容，也就是使用 doc/。 在t2工程目录中 CMakeLists.txt 中添加： INSTALL(DIRECTORY doc/ DESTINATION share/doc/cmake/t2) 4 @Gavin注：在 src目录的 CMakeLists.txt文件中添加如下内容，以安装 hello 到 //bin中： INSTALL(TARGETS hello RUNTIME DESTINATION bin) 6. 尝试我们修改的结果 现在进入 build 目录进行外部编译，注意使用 CMAKE_INSTALL_PREFIX 参数，这里我们将它安装到了/tmp/t2/usr目录： cmake -DCMAKE_INSTALL_PREFIX=/tmp/t2/usr .. 然后继续在终端运行： make make install 让我们进入/tmp/t2/usr目录，看一下安装结果： ./usr ./usr/share ./usr/share/doc ./usr/share/doc/cmake ./usr/share/doc/cmake/t2 ./usr/share/doc/cmake/t2/hello.txt ./usr/share/doc/cmake/t2/README ./usr/share/doc/cmake/t2/COPYRIGHT ./usr/bin ./usr/bin/hello ./usr/bin/runhello.sh 如果你要直接安装到系统，可以使用如下指令： cmake -DCMAKE_INSTALL_PREFIX=/usr .. 7. 一个疑问 如果我没有定义 CMAKE_INSTALL_PREFIX 会安装到什么地方？ 你可以尝试一下，在 build 目录中打开终端，并执行 cmake .. make make install 你会发现 CMAKE_INSTALL_PREFIX 的默认定义是 /usr/local。 8. 小结 本小节主要描述了如何在工程中使用多目录、各种安装指令以及 CMAKE_INSTALL_PREFIX 变量(你真够牛的，这么点东西居然罗唆了这么多文字)。 在下一小节，我们将探讨如何在 cmake 中构建动态库和静态库，以及如何使用外部头文件和外部共享库.毕竟，这是程序编写中最常使用的（对了，你知道用怎样的 gcc 参数可以直接构建静态库和动态库吗？） 五、静态库与动态库构建 读者云，太能罗唆了，一个 Hello World 就折腾了两个大节。OK，从本节开始，我们不再折腾 Hello World 了，我们来折腾 Hello World 的共享库。 本节的任务： 1 建立一个静态库和动态库，提供 HelloFunc 函数供其他程序编程使用，HelloFunc 向终端输出 Hello World 字符串。 2 安装头文件与共享库。 1. 准备工作 在 /backup/cmake 目录建立 t3 目录，用于存放本节涉及到的工程。 2. 建立共享库 cd /backup/cmake/t3 mkdir lib 在 t3 目录下建立 CMakeLists.txt，内容如下： PROJECT(HELLOLIB) ADD_SUBDIRECTORY(lib) 在 lib 目录下建立两个源文件 hello.c 与 hello.h hello.c 内容如下： #include \"hello.h\" void HelloFunc() { printf(\"Hello World\\n\"); } hello.h 内容如下： #ifndef HELLO_H #define HELLO_H #include void HelloFunc(); #endif 在 lib 目录下建立 CMakeLists.txt，内容如下： SET(LIBHELLO_SRC hello.c) ADD_LIBRARY(hello SHARED ${LIBHELLO_SRC}) 3.编译共享库 仍然采用 out-of-source 编译的方式，按照习惯，我们在 t3 目录建立一个 build 目录，在 build 目录中： cmake .. make 这时，你就可以在 t3/build/lib 目录得到一个 libhello.so，这就是我们期望的共享库。 @Gavin注：在Windows的Cygwin环境下，该共享库为 cyghello.dll。 如果你需要指定 libhello.so 生成的位置，可以通过在主工程文件 CMakeLists.txt 中修改 ADD_SUBDIRECTORY(lib) 指令来指定一个编译输出位置或者在 lib/CMakeLists.txt 中添加 SET(LIBRARY_OUTPUT_PATH ) 来指定一个新的位置。 这两者的区别我们上一节已经提到了，所以，这里不再赘述。下面，我们解释一下一个新的指令 ADD_LIBRARY ： ADD_LIBRARY(libname [SHARED|STATIC|MODULE] [EXCLUDE_FROM_ALL] source1 source2 ... sourceN ) 你不需要写全 libhello.so，只需要填写 hello 即可，cmake 系统会自动为你生成 libhello.X。 类型有三种： 1 SHARED，动态库 2 STATIC，静态库 3 MODULE，在使用 dyld 的系统有效，如果不支持 dyld，则被当作 SHARED 对待。 EXCLUDE_FROM_ALL 参数的意思是这个库不会被默认构建，除非有其他的组件依赖或者手工构建。 4. 添加静态库 同样使用上面的指令，我们在支持动态库的基础上再为工程添加一个静态库。按照一般的习惯，静态库名字跟动态库名字应该是一致的，只不过后缀是.a 罢了。 下面我们用这个指令再来添加静态库，在 t3/lib 的 CMakeLists.txt 文件中添加如下指令： ADD_LIBRARY(hello STATIC ${LIBHELLO_SRC}) 然后再在 build 目录进行外部编译。我们会发现，静态库根本没有被构建，仍然只生成了一个动态库。因为 hello 作为一个 target 是不能重名的，所以，静态库构建指令无效。 如果我们把上面的 hello 修改为 hello_static： ADD_LIBRARY(hello_static STATIC ${LIBHELLO_SRC}) 就可以构建一个 libhello_static.a 的静态库了。 这种结果显示不是我们想要的，我们需要的是名字相同的静态库和动态库，因为 target 名称是唯一的。所以，我们肯定不能通过 ADD_LIBRARY 指令来实现了。这时候我们需要用到另外一个指令： SET_TARGET_PROPERTIES，其基本语法是： SET_TARGET_PROPERTIES(target1 target2 ... PROPERTIES prop1 value1 prop2 value2 ... ) 这条指令可以用来设置输出的名称，对于动态库，还可以用来指定动态库版本和 API 版本。 在本例中，我们需要做的是向 lib/CMakeLists.txt 中添加一条： SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME \"hello\") 这样，我们就可以同时得到 libhello.so/libhello.a 两个库了。 与它对应的指令是： GET_TARGET_PROPERTY(VAR target property) 具体用法如下例，我们向 lib/CMakeListst.txt 中添加： GET_TARGET_PROPERTY(OUTPUT_VALUE hello_static OUTPUT_NAME) MESSAGE(STATUS \"This is the hello_static OUTPUT_NAME:\" ${OUTPUT_VALUE}) 如果没有这个属性定义，则返回 NOTFOUND。 让我们来检查一下最终的构建结果，我们发现，libhello.a 已经构建完成，位于 build/lib 目录中，但是 libhello.so 却消失了。这个问题的原因是：cmake 在构建一个新的 target 时，会尝试清理掉其他使用这个名字的库，因此，在构建 libhello.a 时，就会清理掉 libhello.so。 @ROSIt注: 实测 libhello.so 并没有消失, 所使用版本 cmake version 3.16.3。 为了回避这个问题，比如再次使用 SET_TARGET_PROPERTIES 定义 CLEAN_DIRECT_OUTPUT 属性。 向 lib/CMakeLists.txt 中添加： SET_TARGET_PROPERTIES(hello PROPERTIES CLEAN_DIRECT_OUTPUT 1) SET_TARGET_PROPERTIES(hello_static PROPERTIES CLEAN_DIRECT_OUTPUT 1) 这时候，我们再次进行构建，会发现 build/lib 目录中同时生成了 libhello.so 和 libhello.a。 5. 动态库版本号 按照规则，动态库是应该包含一个版本号的，我们可以看一下系统的动态库，一般情况是： libhello.so.1.2 libhello.so ->libhello.so.1 libhello.so.1->libhello.so.1.2 为了实现动态库版本号，我们仍然需要使用 SET_TARGET_PROPERTIES 指令。 具体使用方法如下： SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1) VERSION 指代动态库版本，SOVERSION 指代 API 版本。 将上述指令加入 lib/CMakeLists.txt 中，重新构建看看结果。 在 build/lib 目录会生成： libhello.so.1.2 libhello.so.1->libhello.so.1.2 libhello.so ->libhello.so.1 6. 安装共享库和头文件 以上面的例子，我们需要将 libhello.a, libhello.so.x 以及 hello.h 安装到系统目录，才能真正让其他人开发使用。在本例中我们将 hello 的共享库安装到 /lib 目录，将 hello.h 安装到 /include/hello 目录。 利用上一节了解到的 INSTALL 指令，我们向 lib/CMakeLists.txt 中添加如下指令： INSTALL(TARGETS hello hello_static LIBRARY DESTINATION lib ARCHIVE DESTINATION lib ) INSTALL(FILES hello.h DESTINATION include/hello) 注意，静态库要使用 ARCHIVE 关键字。 通过： make sudo make install 我们就可以将头文件和共享库安装到系统目录 /usr/lib 和 /usr/include/hello 中了。 @Gavin注：在Mac中，请安装到 /usr/local/lib目录下。 7. 小结 本小节，我们谈到了： 如何通过 ADD_LIBRARY 指令构建动态库和静态库。 如何通过 SET_TARGET_PROPERTIES 同时构建同名的动态库和静态库。 如何通过 SET_TARGET_PROPERTIES 控制动态库版本。 最终使用上一节谈到的 INSTALL 指令来安装头文件和动态、静态库。 在下一节，我们需要编写另一个高级一点的 Hello World 来演示怎么使用我们已经构建的共享库 libhello 和外部头文件。 六、如何使用外部共享库和头文件 抱歉，本节仍然继续折腾 Hello World。 上一节我们已经完成了 libhello 动态库的构建以及安装，本节我们的任务很简单： 编写一个程序使用我们上一节构建的共享库。 1. 准备工作 请在 /backup/cmake 目录建立 t4 目录，本节所有资源将存储在 t4 目录。 2. 重复以前的步骤，建立src目录，编写源文件 main.c，内容如下： #include int main(void) { HelloFunc(); return 0; } 编写 t4 工程主文件 CMakeLists.txt： PROJECT(HELLO) ADD_SUBDIRECTORY(src) 编写 src/CMakeLists.txt： ADD_EXECUTABLE(main main.c) 上述工作已经严格按照我们前面几节提到的内容完成了。 3. 外部构建 按照习惯，仍然建立 build 目录，使用 cmake .. 方式构建。 构建过程： cmake .. make 构建失败，如果需要查看细节，可以使用第一节提到的方法：make VERBOSE=1 来构建。 错误输出为是： /home/qlf/backup/cmake/t4/src/main.c:1:10: fatal error: hello.h: 没有那个文件或目录 1 | #include | ^~~~~~~~~ compilation terminated. 4. 引入头文件搜索路径 hello.h 位于 /usr/include/hello 目录中，并没有位于系统标准的头文件路径，(有人会说了，白痴啊，你就不会 include 。 同志，要这么干，我这 一节就没什么可写了，只能选择一个 glib 或者 libX11 来写了，这些代码写出来很多同志是看不懂的)。 为了让我们的工程能够找到 hello.h 头文件，我们需要引入一个新的指令 INCLUDE_DIRECTORIES，其完整语法为： INCLUDE_DIRECTORIES([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...) 这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来。默认的行为是追加到当前的头文件搜索路径的后面，你可以通过两种方式来控制搜索路径添加的方式： 1 CMAKE_INCLUDE_DIRECTORIES_BEFORE，通过 SET 这个 cmake 变量为 on，可以将添加的头文件搜索路径放在已有路径的前面。 2 通过 AFTER 或者 BEFORE 参数，也可以控制是追加还是置前。 现在我们在 src/CMakeLists.txt 中添加一个头文件搜索路径，方式很简单，加入： INCLUDE_DIRECTORIES(/usr/include/hello) 进入 build 目录，重新进行构建，这时找不到 hello.h 的错误已经消失，但是出现了一个新的错误： main.c:(.text+0xe): undefined reference to `HelloFunc' 因为我们并没有 link 到共享库 libhello 上。 5. 为 target 添加共享库 我们现在需要完成的任务是将目标文件链接到 libhello，这里我们需要引入两个新的指令：LINK_DIRECTORIES 和 TARGET_LINK_LIBRARIES。 LINK_DIRECTORIES 的全部语法是： LINK_DIRECTORIES(directory1 directory2 ...) 这个指令非常简单，添加非标准的共享库搜索路径。比如，在工程内部同时存在共享库和可执行二进制，在编译时就需要指定一下这些共享库的路径。这个例子中我们没有用到这个指令。 TARGET_LINK_LIBRARIES 的全部语法是： TARGET_LINK_LIBRARIES(target library1 library2 ...) 这个指令可以用来为 target 添加需要链接的共享库。本例中是一个可执行文件，但是同样可以用于为自己编写的共享库添加共享库链接。 @ROSIt注:TARGET_LINK_LIBRARIES是一条重要指令，ROS中也会用到 为了解决前面我们遇到的 HelloFunc 未定义错误，我们需要做的是向 src/CMakeLists.txt 中添加如下指令： TARGET_LINK_LIBRARIES(main hello) 也可以写成： TARGET_LINK_LIBRARIES(main libhello.so) 这里的 hello 指的是我们上一节构建的共享库 libhello。 进入 build 目录重新进行构建： cmake .. make 这时我们就得到了一个链接到 libhello 的可执行程序 main，位于 t4/build/src 目录。切换到 t4/build/src 目录，在终端执行./main，运行结果如下： Hello World 让我们来检查一下 main 的链接情况。在 t4/build 目录中打开终端，执行ldd src/main，输出结果如下： linux-vdso.so.1 (0x00007fff44f8f000) libhello.so.1 => /lib/libhello.so.1 (0x00007f566802d000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f5667e3b000) /lib64/ld-linux-x86-64.so.2 (0x00007f5668075000) 可以清楚的看到 main 确实链接了共享库 libhello，而且链接的是动态库 libhello.so.1。 那如何链接到静态库呢？ 方法很简单： 将 TARGET_LINK_LIBRRARIES 指令修改为： TARGET_LINK_LIBRARIES(main libhello.a) 重新构建后再来看一下 main 的链接情况。在 t4/build 目录中打开终端，执行ldd src/main，输出结果如下： linux-vdso.so.1 (0x00007ffdbb5e4000) libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f86c713a000) /lib64/ld-linux-x86-64.so.2 (0x00007f86c736f000) 说明，main 确实链接到了静态库 libhello.a。 6. 特殊的环境变量 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH 务必注意，这两个是环境变量而不是 cmake 变量。 使用方法是要在 bash 中用 export 或者在 csh 中使用 set 命令设置或者 CMAKE_INCLUDE_PATH=/home/include cmake ..等方式。 这两个变量主要是用来解决以前 autotools 工程中 --extra-include-dir 等参数的支持的。 也就是，如果头文件没有存放在常规路径(/usr/include, /usr/local/include 等)，则可以通过这些变量就行弥补。 我们以本例中的 hello.h 为例，它存放在 /usr/include/hello 目录，所以直接查找肯定是找不到的。 前面我们直接使用了绝对路径 INCLUDE_DIRECTORIES(/usr/include/hello) 告诉工程这个头文件目录。 为了将程序更智能一点，我们可以使用 CMAKE_INCLUDE_PATH 来进行，使用 bash 的方法如下，在终端中输入： export CMAKE_INCLUDE_PATH=/usr/include/hello 然后将 t4/src 目录 CMakeLists.txt 中的INCLUDE_DIRECTORIES(/usr/include/hello) 替换为： FIND_PATH(myHeader hello.h) IF(myHeader) INCLUDE_DIRECTORIES(${myHeader}) ENDIF(myHeader) 上述的一些指令我们在后面会介绍。 这里简单说明一下，FIND_PATH 用来在指定路径中搜索文件名，比如: FIND_PATH(myHeader NAMES hello.h PATHS /usr/include /usr/include/hello) 这里我们没有指定路径。但是，cmake 仍然可以帮我们找到 hello.h 存放的路径，就是因为我们设置了环境变量 CMAKE_INCLUDE_PATH。 如果你不使用 FIND_PATH，CMAKE_INCLUDE_PATH 变量的设置是没有作用的，你不能指望它会直接为编译器命令添加参数 -I。 以此为例，CMAKE_LIBRARY_PATH 可以用在 FIND_LIBRARY 中。 同样，因为这些变量直接为 FIND 指令所使用，所以所有使用 FIND_ 指令的 cmake 模块都会受益。 7. 小结 本节我们探讨了： 如何通过 INCLUDE_DIRECTORIES 指令加入非标准的头文件搜索路径。 如何通过 LINK_DIRECTORIES 指令加入非标准的库文件搜索路径。 如果通过 TARGET_LINK_LIBRARIES 为库或可执行二进制加入库链接。 并解释了如何链接到静态库。 到这里为止，您应该基本可以使用 cmake 工作了，但是还有很多高级的话题没有探讨，比如编译条件检查、编译器定义、平台判断、如何跟 pkgconfig 配合使用等等。 到这里，或许你可以理解前面讲到的“cmake 的使用过程其实就是学习 cmake 语言并编写 cmake 程序的过程”，既然是“cmake 语言”，自然涉及到变量、语法等。 下一节，我们将抛开程序的话题，看看常用的 CMAKE 变量以及一些基本的控制语法规则。 七、cmake 常用变量和常用环境变量 1. cmake 变量引用的方式 前面我们已经提到了，使用${}进行变量的引用。在 IF 等语句中，是直接使用变量名而不通过${}取值。 2. cmake 自定义变量的方式 主要有隐式定义和显式定义两种，前面举了一个隐式定义的例子，就是 PROJECT 指令，他会隐式的定义_BINARY_DIR 和_SOURCE_DIR两个变量。 显式定义的例子我们前面也提到了，使用 SET 指令，就可以构建一个自定义变量了。 比如： SET(HELLO_SRC main.c)，PROJECT_BINARY_DIR 可以通过 ${HELLO_SRC} 来引用这个自定义变量了。 3. cmake常用变量 1 CMAKE_BINARY_DIR PROJECT_BINARY_DIR _BINARY_DIR 这三个变量指代的内容是一致的，如果是 in source 编译，指得就是工程顶层目录；如果是 out-of-source 编译，指的是工程编译发生的目录。PROJECT_BINARY_DIR 跟其他指令稍有区别，现在，你可以理解为他们是一致的。 2 CMAKE_SOURCE_DIR PROJECT_SOURCE_DIR _SOURCE_DIR 这三个变量指代的内容是一致的，不论采用何种编译方式，都是工程顶层目录。 也就是在 in source 编译时，他跟 CMAKE_BINARY_DIR 等变量一致。 PROJECT_SOURCE_DIR 跟其他指令稍有区别，现在，你可以理解为他们是一致的。 3 CMAKE_CURRENT_SOURCE_DIR 指的是当前处理的 CMakeLists.txt 所在的路径，比如上面我们提到的 src 子目录。 4 CMAKE_CURRRENT_BINARY_DIR 如果是 in-source 编译，它跟 CMAKE_CURRENT_SOURCE_DIR 一致；如果是 out-ofsource 编译，他指的是 target 编译目录。 使用我们上面提到的 ADD_SUBDIRECTORY(src bin)可以更改这个变量的值。 使用 SET(EXECUTABLE_OUTPUT_PATH ) 并不会对这个变量造成影响，它仅仅修改了最终目标文件存放的路径。 5 CMAKE_CURRENT_LIST_FILE 输出调用这个变量的 CMakeLists.txt 的完整路径 6 CMAKE_CURRENT_LIST_LINE 输出这个变量所在的行 7 CMAKE_MODULE_PATH 这个变量用来定义自己的 cmake 模块所在的路径。如果你的工程比较复杂，有可能会自己编写一些 cmake 模块，这些 cmake 模块是随你的工程发布的。为了让 cmake 在处理 CMakeLists.txt 时找到这些模块，你需要通过 SET 指令，将自己的 cmake 模块路径设置一下。 比如： SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) 这时候你就可以通过 INCLUDE 指令来调用自己的模块了。 8 EXECUTABLE_OUTPUT_PATH 和 LIBRARY_OUTPUT_PATH 分别用来重新定义最终结果的存放目录，前面我们已经提到了这两个变量。 9 PROJECT_NAME 返回通过 PROJECT 指令定义的项目名称。 4. cmake 调用环境变量的方式 使用$ENV{NAME} 指令就可以调用系统的环境变量了。 设置环境变量的方式是： SET(ENV{变量名} 值) 1 CMAKE_INCLUDE_CURRENT_DIR 自动添加 CMAKE_CURRENT_BINARY_DIR 和 CMAKE_CURRENT_SOURCE_DIR 到当前处理的 CMakeLists.txt。相当于在每个 CMakeLists.txt 加入： INCLUDE_DIRECTORIES(${CMAKE_CURRENT_BINARY_DIR} ${CMAKE_CURRENT_SOURCE_DIR}) 2 CMAKE_INCLUDE_DIRECTORIES_PROJECT_BEFORE 将工程提供的头文件目录始终置于系统头文件目录的前面，当你定义的头文件确实跟系统发生冲突时可以提供一些帮助。 3 CMAKE_INCLUDE_PATH 和 CMAKE_LIBRARY_PATH 我们在上一节已经提及。 5. 系统信息 1 CMAKE_MAJOR_VERSION，CMAKE 主版本号，比如 2.4.6 中的 2 2 CMAKE_MINOR_VERSION，CMAKE 次版本号，比如 2.4.6 中的 4 3 CMAKE_PATCH_VERSION，CMAKE 补丁等级，比如 2.4.6 中的 6 4 CMAKE_SYSTEM，系统名称，比如 Linux-2.6.22 5 CMAKE_SYSTEM_NAME，不包含版本的系统名，比如 Linux 6 CMAKE_SYSTEM_VERSION，系统版本，比如 2.6.22 7 CMAKE_SYSTEM_PROCESSOR，处理器名称，比如 i686 8 UNIX，在所有的类 UNIX 平台为 TRUE，包括 OS X 和 cygwin 9 WIN32，在所有的 win32 平台为 TRUE，包括 cygwin 6. 主要的开关选项 1 MAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS，用来控制 IF ELSE语句的书写方式，在下一节语法部分会讲到。 2 BUILD_SHARED_LIBS 这个开关用来控制默认的库编译方式，如果不进行设置，使用 ADD_LIBRARY 并没有指定库类型的情况下，默认编译生成的库都是静态库。 3 CMAKE_C_FLAGS 设置C编译选项，也可以通过指令ADD_DEFINITIONS()添加。 4 CMAKE_CXX_FLAGS 设置C++编译选项，也可以通过指令ADD_DEFINITIONS()添加。 7.小结 本章介绍了一些较常用的 cmake 变量，这些变量仅仅是所有 cmake 变量的很少一部分。目前 cmake 的英文文档也是比较缺乏的，如果需要了解更多的 cmake 变量，更好的方式是阅读一些成功项目的 cmake 工程文件，比如 KDE4 的代码。 八、cmkae 常用指令 前面我们讲到了 cmake 常用的变量，相信“cmake 即编程”的感觉会越来越明显。无论如何，我们仍然可以看到 cmake 比 autotools 要简单很多。接下来我们就要集中的看一看 cmake 所提供的常用指令。在前面的章节我们已经讨论了很多指令的用法，如 PROJECT，ADD_EXECUTABLE，INSTALL，ADD_SUBDIRECTORY，SUBDIRS，INCLUDE_DIRECTORIES，LINK_DIRECTORIES，TARGET_LINK_LIBRARIES，SET等。 1. 基本指令 1 ADD_DEFINITIONS 向C，C++编译器添加-D定义，比如： ADD_DEFINITIONS(-DENABLE_DEBUG -DABC)，参数之间用空格分割。 如果你的代码中定义了#ifdef ENABLE_DEBUG #endif，这个代码块就会生效。 如果要添加其他的编译器开关，可以通过 CMAKE_C_FLAGS 变量和 CMAKE_CXX_FLAGS 变量设置。 2 ADD_DEPENDENCIES 定义 target 依赖的其他 target，确保在编译本 target 之前，其他的 target 已经被构建。 ADD_DEPENDENCIES(target-name depend-target1 depend-target2 ...) 3 ADD_EXECUTABLE、ADD_LIBRARY、ADD_SUBDIRECTORY 前面已经介绍过了，这里不再罗唆。 4 ADD_TEST 与 ENABLE_TESTING 指令 ENABLE_TESTING 指令用来控制 Makefile 是否构建 test 目标，涉及工程所有目录。语法很简单，没有任何参数，ENABLE_TESTING()，一般情况这个指令放在工程的主CMakeLists.txt 中。 ADD_TEST 指令的语法是： ADD_TEST(testname Exename arg1 arg2 ...) testname 是自定义的 test 名称，Exename 可以是构建的目标文件也可以是外部脚本等等。后面连接传递给可执行文件的参数。如果没有在同一个 CMakeLists.txt 中打开ENABLE_TESTING()指令，任何 ADD_TEST 都是无效的。 比如我们前面的 Helloworld 例子，可以在工程主 CMakeLists.txt 中添加 ADD_TEST(mytest ${PROJECT_BINARY_DIR}/bin/main) ENABLE_TESTING() 生成 Makefil e后，就可以运行 make test 来执行测试了。 5 AUX_SOURCE_DIRECTORY 基本语法是： AUX_SOURCE_DIRECTORY(dir VARIABLE) 作用是发现一个目录下所有的源代码文件并将列表存储在一个变量中，这个指令临时被用来自动构建源文件列表。因为目前 cmake 还不能自动发现新添加的源文件。 比如： AUX_SOURCE_DIRECTORY(. SRC_LIST) ADD_EXECUTABLE(main ${SRC_LIST}) 你也可以通过后面提到的 FOREACH 指令来处理这个 LIST。 6 CMAKE_MINIMUM_REQUIRED 其语法为 CMAKE_MINIMUM_REQUIRED(VERSION versionNumber [FATAL_ERROR]) 比如 CMAKE_MINIMUM_REQUIRED(VERSION 2.5 FATAL_ERROR) 如果 cmake 版本小与 2.5，则出现严重错误，整个过程中止。 7 EXEC_PROGRAM 在 CMakeLists.txt 处理过程中执行命令，并不会在生成的 Makefile 中执行。具体语法为: EXEC_PROGRAM(Executable [directory in which to run] [ARGS ] [OUTPUT_VARIABLE ] [RETURN_VALUE ]) 用于在指定的目录运行某个程序，通过 ARGS 添加参数。如果要获取输出和返回值，可通过 OUTPUT_VARIABLE 和 RETURN_VALUE 分别定义两个变量。 这个指令可以帮助你在 CMakeLists.txt 处理过程中支持任何命令，比如根据系统情况去 修改代码文件等等。 举个简单的例子，我们要在 src 目录执行 ls 命令，并把结果和返回值存下来。 可以直接在 src/CMakeLists.txt 中添加： EXEC_PROGRAM(ls ARGS \"*.c\" OUTPUT_VARIABLE LS_OUTPUT RETURN_VALUE LS_RVALUE) IF(not LS_RVALUE) MESSAGE(STATUS \"ls result: \" ${LS_OUTPUT}) ENDIF(not LS_RVALUE) 在cmake 生成 Makefile 的过程中，就会执行 `ls`` 命令，如果返回0，则说明成功执行，那么就输出ls *.c的结果。关于IF语句，后面的控制指令会提到。 8 FILE 指令 文件操作指令，基本语法为： FILE(WRITE filename \"message to write\"... ) FILE(APPEND filename \"message to write\"... ) FILE(READ filename variable) FILE(GLOB variable [RELATIVE path] [globbing expressions]...) FILE(GLOB_RECURSE variable [RELATIVE path] [globbing expressions]...) FILE(REMOVE [directory]...) FILE(REMOVE_RECURSE [directory]...) FILE(MAKE_DIRECTORY [directory]...) FILE(RELATIVE_PATH variable directory file) FILE(TO_CMAKE_PATH path result) FILE(TO_NATIVE_PATH path result) 这里的语法都比较简单，不在展开介绍了。 9 INCLUDE 指令，用来载入 CMakeLists.txt 文件，也用于载入预定义的 cmake 模块 INCLUDE(file1 [OPTIONAL]) INCLUDE(module [OPTIONAL]) OPTIONAL 参数的作用是文件不存在也不会产生错误。 你可以指定载入一个文件，如果定义的是一个模块，那么将在 CMAKE_MODULE_PATH 中搜 索这个模块并入。 载入的内容将在处理到 INCLUDE 语句是直接执行。 2. INSTALL 指令 INSTALL 系列指令已经在前面的章节有非常详细的说明，这里不在赘述，可参考前面的安装部分。 3. FIND指令 FIND_ 系列指令主要包含一下指令： FIND_FILE( name1 path1 path2 ...) VAR 变量代表找到的文件全路径，包含文件名 FIND_LIBRARY( name1 path1 path2 ...) VAR 变量表示找到的库全路径，包含库文件名 FIND_PATH( name1 path1 path2 ...) VAR 变量代表包含这个文件的路径。 FIND_PROGRAM( name1 path1 path2 ...) VAR 变量代表包含这个程序的全路径。 FIND_PACKAGE( [major.minor] [QUIET] [NO_MODULE] [[REQUIRED|COMPONENTS] [componets...]]) 用来调用预定义在 CMAKE_MODULE_PATH 下的 Find.cmake 模块，你也可以自己 定义Find模块，通过SET(CMAKE_MODULE_PATH dir)将其放入工程的某个目录 中供工程使用。我们在后面的章节会详细介绍FIND_PACKAGE 的使用方法和 Find 模块的编写。 FIND_LIBRARY 示例： FIND_LIBRARY(libX X11 /usr/lib) IF(NOT libX) MESSAGE(FATAL_ERROR “libX not found”) ENDIF(NOT libX) 4. 控制指令 1 IF指令 基本语法为： IF(expression) # THEN section. COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ELSE(expression) # ELSE section. COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDIF(expression) 另外一个指令是 ELSEIF，总体把握一个原则，凡是出现 IF 的地方一定要有对应的 ENDIF。出现 ELSEIF 的地方，ENDIF 是可选的。 表达式的使用方法如下： IF(var)，如果变量不是：空，0，N, NO, OFF, FALSE, NOTFOUND 或_NOTFOUND 时，表达式为真。 IF(NOT var )，与上述条件相反。 IF(var1 AND var2)，当两个变量都为真是为真。 IF(var1 OR var2)，当两个变量其中一个为真时为真。 IF(COMMAND cmd)，当给定的 cmd 确实是命令并可以调用时为真。 IF(EXISTS dir)或者IF(EXISTS file)，当目录名或者文件名存在时为真。 IF(file1 IS_NEWER_THAN file2)，当 file1 比 file2 新，或者 file1/file2 其 中有一个不存在时为真，文件名请使用完整路径。 IF(IS_DIRECTORY dirname)，当 dirname 是目录时，为真。 IF(variable MATCHES regex) IF(string MATCHES regex) 当给定的变量或者字符串能够匹配正则表达式 regex 时为真。比如： IF(\"hello\" MATCHES \"ell\") MESSAGE(\"true\") ENDIF(\"hello\" MATCHES \"ell\") # 数字比较表达式 IF(variable LESS number) IF(string LESS number) IF(variable GREATER number) IF(string GREATER number) IF(variable EQUAL number) IF(string EQUAL number) # 按照字母序的排列进行比较 IF(variable STRLESS string) IF(string STRLESS string) IF(variable STRGREATER string) IF(string STRGREATER string) IF(variable STREQUAL string) IF(string STREQUAL string) IF(DEFINED variable)，如果变量被定义，为真。 一个小例子，用来判断平台差异： IF(WIN32) MESSAGE(STATUS “This is windows.”) # 做一些 Windows 相关的操作 ELSE(WIN32) MESSAGE(STATUS “This is not windows”) # 做一些非 Windows 相关的操作 ENDIF(WIN32) 上述代码用来控制在不同的平台进行不同的控制，但是，阅读起来却并不是那么舒服，ELSE(WIN32)之类的语句很容易引起歧义。 这就用到了我们在“常用变量”一节提到的 CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS 开关。 可以SET(CMAKE_ALLOW_LOOSE_LOOP_CONSTRUCTS ON) 这时候就可以写成： IF(WIN32) ELSE() ENDIF() 如果配合 ELSEIF 使用，可能的写法是这样： IF(WIN32) #do something related to WIN32 ELSEIF(UNIX) #do something related to UNIX ELSEIF(APPLE) #do something related to APPLE ENDIF(WIN32) 2 WHILE WHILE 指令的语法是： WHILE(condition) COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDWHILE(condition) 其真假判断条件可以参考 IF 指令。 3 FOREACH FOREACH 指令的使用方法有三种形式： 1 列表 ``` FOREACH(loop_var arg1 arg2 ...) COMMAND1(ARGS ...) COMMAND2(ARGS ...) ... ENDFOREACH(loop_var) ``` 像我们前面使用的 `AUX_SOURCE_DIRECTORY` 的例子 ``` AUX_SOURCE_DIRECTORY(. SRC_LIST) FOREACH(F ${SRC_LIST}) MESSAGE(${F}) ENDFOREACH(F) ``` 2 范围 ``` FOREACH(loop_var RANGE total) ENDFOREACH(loop_var) ``` 从 0 到 total 以 1 为步进。 举例如下： ``` FOREACH(VAR RANGE 10) MESSAGE(${VAR}) ENDFOREACH(VAR) ``` 得到的结果是： ``` 0 1 2 3 4 5 6 7 8 9 10 ``` 3 范围和步进 ``` FOREACH(loop_var RANGE start stop [step]) ENDFOREACH(loop_var) ``` 从 start 开始到 stop 结束，以 step 为步进， 举例如下： ``` FOREACH(A RANGE 5 15 3) MESSAGE(${A}) ENDFOREACH(A) ``` 最终得到的结果是: ``` 5 8 11 14 ``` 这个指令需要注意的是，直到遇到 ENDFOREACH 指令，整个语句块才会得到真正的执行。 5.小结 本小节基本涵盖了常用的 cmake 指令，包括基本指令、查找指令、安装指令以及控制语句等。特别需要注意的是，在控制语句条件中使用变量，不能用${}引用，而是直接应用变量名。 掌握了以上的各种控制指令，你应该完全可以通过 cmake 管理复杂的程序了。下一节，我们将介绍一个比较复杂的例子，通过他来演示本章的一些指令，并介绍模块的概念。 九、复杂的例子：模块的使用和自定义 你现在还会觉得 cmake 简单吗？ 本章我们将着重介绍系统预定义的 Find 模块的使用以及自己编写 Find 模块。系统中提供了其他各种模块，一般情况需要使用 INCLUDE 指令显式的调用，FIND_PACKAGE 指令是一个特例，可以直接调用预定义的模块。 其实使用纯粹依靠 cmake 本身提供的基本指令来管理工程是一件非常复杂的事情。所以，cmake 设计成了可扩展的架构，可以通过编写一些通用的模块来扩展 cmake。 在本章，我们准备首先介绍一下 cmake 提供的 FindCURL 模块的使用。然后，基于我们前面的 libhello 共享库，编写一个 FindHello.cmake 模块。 1. 使用 FindCURL 模块 在 /backup/cmake 目录建立 t5 目录，用于存放我们的 CURL 的例子。 建立 src 目录，并建立 src/main.c，内容如下： #include #include #include #include FILE *fp; int write_data(void *ptr, size_t size, size_t nmemb, void *stream) { int written = fwrite(ptr, size, nmemb, (FILE *)fp); return written; } int main() { const char * path = \"/tmp/curl-test\"; const char * mode = \"w\"; fp = fopen(path, mode); curl_global_init(CURL_GLOBAL_ALL); CURLcode res; CURL *curl = curl_easy_init(); curl_easy_setopt(curl, CURLOPT_URL, \"https://www.baidu.com\"); curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_data); curl_easy_setopt(curl, CURLOPT_VERBOSE, 1); res = curl_easy_perform(curl); curl_easy_cleanup(curl); } 这段代码的作用是通过 curl 取回 www.linux-ren.org 的首页并写入 /tmp/curl-test 文件中。 @Gavin注：原书中的 www.linux-ren.org 会产生301重定向，建议换成其他，比如：https://www.baidu.com 建立 t5 主工程文件 CMakeLists.txt： PROJECT(CURLTEST) ADD_SUBDIRECTORY(src) 建立 src/CMakeLists.txt： ADD_EXECUTABLE(curltest main.c) 现在自然是没办法编译的，我们需要添加 curl 的头文件路径和库文件。 方法 1： 直接通过 INCLUDE_DIRECTORIES 和 TARGET_LINK_LIBRARIES 指令添加 我们可以直接在 src/CMakeLists.txt 中添加： INCLUDE_DIRECTORIES(/usr/include) TARGET_LINK_LIBRARIES(curltest curl) 方法2： 我们要探讨的是使用 cmake 提供的 FindCURL 模块。 向 src/CMakeLists.txt 中添加： FIND_PACKAGE(CURL) IF(CURL_FOUND) INCLUDE_DIRECTORIES(${CURL_INCLUDE_DIR}) TARGET_LINK_LIBRARIES(curltest ${CURL_LIBRARY}) ELSE(CURL_FOUND) MESSAGE(FATAL_ERROR ”CURL library not found”) ENDIF(CURL_FOUND) 对于系统预定义的 Find.cmake 模块，使用方法一般如上例所示： 每一个模块都会定义以下几个变量： _FOUND _INCLUDE_DIR or _INCLUDES _LIBRARY or _LIBRARIES 你可以通过_FOUND来判断模块是否被找到，如果没有找到，按照工程的需要关闭某些特性、给出提醒或者中止编译，上面的例子就是报出致命错误并终止构建。 如果 _FOUND 为真，则将 _INCLUDE_DIR 加入 INCLUDE_DIRECTORIES， 将 _LIBRARY 加入 TARGET_LINK_LIBRARIES 中。 方法1或者方法2操作完成后，建立 build目录，进行外部构建，在终端中输入： cmake .. make 即可在 /build/src 目录下得到可执行文件 curltest 我们再来看一个复杂的例子，通过 _FOUND 来控制工程特性： SET(mySources viewer.c) SET(optionalSources) SET(optionalLibs) FIND_PACKAGE(JPEG) IF(JPEG_FOUND) SET(optionalSources ${optionalSources} jpegview.c) INCLUDE_DIRECTORIES( ${JPEG_INCLUDE_DIR} ) SET(optionalLibs ${optionalLibs} ${JPEG_LIBRARIES} ) ADD_DEFINITIONS(-DENABLE_JPEG_SUPPORT) ENDIF(JPEG_FOUND) IF(PNG_FOUND) SET(optionalSources ${optionalSources} pngview.c) INCLUDE_DIRECTORIES( ${PNG_INCLUDE_DIR} ) SET(optionalLibs ${optionalLibs} ${PNG_LIBRARIES} ) ADD_DEFINITIONS(-DENABLE_PNG_SUPPORT) ENDIF(PNG_FOUND) ADD_EXECUTABLE(viewer ${mySources} ${optionalSources} ) TARGET_LINK_LIBRARIES(viewer ${optionalLibs} 通过判断系统是否提供了 JPEG 库来决定程序是否支持 JPEG 功能。 2. 编写属于自己的 FindHello 模块 @ROSIT注: 代码未测试成功 我们在此前的 t3 实例中，演示了构建动态库、静态库的过程并进行了安装。 接下来，我们在 t6 示例中演示如何自定义 FindHELLO 模块并使用这个模块构建工程： 在 /backup/cmake/ 中建立 t6 目录，并在其中建立 cmake目录用于存放我们自己定义的 FindHELLO.cmake 模块。同时建立 src 目录，用于存放我们的源文件。 1 进入到 t6/cmake目录，新建 FindHELLO.cmake 文件，并填写如下内容： FIND_PATH(HELLO_INCLUDE_DIR hello.h /usr/include/hello /usr/local/include/hello) FIND_LIBRARY(HELLO_LIBRARY NAMES hello PATH /usr/lib /usr/local/lib) IF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY) SET(HELLO_FOUND TRUE) ENDIF(HELLO_INCLUDE_DIR AND HELLO_LIBRARY) IF(HELLO_FOUND) IF(NOT HELLO_FIND_QUIETLY) MESSAGE(STATUS \"Found Hello: ${HELLO_LIBRARY}\") ENDIF(NOT HELLO_FIND_QUIETLY) ELSE(HELLO_FOUND) IF(HELLO_FIND_REQUIRED) MESSAGE(FATAL_ERROR \"Could not find hello library\") ENDIF(HELLO_FIND_REQUIRED) ENDIF(HELLO_FOUND) 针对上面的模块让我们再来回顾一下 FIND_PACKAGE 指令： FIND_PACKAGE( [major.minor] [QUIET] [NO_MODULE] [[REQUIRED|COMPONENTS] [componets...]]) 前面的 CURL 例子中我们使用了最简单的 FIND_PACKAGE 指令。其实他可以使用多种参数：QUIET参数，对应与我们编写的 FindHELLO 中的 HELLO_FIND_QUIETLY，如果不指定这个参数，就会执行： MESSAGE(STATUS \"Found Hello: ${HELLO_LIBRARY}\") REQUIRED 参数，其含义是指这个共享库是否是工程必须的。如果使用了这个参数，说明这个链接库是必备库，如果找不到这个链接库，则工程不能编译。对应于FindHELLO.cmake模块中的 HELLO_FIND_REQUIRED 变量。 同样，我们在上面的模块中定义了 HELLO_FOUND, HELLO_INCLUDE_DIR, HELLO_LIBRARY 变量供开发者在FIND_PACKAGE 指令中使用。 OK，下面建立 src/main.c，内容为： #include int main() { HelloFunc(); return 0; } 建立 src/CMakeLists.txt 文件，内容如下： FIND_PACKAGE(HELLO) IF(HELLO_FOUND) ADD_EXECUTABLE(hello main.c) INCLUDE_DIRECTORIES(${HELLO_INCLUDE_DIR}) TARGET_LINK_LIBRARIES(hello ${HELLO_LIBRARY}) ENDIF(HELLO_FOUND) 为了能够让工程找到 FindHELLO.cmake 模块(存放在工程中的 cmake 目录)，我们在 t6 主工程文件 CMakeLists.txt 中加入： SET(CMAKE_MODULE_PATH ${PROJECT_SOURCE_DIR}/cmake) 3. 使用自定义的 FindHELLO 模块构建工程 仍然采用外部编译的方式，建立 build 目录，进入目录运行： cmake .. 我们可以从输出中看到： Found Hello: /usr/lib/libhello.so 如果我们把上面的FIND_PACKAGE(HELLO)修改为FIND_PACKAGE(HELLO QUIET)，则不会看到上面的输出。 接下来就可以使用 make 命令构建工程，运行：./src/hello 可以得到输出： Hello World。 说明工程成功构建。 4. 如果没有找到 hello library 呢? 我们可以尝试将 /usr/lib/libhello.x 移动到 /tmp 目录，这样，按照 FindHELLO 模块的定义，就找不到 hello library 了，我们再来看一下构建结果： cmake .. 仍然可以成功进行构建，但是这时候是没有办法编译的。 修改FIND_PACKAGE(HELLO)为FIND_PACKAGE(HELLO REQUIRED)，将 hello library 定义为工程必须的共享库。 这时候再次运行cmake .. 我们得到如下输出： CMake Error: Could not find hello library 因为找不到 libhello.x，所以，整个 Makefile 生成过程被出错中止。 5.小结 在本节中，我们学习了如何使用系统提供的 Find 模块并学习了自己编写 Find 模块以及如何在工程中使用这些模块。 后面的章节，我们会逐渐学习更多的 cmake 模块使用方法以及用 cmake 来管理 GTK 和 QT4 工程。 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Shared/":{"url":"Markdown/Shared/","title":"C 优秀案例","keywords":"","body":"C 共享资源 欢迎来到师兄师姐资源分享页面！❤️‍❤️‍ 这是一个旨在帮助师兄师姐们与学弟学妹们建立更紧密联系的在线平台。致力于创建一个集体智慧的知识库，让高年级同学能够分享自己的经验、资源和宝贵建议，帮助新生更好地适应校园生活和学术挑战。⛱⛱ 无论你是高年级的师兄师姐还是刚刚踏入校门的学弟学妹，都可以分享、获取和互相学习。⛄⛄ 提供分享资源，企业微信联系：郄龙飞✅ new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "},"Markdown/Shared/ljt_jg2102.html":{"url":"Markdown/Shared/ljt_jg2102.html","title":"1 李霁桐-机工2102","keywords":"","body":"会打招呼的小机器人 作者：李霁桐-机工2102 链接：https://pan.baidu.com/s/1pAA77Lhh1mizlMrXfWxftg?pwd=6666 提取码：6666 演示视频 1 前言 这个小机器人最早是大一时期在网站上偶然看到的 那个时候看见这个很新鲜，话说小学毕业之后没玩过什么像样的玩具，当即决定（坏笑）就是它了，搞一个玩玩。 2 机械结构 每个腿有两个自由度，上下升降为最简单的四杆机构。 所有零件均采用3D打印，方便，便宜，省事（赞！）。 我是用自己的3D打印机做的，建议大家没有打印机的在三维猴，或者未来工厂的网站上上传自己的文件请他们来打印，费用不太高，质量不错。一点注意零件数量选对。还有，记得买螺栓，长一点，长度参考SoiledWorks里面的模型选一种。 于是我最后做了这个 （它是小黑，是上面第一张照片中小白的孪生哥哥，现在在工训中心402竞赛社） 这是我大学以来制作的第一件作（wan）品（ju）。 3 电路部分 电路部分采用PCA9685多路PWM舵机驱动板，这个板子的好处就是节省了主控的引脚，主控只需要两根信号引脚加上其他供电引脚就可以实现控制多路舵机的角度（要不然还得一大堆线插在主控上，哈哈） 主控器采用esp8266，很短暂地使用过Arduino开发板。后来偶然的一次使用WiFi模块做遥控车的时候，用不明白上网查了查，看完吓了一跳，esp8266的性能对Arduino UNO几乎是碾压性的优势，而当时我居然只想着用这么强大的东西简简单单做一个天线（就好比用精车加工钢管晾衣服）。于是我果断买了一块esp8266开发板。 所以整体接线非常简单： 1、PCA9685的SCL接esp8266的SCL 2、PCA9685的SDA接esp8266的SDA 3、PCA9685的GND接esp8266的GND 4、PCA9685的VCC接esp8266的3.3V（可能标着3V3） 5、PCA9685的V+接esp8266的VIN 这就完了。 4 程序烧录 随便上网找找安装Arduino环境，应该还是很好找的，然后参考教程添加esp8266的支持包。 打开文件中“硬件代码”文件夹，打开对应Arduino工程就好了（robt_drive那个），记得修改里面的WIFI名称和密码，改成自己电脑热点的名称和密码，然后点击烧录即可。： 烧录完成后，打开串口监视器，波特率调成115200（也可能是9600，我忘了）按一下esp8266的复位键，就可以得到一串类似于192.168.31.0的数字，在浏览器网址输入处粘贴这段数字就能进入一个空白网页，网页里面只有一个写着Hello的按钮，按下它你的机器人就会和你打招呼（如果你正好在他前方，如果不在它也会朝空气打招呼）。 到这里，这个机器人做完了。 怎么。你还想往下看？？？ 那好，还可以来点更进阶的。 5 Opencv手势交互 其实前几部分完成已经很不错了，后面的东西需要一些基础，如果你用过pycharm就够了。 首先你需要在Arduino环境中额外再配置一个esp32的支持包，这个很重要，然后烧录jiqichongwu这个工程的代码（在“硬件代码”文件夹里面）。 烧录完成后打开串口监视器（记得调波特率），也会获得一串类似192.169.31.0这样的IP地址。 然后用pycharm打开视觉识别那个工程进去（打开那个main.py文件）编译器先选Scripts文件夹下面的ptyhon.exe，这个工程我临时整理的，要是不能用可以直接联系我。 用刚才串口监视器得到的IP地址替换掉我上图里面的这段，这样你的电脑就能连接到esp32cam，并把它的图像传进来。 6 一些问题 1 图像刚传进来会直接显示出来，建议把画面调成全屏，这样我的程序启动的时候它会接管你的鼠标自动把整个画面窗口最小化。 网页得调整到合适大小，因为我的python程序是直接控制鼠标去点击网页中的Hello按钮，所以要事先调好网页的位置让鼠标正好能点到（不要问我为啥不直接发指令，我不会啊，，，）。 2 如果你解决了上面的问题，你朝摄像头打招呼，它就能朝你打招呼啦。 3 最后你还可能因为帧率低的问题得不到机器人的回应，这样我们就得到了一个高冷（呆滞）的机器人。 4 行，就这么多，感兴趣的其他细节可以企业微信联系我。 new Valine({el: \"#vcomments\",appId: '3D2fncm2tN4FI5duTIQA11qY-gzGzoHsz',appKey: 'qh5zfPEVsjNxqCWz3hZMGaPB',placeholder: 'Just go go',avatar: '',meta: undefined,pageSize: 10,lang: 'zh-CN',recordIP: false}) "}}